<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.MicroKernel</name>
    </assembly>
    <members>
        <member name="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator">
            <summary>
            Abstract implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
            The implementors must only override the InternalCreate and 
            InternalDestroy methods in order to perform their creation and
            destruction logic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentActivator">
            <summary>
            Implements the instance creation logic. The default
            implementation should rely on an ordinary call to 
            Activator.CreateInstance(). 
            </summary>
            <remarks>
            This interface is provided in order to allow custom components
            to be created using a different logic, such as using a specific factory
            or builder.
            <para>
            The constructor for implementation has the following signature:
            </para>
            <code>
            ComponentModel model, IKernel kernel, 
            ComponentInstanceDelegate onCreation, 
            ComponentInstanceDelegate onDestruction
            </code>
            <para>
            The Activator should raise the events onCreation and onDestruction
            in order to correctly implement the contract. Usually the best
            way of creating a custom activator is by extending the existing ones.
            </para>
            <seealso cref="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator"/>
            <seealso cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Create(Castle.MicroKernel.CreationContext)">
            <summary>
            Should return a new component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Destroy(System.Object)">
            <summary>
            Should perform all necessary work to dispose the instance
            and/or any resource related to it.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Constructs an AbstractComponentActivator
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.ComponentActivatorException">
            <summary>
            Summary description for ComponentActivatorException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator">
            <summary>
            Standard implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
            Handles the selection of the best constructor, fills the
            writable properties the component exposes, run the commission 
            and decommission lifecycles, etc.
            </summary>
            <remarks>
            Custom implementors can just override the <c>CreateInstance</c> method.
            Please note however that the activator is responsible for the proxy creation
            when needed.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.CreationContext">
            <summary>
            Used during a component request, passed along to the whole process.
            This allow some data to be passed along the process, which is used 
            to detected cycled dependency graphs and now it's also being used
            to provide arguments to components.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ISubDependencyResolver">
            <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.Resolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Should return an instance of a service or property values as
            specified by the dependency model instance. 
            It is also the responsability of <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            to throw an exception in the case a non-optional dependency 
            could not be resolved.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="parentResolver">Parent resolver</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns>The dependency resolved value or null</returns>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.CanResolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Returns true if the resolver is able to satisfy this dependency.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="parentResolver">Parent resolver</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns><c>true</c> if the dependency can be satisfied</returns>
        </member>
        <member name="F:Castle.MicroKernel.CreationContext.handler">
            <summary>
            
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.CreationContext.dependencies">
            <summary>
            Holds the scoped dependencies being resolved. 
            If a dependency appears twice on the same scope, we'd have a cycle.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.CreationContext.TrackDependency(System.Reflection.MemberInfo,Castle.Core.DependencyModel)">
            <summary>
            Track dependencies and guards against circular dependencies.
            </summary>
            <returns>A dependency key that can be used to remove the dependency if it was resolved correctly.</returns>
        </member>
        <member name="M:Castle.MicroKernel.CreationContext.UntrackDependency(Castle.Core.DependencyModel)">
            <summary>
            Removes a dependency that was resolved successfully.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.CreationContext.Handler">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.CreationContext.DependencyModelExtended">
            <summary>
            Extends <see cref="T:Castle.Core.DependencyModel"/> adding <see cref="T:System.Reflection.MemberInfo"/>
            information. This is only useful to provide detailed information 
            on exceptions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Exceptions.CircularDependecyException">
            <summary>
            Exception throw when a circular dependency is detected
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Exceptions.CircularDependecyException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependecyException"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Exceptions.CircularDependecyException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependecyException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.Exceptions.CircularDependecyException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependecyException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.Exceptions.CircularDependecyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependecyException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <see langword="null"/> or <see cref="P:System.Exception.HResult"/> is zero (0).</exception>
        </member>
        <member name="T:Castle.MicroKernel.ComponentNotFoundException">
            <summary>
            Exception threw when a request for a component
            cannot be satisfied because the component does not
            exist in the container
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/> class.
            </summary>
            <param name="service">The service.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentRegistrationException">
            <summary>
            Exception threw when there is a problem
            registering a component
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.KernelException">
            <summary>
            Exception threw by Kernel operations that failed
            for some reason.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.Facilities.EventWiring.EventWiringException">
            <summary>
            Exception that is thrown when a error occurs during the Event Wiring process
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.FacilityException">
            <summary>
            Base exception to be used by facilities.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.Facilities.EventWiring.EventWiringFacility">
             <summary>
             Facility to allow components to dynamically subscribe to events offered by 
             other components. We call the component that offers events publishers and 
             the components that uses them, subscribers.
             </summary>
             <remarks>
             A component that wish to subscribe to an event must use the external configuration
             adding a node <c>subscribers</c> on the publisher. This node can have multiple entries using the 
             <c>subscriber</c> node.
             </remarks>
             <example>
             <para>This example shows two simple components: one is the event publisher and the other is the 
             subscriber. The subscription will be done by the facility, using the publisher associated configuration.</para>
             <para>The Publisher class:</para>
             <code>
             public class SimplePublisher
            	{
            		public event PublishEventHandler Event;
            
            		public void Trigger()
            		{
            			if (Event != null)
            			{
            				Event(this, new EventArgs()); 
            			}
            		}
             }
             </code>
             <para>The Subscriber class:</para>
             <code>
             public class SimpleListener
             {
             	private bool _listened;
             	private object _sender;
             
             	public void OnPublish(object sender, EventArgs e)
             	{
             		_sender = sender; 
             		_listened = sender != null;
             	}
             
             	public bool Listened
             	{
             		get { return _listened;	}
             	}
             
             	public object Sender
             	{
             		get { return _sender; }
             	}
             }
             </code>
             <para>The configuration file:</para>
             <code>
             <![CDATA[
             <?xml version="1.0" encoding="utf-8" ?>
             <configuration>
             	<facilities>
             		<facility 
             			id="event.wiring"
             			type="Castle.Facilities.EventWiring.EventWiringFacility, Castle.MicroKernel" />
             	</facilities>
             
             	<components>
             		<component 
             			id="SimpleListener" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimpleListener, Castle.Facilities.EventWiring.Tests" />
             
             		<component 
             			id="SimplePublisher" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimplePublisher, Castle.Facilities.EventWiring.Tests" >
             			<subscribers>
             				<subscriber id="SimpleListener" event="Event" handler="OnPublish"/>
             			</subscribers>
             		</component>
             	</components>
             </configuration>
             ]]>
             </code>
             </example>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.AbstractFacility">
            <summary>
            Base class for facilities. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IFacility">
            <summary>
            Unit of extension. A facility should use 
            the extension points offered by the kernel
            to augment its functionality.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
            
            </summary>
            <param name="kernel"></param>
            <param name="facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Terminate">
            <summary>
            
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init">
            <summary>
            The custom initialization for the Facility.
            </summary>
            <remarks>It must be overriden.</remarks>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Initializes the facility. First it performs the initialization common for all 
            facilities, setting the <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel"/> and the 
            <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig"/>. After it, the <c>Init</c> method is invoked
            and the custom initilization is perfomed.
            </summary>
            <param name="kernel"></param>
            <param name="facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Terminate">
            <summary>
            Terminates the Facility, invokind the <see cref="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose"/> and setting 
            the Kernel to a null reference.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose">
            <summary>
            Performs the tasks associated with freeing, releasing, or resetting 
            the facility resources.
            </summary>
            <remarks>It can be overriden.</remarks>
        </member>
        <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel">
            <summary>
            Gets the <see cref="T:Castle.MicroKernel.IKernel"/> where the facility is registered.
            </summary>
            <value>The <see cref="T:Castle.MicroKernel.IKernel"/>.</value>
        </member>
        <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig">
            <summary>
            Gets the facility configuration.
            </summary>
            <value>The <see cref="T:Castle.Core.Configuration.IConfiguration"/> representing 
            the facility configuration.</value>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.Init">
            <summary>
            Overriden. Initializes the facility, subscribing to the <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated"/>,
            <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentCreated"/>, <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed"/> Kernel events.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentModelCreated(Castle.Core.ComponentModel)">
            <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            parses the configuration (the subscribers node) getting the event wiring info.
            </summary>
            <param name="model">The component model.</param>
            <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">Invalid and/or a error in the configuration</exception>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentCreated(Castle.Core.ComponentModel,System.Object)">
            <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            iterates the subscribers starting them and wiring the events.
            </summary>
            <param name="model">The component model.</param>
            <param name="instance">The instance representing the component.</param>
            <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">When the subscriber is not found
            <br/> or <br/>
            The handler method isn't found
            <br/> or <br/>
            The event isn't found
            </exception>
        </member>
        <member name="T:Castle.Facilities.EventWiring.WireInfo">
            <summary>
            Represents the information about an event.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.WireInfo"/> class.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="handler">The name of the handler method.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
        </member>
        <member name="P:Castle.Facilities.EventWiring.WireInfo.EventName">
            <summary>
            Gets the name of the event.
            </summary>
            <value>The name of the event.</value>
        </member>
        <member name="P:Castle.Facilities.EventWiring.WireInfo.Handler">
            <summary>
            Gets the handler method name.
            </summary>
            <value>The handler.</value>
        </member>
        <member name="T:Castle.Facilities.FactorySupport.FactoryActivator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.baseUri">
            <summary>
            Used for client side (Expand explanation)
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.localRegistry">
            <summary>
            Used for server side. 
            Holds the local registry
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.remoteRegistry">
            <summary>
            Used for client side. 
            Holds a remote proxy to the server registry
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingFacility.#ctor">
            <summary>
            Constructs a RemotingFacility
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction">
            <summary>
            Implementors must inspect the component for 
            a given information or parameter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Usually the implementation will look in the configuration property 
            of the model or the service interface, or the implementation looking for
            something.
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingInspector.ResetDependencies(Castle.Core.ComponentModel)">
            <summary>
            Client components are not created by the container
            so there's no point collecting constructor dependencies
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.CheckWaitingList">
            <summary>
            For each new component registered,
            some components in the WaitingDependency
            state may have became valid, so we check them
            </summary>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.Start(System.String)">
            <summary>
            Request the component instance
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.ILifecycleConcern">
            <summary>
            Summary description for ILifecycleConcern.
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.FactoryInterceptor">
            <summary>
            Summary description for FactoryInterceptor.
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.TypedFactoryFacility">
            <summary>
            Summary description for TypedFactoryFacility.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.AbstractHandler">
            <summary>
            Implements the basis of <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandler">
            <summary>
            Contract for the IHandler, which manages an
            component state and coordinates its creation 
            and destruction (dispatching to activators, lifestyle managers)
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the handler with a reference to the
            kernel.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Resolve(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return a valid instance 
            for the component the handler is responsible.
            It should throw an exception in the case the component
            can't be created for some reason
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Release(System.Object)">
            <summary>
            Implementors should dispose the component instance
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.AddCustomDependencyValue(System.String,System.Object)">
            <summary>
            Dictionary of String/object used to 
            associate data with a component dependency.
            For example, if you component SmtpServer depends on 
            host and port, you can add those to this
            dictionary and the handler will be able to use them.
            </summary>
            <remarks>
            TODO: Document this
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.RemoveCustomDependencyValue(System.String)">
            <summary>
            TODO: Document this
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.HasCustomParameter(System.String)">
            <summary>
            TODO: Document this
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.CurrentState">
            <summary>
            Gets the state of the handler
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.ComponentModel">
            <summary>
            Gets the model of the component being 
            managed by this handler.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IHandler.OnHandlerStateChanged">
            <summary>
            TODO: Document this
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.IExposeDependencyInfo">
            <summary>
            Might be implemented by a handler 
            so it can expose access to dependency information 
            which is used to construct meaningful error messages
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.IExposeDependencyInfo.ObtainDependencyDetails(System.Collections.IList)">
            <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            <param name="dependenciesChecked">list of the dependecies that was already checked, used to avoid cycles.</param>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.dependenciesByService">
            <summary>
            Dictionary of Type to a list of <see cref="T:Castle.Core.DependencyModel"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.dependenciesByKey">
            <summary>
            Dictionary of key (string) to <see cref="T:Castle.Core.DependencyModel"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.customParameters">
            <summary>
            Custom dependencies values associated with the handler
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.lifestyleManager">
            <summary>
            Lifestyle manager instance
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
            Constructs and initializes the handler
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Saves the kernel instance, subscribes to 
            <see cref="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel"/> event,
            creates the lifestyle manager instance and computes
            the handler state.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.CreationContext)">
            <summary>
            Should be implemented by derived classes: 
            returns an instance of the component this handler
            is responsible for
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Release(System.Object)">
            <summary>
            Should be implemented by derived classes: 
            disposes the component instance (or recycle it)
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddCustomDependencyValue(System.String,System.Object)">
            <summary>
            TODO: Pendent
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.HasCustomParameter(System.String)">
            <summary>
            TODO: Pendent
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.RemoveCustomDependencyValue(System.String)">
            <summary>
            TODO: Pendent
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ObtainDependencyDetails(System.Collections.IList)">
            <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.CreateLifestyleManager(Castle.MicroKernel.IComponentActivator)">
            <summary>
            Creates an implementation of <see cref="T:Castle.MicroKernel.ILifestyleManager"/> based
            on <see cref="T:Castle.Core.LifestyleType"/> and invokes <see cref="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel)"/>
            to initialize the newly created manager.
            </summary>
            <param name="activator"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied">
            <summary>
            Checks if the handler is able to, at very least, satisfy
            the dependencies for the constructor with less parameters
            </summary>
            <remarks>
            For each non*optional dependency, the implementation will invoke 
            <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)">
            <summary>
            Invoked by <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied"/>
            in order to check if a dependency can be satisfied.
            If not, the handler is set to a 'waiting dependency' state.
            </summary>
            <remarks>
            This method registers the dependencies within the correct collection 
            or dictionary and changes the handler state to 
            <see cref="F:Castle.MicroKernel.HandlerState.WaitingDependency"/>
            </remarks>
            <param name="dependency"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.DependencySatisfied(Castle.MicroKernel.IHandler,System.Boolean@)">
            <summary>
            Invoked by the kernel
            when one of registered dependencies were satisfied by 
            new components registered.
            </summary>
            <remarks>
            Handler for the event <see cref="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered"/>
            </remarks>
            <param name="handler"></param>
            <param name="stateChanged"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.OnAddedAsChildKernel(System.Object,System.EventArgs)">
            <summary>
            Invoked whe the container receives a parent container reference.
            </summary>
            <remarks>
            This method implementation checks whether the parent container
            is able to supply the dependencies for this handler.
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.HandlerStateChanged(System.Object,System.EventArgs)">
            <summary>
            Handler for the event <see cref="E:Castle.MicroKernel.Handlers.AbstractHandler.OnHandlerStateChanged"/>
            </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.CurrentState">
            <summary>
            Gets the handler state.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.ComponentModel">
            <summary>
            Gets the component model.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.Handlers.AbstractHandler.OnHandlerStateChanged">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultGenericHandler">
            <summary>
            Summary description for DefaultGenericHandler.
            </summary>
            <remarks>
            TODO: Consider refactoring AbstractHandler moving lifestylemanager
            creation to DefaultHandler
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandler">
            <summary>
            Summary description for DefaultHandler.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandlerFactory">
            <summary>
            Summary description for DefaultHandlerFactory.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandlerFactory">
            <summary>
            Extension point to allow the developer
            to use his implementation of <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.HandlerException">
            <summary>
            Summary description for HandlerException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerState">
            <summary>
            Possible states for a IHandler instance
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.Valid">
            <summary>
            The component can be requested
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.WaitingDependency">
            <summary>
            The component can not be requested 
            as it still depending on a external 
            dependency not yet available
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerStateDelegate">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.DisposalConcern">
            <summary>
            Summary description for DisposalConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.InitializationConcern">
            <summary>
            Summary description for InitializationConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.SupportInitializeConcern">
            <summary>
            Summary description for SupportInitializeConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Pool.IPool">
            <summary>
            Pool implementation contract. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Request(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return a component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Release(System.Object)">
            <summary>
            Implementors should release the instance or put it
            on the pool
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.DefaultPool.InitPool">
            <summary>
            Initializes the pool to a initial size by requesting
            n components and then releasing them.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager">
            <summary>
            Summary description for AbstractLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ILifestyleManager">
            <summary>
            The <c>ILifestyleManager</c> implements 
            a strategy for a given lifestyle, like singleton, perthread
            and transient.
            </summary>
            <remarks>
            The responsability of <c>ILifestyleManager</c>
            is only the management of lifestyle. It should rely on
            <see cref="T:Castle.MicroKernel.IComponentActivator"/> to obtain a new component instance
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the <c>ILifestyleManager</c> with the 
            <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            </summary>
            <param name="componentActivator"></param>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Resolve(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return the component instance based 
            on the lifestyle semantic.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Release(System.Object)">
            <summary>
            Implementors should release the component instance based
            on the lifestyle semantic, for example, singleton components
            should not be released on a call for release, instead they should
            release them when disposed is invoked.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager">
            <summary>
            Summary description for PerThreadLifestyleManager.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleManager">
            <summary>
            Implements a Lifestyle Manager for Web Apps that
            create at most one object per web request.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PoolableLifestyleManager">
            <summary>
            Implements a Poolable Lifestyle Manager. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.SingletonLifestyleManager">
            <summary>
            Summary description for SingletonLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.TransientLifestyleManager">
            <summary>
            Summary description for TransientLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector">
            <summary>
            Uses the ConfigurationStore registered in the kernel to obtain
            an <see cref="T:Castle.Core.Configuration.IConfiguration"/> associated with the component.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Queries the kernel's ConfigurationStore for a configuration
            associated with the component name.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector">
            <summary>
            Check for a node 'parameters' within the component 
            configuration. For each child it, a ParameterModel is created
            and added to ComponentModel's Parameters collection
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Inspect the configuration associated with the component
            and populates the parameter model collection accordingly
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConstructorDependenciesModelInspector">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
            collects all available constructors and populates them in the model
            as candidates. The Kernel will pick up one of the candidates
            according to a heuristic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ExtendedPropertiesConstants">
            <summary>
            Only to hold internal constants and get rid of 
            magic numbers and hardcode names.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.GenericInspector">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.InterceptorInspector">
            <summary>
            Inspect the component for <c>InterceptorAttribute</c> and
            the configuration for the interceptors node
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector">
            <summary>
            Inspects the type looking for interfaces that constitutes
            lifecycle interfaces, defined in the Castle.Model namespace.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Checks if the type implements <see cref="T:Castle.Core.IInitializable"/> and or
            <see cref="T:System.IDisposable"/> interfaces.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector">
            <summary>
            Inspects the component configuration and the type looking for a
            definition of lifestyle type. The configuration preceeds whatever
            is defined in the component.
            </summary>
            <remarks>
            This inspector is not guarantee to always set up an lifestyle type. 
            If nothing could be found it wont touch the model. In this case is up to
            the kernel to estabish a default lifestyle for components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Seaches for the lifestyle in the configuration and, if unsuccessful
            look for the lifestyle attribute in the implementation type.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromConfiguration(Castle.Core.ComponentModel)">
            <summary>
            Reads the attribute "lifestyle" associated with the 
            component configuration and tries to convert to <see cref="T:Castle.Core.LifestyleType"/> 
            enum type. 
            </summary>
            <exception cref="T:System.Configuration.ConfigurationException">
            If the conversion fails
            </exception>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromType(Castle.Core.ComponentModel)">
            <summary>
            Check if the type expose one of the lifestyle attributes
            defined in Castle.Model namespace.
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector">
            <summary>
            Base for inspectors that want configuration associated with methods.
            For each child a <see cref="T:Castle.Core.MethodMetaModel"/> is created
            and added to ComponentModel's methods collection
            </summary>
            <remarks>
            Implementors should override the <see cref="M:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector.ObtainNodeName"/> return
            the name of the node to be inspected. For example:
            <code>
            <pre>
              <transactions>
                <method name="Save" transaction="requires"/>
              </transactions>
            </pre>
            </code>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
            collects all potential writable puplic properties exposed by the component 
            implementation and populates the model with them.
            The Kernel might be able to set some of these properties when the component 
            is requested.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Adds the properties as optional dependencies of this component.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder">
            <summary>
            Summary description for DefaultComponentModelBuilder.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentModelBuilder">
            <summary>
            Implementors must construct a populated
            instance of ComponentModel by inspecting the component
            and|or the configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.BuildModel(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Constructs a new ComponentModel by invoking
            the registered contributors.
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            "To give or supply in common with others; give to a 
            common fund or for a common purpose". The contributor
            should inspect the component, or even the configuration
            associated with the component, to add or change information
            in the model that can be used later.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            Removes the specified contributor
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="T:Castle.MicroKernel.IProxyFactory">
            <summary>
            Defines the contract used by the kernel 
            to obtain proxies for components. The implementor
            must return a proxied instance that dispatch 
            the invocation to the registered interceptors in the model
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel,System.Object[])">
            <summary>
            Implementors must create a proxy based on 
            the information exposed by ComponentModel
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
            <param name="constructorArguments"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.NotSupportedProxyFactory">
            <summary>
            This is a placeholder implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>.
            </summary>
            <remarks>
            The decision to supply no implementation for <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            is supported by the fact that the MicroKernel should be a thin
            assembly with the minimal set of features, although extensible.
            Providing the support for this interface would obligate 
            the user to import another assembly, even if the large majority of
            simple cases, no use use of interceptors will take place.
            If you want to use however, see the Windsor container.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.AllComponentsReleasePolicy">
            <summary>
            Summary description for AllComponentsReleasePolicy.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IReleasePolicy">
            <summary>
            Summary description for IReleasePolicy.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy">
            <summary>
            Only tracks components that have decommission steps
            registered
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy">
            <summary>
            No tracking of component instances are made.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver">
            <summary>
            Default implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>.
            This implementation is quite simple, but still should be useful
            for 99% of situations. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IDependencyResolver">
            <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.Initialize(Castle.MicroKernel.DependencyDelegate)">
            <summary>
            This method is called with a delegate for firing the
            IKernelEvents.DependencyResolving event.
            </summary>
            <param name="resolving">The delegate used to fire the event</param>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Registers a sub resolver instance
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Unregisters a sub resolver instance previously registered
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.#ctor(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver"/> class.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Initialize(Castle.MicroKernel.DependencyDelegate)">
            <summary>
            Initializes this instance with the specified dependency delegate.
            </summary>
            <param name="dependencyDelegate">The dependency delegate.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Registers a sub resolver instance
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Unregisters a sub resolver instance previously registered
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.CanResolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Returns true if the resolver is able to satisfy the specified dependency.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="parentResolver">Parent resolver</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns><c>true</c> if the dependency can be satisfied</returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Try to resolve the dependency by checking the parameters in 
            the model or checking the Kernel for the requested service.
            </summary>
            <remarks>
            The dependency resolver has the following precedence order:
            <list type="bullet">
            <item><description>
            The dependency is checked within the <see cref="T:Castle.MicroKernel.CreationContext"/>
            </description></item>
            <item><description>
            The dependency is checked within the <see cref="T:Castle.MicroKernel.IHandler"/> instance for the component
            </description></item>
            <item><description>
            The dependency is checked within the registered <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/>s
            </description></item>
            <item><description>
            Finally the resolver tries the normal flow 
            which is using the configuration
            or other component to satisfy the dependency
            </description></item>
            </list>
            </remarks>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="parentResolver">Parent resolver</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns>The dependency resolved value or null</returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ExtractComponentKey(System.String,System.String)">
            <summary>
            Extracts the component name from the a ref strings which is
            ${something}
            </summary>
            <param name="name"></param>
            <param name="keyValue"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RebuildContextForParameter(Castle.MicroKernel.CreationContext,System.Type)">
            <summary>
            This method rebuild the context for the parameter type.
            Naive implementation.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DependencyResolverException">
            <summary>
            Summary description for DependencyResolverException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.IConfigurationStore"/>
            does not try to obtain an external configuration by any means.
            Its only purpose is to serve as a base class for subclasses
            that might obtain the configuration node from anywhere.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ISubSystem">
            <summary>
            A subsystem is used by the MicroKernel to deal 
            with a specific concern.  
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the subsystem
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Terminate">
            <summary>
            Should perform the termination
            of the subsystem instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IConfigurationStore">
            <summary>
            The contract used by the kernel to obtain
            external configuration for the components and
            facilities.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a facility key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddBootstrapComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a  configuration node with a bootstrap component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified facility key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetBootstrapComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetFacilities">
            <summary>
            Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetComponents">
            <summary>
            Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetBootstrapComponents">
            <summary>
            Returns all configuration nodes for bootstrap components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetResource(System.String,Castle.Core.Resource.IResource)">
            <summary>
            
            </summary>
            <param name="resourceUri"></param>
            <param name="resource"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a facility key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddBootstrapComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a bootstrap component key
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with
            the specified facility key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetBootstrapComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilities">
            <summary>
            Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetBootstrapComponents">
            <summary>
            Returns all configuration nodes for bootstrap components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponents">
            <summary>
            Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter">
            <summary>
            Base implementation of <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter">
            <summary>
            Implements a conversion logic to a type of a
            set of types. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type with the specified 
            configuration
            </summary>
            <param name="type"></param>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(System.String,System.Type)">
            <summary>
            Should perform the conversion from the
            string representation specified to the type
            specified.
            </summary>
            <param name="value"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
            <summary>
            Should perform the conversion from the
            configuration node specified to the type
            specified.
            </summary>
            <param name="configuration"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IGenericCollectionConverterHelper">
            <summary>
            This interface is needed because we want to isolate ourself from
            the generic parameters, so we can work type safe inside the implementations,
            and still call from non generic types outside.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IKernelDependentConverter">
            <summary>
            Marker interface that signals that a converter
            depends on IKernel to be able to perform 
            the conversion.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.EnumConverter">
            <summary>
            Converts a string representation to an enum value
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.PrimitiveConverter">
            <summary>
            Implements all standard conversions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.TypeNameConverter">
            <summary>
            Convert a type name to a Type instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException">
            <summary>
            Summary description for ConverterException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.DefaultConversionManager">
            <summary>
            Composition of all available conversion managers
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IConversionManager">
            <summary>
            Establish a composition interface and a subsystem.
            Implementors should delegate the conversion to 
            a instance of a type converter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.IConversionManager.Add(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter)">
            <summary>
            Register a type converter instance.
            </summary>
            <param name="converter"></param>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.left">
            <summary>Node's left</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.right">
            <summary>Node's right</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.parent">
            <summary>Node's parent</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.nextSibling">
            <summary>DA Linked List</summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String)">
            <summary>
            Creates a ComponentName using a name pattern like
            "service:key=value,key2=value2"
            </summary>
            <param name="name">Complete name</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String,System.String)">
            <summary>
            Creates a ComponentName with specified service and 
            properties.
            </summary>
            <param name="service">Service name</param>
            <param name="properties">Property list.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.Setup(System.String)">
            <summary>
            Parses the full name extracting the service and properties.
            </summary>
            <param name="name">Full name.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupService(System.String)">
            <summary>
            Sets up the service. Can be empty but can't be null.
            </summary>
            <param name="service"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.String)">
            <summary>
            Parses and validate a properties list string like 
            "key=value,key2=value2" and so on.
            </summary>
            <param name="properties">Property list.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.Collections.IDictionary)">
            <summary>
            Validates a properties Hashtable.
            </summary>
            <param name="properties">Property list.</param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem">
            <summary>
            Default <see cref="T:Castle.MicroKernel.INamingSubSystem"/> implementation.
            Keeps services and key maps as simple hash tables. Does not
            support a query string.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.INamingSubSystem">
            <summary>
            Contract for SubSystem that wishes to keep and coordinate
            component registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Register(System.String,Castle.MicroKernel.IHandler)">
            <summary>
            Implementors should register the key and service pointing 
            to the specified handler
            </summary>
            <param name="key"></param>
            <param name="handler"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.UnRegister(System.String)">
            <summary>
            Unregister the handler by the given key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.UnRegister(System.Type)">
            <summary>
            Unregister the handler by the given service
            </summary>
            <param name="service"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Contains(System.String)">
            <summary>
            Returns true if there is a component registered 
            for the specified key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Contains(System.Type)">
            <summary>
            Returns true if there is a component registered 
            for the specified service
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.String)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers(System.String)">
            <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> that
            satisfies the specified query.
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified service.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.String,System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified key with the service type.
            <remarks>
            It is expected that this will be used mainly to resolve a generic service
            by its key.
            </remarks>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers(System.Type)">
            <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers">
            <summary>
            Returns all <see cref="T:Castle.MicroKernel.IHandler"/> registered.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetAssignableHandlers(System.Type)">
            <summary>
            Return <see cref="T:Castle.MicroKernel.IHandler"/>s where components are compatible
            with the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetKey2Handler">
            <summary>
            List of handler by key
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetService2Handler">
            <summary>
            List of handler by service
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.ComponentCount">
            <summary>
            Returns the number of components registered.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.Item(System.Type)">
            <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler"/> with 
            the specified service
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.Item(System.String)">
            <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler"/> with
            the specified key
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.key2Handler">
            <summary>
            Map(String, IHandler) to map component keys
            to <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.service2Handler">
            <summary>
            Map(Type, IHandler) to map services 
            to <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.NamingPartsSubSystem">
            <summary>
            Alternative <see cref="T:Castle.MicroKernel.INamingSubSystem"/> implementation.
            Extends the default implementation replacing the 
            key support with a more complete ComponentName. Supports
            queries.
            </summary>
            <example>
            The user must register components using the following construction
            <code>
              service:properties
            </code>
            Where properties is a list of key value pairs (comma separated). Example:
            <code>
              protocol:secure=true,version=1.2
            </code>
            The user can then query for components using the same construction:
            <code>
              protocol:secure=true
            </code>
            Or to return all:
            <code>
              protocol:*
            </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.DefaultResourceSubSystem">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem">
            <summary>
            An implementation of <c>a</c> should 
            be able to return instances of <see cref="T:Castle.Core.Resource.IResource"/>
            for a given resource identifier.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystemConstants">
            <summary>
            Holds the keys used by Kernel to register/request 
            a subsystem.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConfigurationStoreKey">
            <summary>
            Key used for the configuration store subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConversionManagerKey">
            <summary>
            Key used for the conversion manager
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.NamingKey">
            <summary>
            Key used for the naming subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ResourceKey">
            <summary>
            Key used for the resource subsystem
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Util.ReferenceComparer">
            <summary>
            Compares if the reference of two objects are equals.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Util.ReferenceExpressionUtil">
            <summary>
            Summary description for ReferenceExpressionUtil.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.DefaultKernel">
            <summary>
            Default implementation of <see cref="T:Castle.MicroKernel.IKernel"/>. 
            This implementation is complete and also support a kernel 
            hierarchy (sub containers).
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.KernelEventSupport">
            <summary>
            Summary description for KernelEventSupport.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IKernelEvents">
            <summary>
            Summary description for IKernelEvents.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentRegistered">
            <summary>
            Event fired when a new component is registered 
            on the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentUnregistered">
            <summary>
            Event fired when a component is removed from the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated">
            <summary>
            Event fired after the ComponentModel is created.
            Allows customizations that may affect the handler.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel">
            <summary>
            Event fired when the kernel was added as child of
            another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.RemovedAsChildKernel">
            <summary>
            Event fired when the kernel was removed from being a child
            of another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentCreated">
            <summary>
            Event fired before the component is created.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed">
            <summary>
            Event fired when a component instance destroyed.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered">
            <summary>
            Event fired when a new handler is registered 
            (it might be in a valid or waiting dependency state)
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.DependencyResolving">
            <summary>
            Event fired when a dependency is being resolved,
            it allows the dependency to be changed,
            but the client ComponentModel must not be altered.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.HandlerRegistered">
            <summary>
            Pending
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentRegistered">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentUnregistered">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentCreated">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentDestroyed">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.AddedAsChildKernel">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.RemovedAsChildKernel">
            <summary>
            Pending
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentModelCreated">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.MicroKernel.IKernel">
            <summary>
            The <c>IKernel</c> interface exposes all the functionality
            the MicroKernel implements.
            </summary>
            <remarks>
            It allows you to register components and
            request them by the key or the service they implemented.
            It also allow you to register facilities and subsystem, thus 
            augmenting the functionality exposed by the kernel alone to fits 
            your needs.
            <seealso cref="T:Castle.MicroKernel.IFacility"/>
            <seealso cref="T:Castle.MicroKernel.ISubSystem"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type)">
            <summary>
            Adds a concrete class as a component
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/> or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException"/>
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type)">
            <summary>
            Adds a concrete class and an interface 
            as a component
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, <paramref name="serviceType"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, <paramref name="serviceType"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            Adds a concrete class as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Adds a concrete class and an interface 
            as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddCustomComponent(Castle.Core.ComponentModel)">
            <summary>
            Adds a custom made <see cref="T:Castle.Core.ComponentModel"/>.
            Used by facilities.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveComponent(System.String)">
            <summary>
            Returns true if the specified component was 
            found and could be removed (i.e. no other component depends on it)
            </summary>
            <param name="key">The component's key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.String)">
            <summary>
            Returns true if the specified key was registered
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.Type)">
            <summary>
            Returns true if the specified service was registered
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
            <param name="key"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.Type,System.Collections.IDictionary)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="service"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.String,System.Collections.IDictionary)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="key"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ReleaseComponent(System.Object)">
            <summary>
            Releases a component instance. This allows
            the kernel to execute the proper decomission 
            lifecycles on the component instance.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.CreateComponentActivator(Castle.Core.ComponentModel)">
            <summary>
            Constructs an implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            for the given <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.String)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
            for the specified component key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
            for the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetAssignableHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
            Adds a <see cref="T:Castle.MicroKernel.IFacility"/> to the kernel.
            </summary>
            <param name="key"></param>
            <param name="facility"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetFacilities">
            <summary>
            Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddSubSystem(System.String,Castle.MicroKernel.ISubSystem)">
            <summary>
            Adds (or replaces) an <see cref="T:Castle.MicroKernel.ISubSystem"/>
            </summary>
            <param name="key"></param>
            <param name="subsystem"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetSubSystem(System.String)">
            <summary>
            Returns an implementation of <see cref="T:Castle.MicroKernel.ISubSystem"/>
            for the specified key. 
            <seealso cref="T:Castle.MicroKernel.SubSystemConstants"/>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
            Support for kernel hierarchy
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
            Remove child kernel
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.String)">
            <summary>
            Returns the component instance by the key
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.Type)">
            <summary>
            Returns the component instance by the service type
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ComponentModelBuilder">
            <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.HandlerFactory">
            <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ConfigurationStore">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IConfigurationStore"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ReleasePolicy">
            <summary>
            Gets or sets the implementation for <see cref="T:Castle.MicroKernel.IReleasePolicy"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Resolver">
            <summary>
            Returns the implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ProxyFactory">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            allowing different strategies for proxy creation.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Parent">
            <summary>
            Returns the parent kernel
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.GraphNodes">
            <summary>
            Graph of components and iteractions.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.parentKernel">
            <summary>
            The parent kernel, if exists.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.handlerFactory">
            <summary>
            The implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.modelBuilder">
            <summary>
            The implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.resolver">
            <summary>
            The dependency resolver.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.releaserPolicy">
            <summary>
            Implements a policy to control component's
            disposal that the usef forgot.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.proxyFactory">
            <summary>
            Holds the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.facilities">
            <summary>
            List of <see cref="T:Castle.MicroKernel.IFacility"/> registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.subsystems">
            <summary>
            Map of subsystems registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.childKernels">
            <summary>
            List of sub containers.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor">
            <summary>
            Constructs a DefaultKernel with no component
            proxy support.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IDependencyResolver,Castle.MicroKernel.IProxyFactory)">
            <summary>
            Constructs a DefaultKernel with the specified
            implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/> and <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
            <param name="resolver"></param>
            <param name="proxyFactory"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IProxyFactory)">
            <summary>
            Constructs a DefaultKernel with the specified
            implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/> or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/> or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException"/>
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, <paramref name="serviceType"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, <paramref name="serviceType"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddCustomComponent(Castle.Core.ComponentModel)">
            <summary>
            
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance(System.String,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance(System.String,System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
            <param name="key"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetAssignableHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetFacilities">
            <summary>
            Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Dispose">
            <summary>
            Starts the process of component disposal.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.DefaultKernel.GraphNodes">
            <summary>
            Graph of components and iteractions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentDataDelegate">
            <summary>
            Represents a delegate which holds basic information about a component.
            </summary>
            <param name="key">Key which identifies the component</param>
            <param name="handler">handler that holds this component and is capable of 
            creating an instance of it.
            </param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentInstanceDelegate">
            <summary>
            Represents a delegate which holds basic information about a component
            and its instance.
            </summary>
            <param name="model">Component meta information</param>
            <param name="instance">Component instance</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentModelDelegate">
            <summary>
            Represents a delegate which holds the information about the 
            component
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerDelegate">
            <summary>
            Represents a delegate which holds a handler
            </summary>
            <param name="handler">handler that holds a component and is capable of 
            creating an instance of it.
            </param>
            <param name="stateChanged"></param>
        </member>
        <member name="T:Castle.MicroKernel.DependencyDelegate">
            <summary>
            Represents a delegate which holds dependency
            resolving information.
            </summary>
        </member>
    </members>
</doc>
