<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NHibernate</name>
    </assembly>
    <members>
        <member name="P:NHibernate.AdoNet.IExpectation.ExpectedRowCount">
            <summary>
            Expected row count. Valid only for batchable expectations.
            </summary>
        </member>
        <member name="T:NHibernate.HibernateException">
            <summary>
            Any exception that occurs in the O-R persistence layer.
            </summary>
            <remarks>
            Exceptions that occur in the database layer are left as native exceptions.
            </remarks>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class 
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl">
            <summary>
            CodeDOM-based bytecode provider.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.IBytecodeProvider.GetReflectionOptimizer(System.Type,NHibernate.Property.IGetter[],NHibernate.Property.ISetter[])">
            <summary>
            Retrieve the <see cref="T:NHibernate.Bytecode.IReflectionOptimizer"/> delegate for this provider
            capable of generating reflection optimization components.
            </summary>
            <param name="clazz">The class to be reflected upon.</param>
            <param name="getters">All property getters to be accessed via reflection.</param>
            <param name="setters">All property setters to be accessed via reflection.</param>
            <returns>The reflection optimization delegate.</returns>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.#ctor(System.Type,NHibernate.Property.IGetter[],NHibernate.Property.ISetter[])">
            <summary>
            ctor
            </summary>
            <param name="mappedClass">The target class</param>
            <param name="setters">Array of setters</param>
            <param name="getters">Array of getters</param>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.InitCompiler">
            <summary>
            Set up the compiler options
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.AddAssembly(System.String)">
            <summary>
            Add an assembly to the list of ReferencedAssemblies
            required to build the class
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.Build(System.String)">
            <summary>
            Build the generated code
            </summary>
            <param name="code">Generated code</param>
            <returns>An instance of the generated class</returns>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.IsPublic(System.String)">
            <summary>
            Check if the property is public
            </summary>
            <remarks>
            <para>If IsPublic==true I can directly set the property</para>
            <para>If IsPublic==false I need to use the setter/getter</para>
            </remarks>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.GenerateCode">
            <summary>
            Generate the required code
            </summary>
            <returns>C# code</returns>
        </member>
        <member name="T:NHibernate.Bytecode.IAccessOptimizer">
            <summary>
            Represents optimized entity property access.
            </summary>
        </member>
        <member name="T:NHibernate.Bytecode.Lightweight.BytecodeProviderImpl">
            <summary>
            Factory that generate object based on IReflectionOptimizer needed to replace the use
            of reflection.
            </summary>
            <remarks>
            Used in <see cref="T:NHibernate.Persister.Entity.AbstractEntityPersister"/> and
            <see cref="T:NHibernate.Type.ComponentType"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.BytecodeProviderImpl.GetReflectionOptimizer(System.Type,NHibernate.Property.IGetter[],NHibernate.Property.ISetter[])">
            <summary>
            Generate the IReflectionOptimizer object
            </summary>
            <param name="mappedClass">The target class</param>
            <param name="setters">Array of setters</param>
            <param name="getters">Array of getters</param>
            <returns><see langword="null" /> if the generation fails</returns>
        </member>
        <member name="T:NHibernate.Bytecode.IReflectionOptimizer">
            <summary>
            Represents reflection optimization for a particular class.
            </summary>
        </member>
        <member name="T:NHibernate.Bytecode.IInstantiationOptimizer">
            <summary>
            Represents optimized entity instantiation.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.IInstantiationOptimizer.CreateInstance">
            <summary>
            Perform instantiation of an instance of the underlying class.
            </summary>
            <returns>The new instance.</returns>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.#ctor(System.Type,NHibernate.Property.IGetter[],NHibernate.Property.ISetter[])">
            <summary>
            Class constructor.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.CreateCreateInstanceMethod(System.Type)">
            <summary>
            Generates a dynamic method which creates a new instance of <paramref name="type" />
            when invoked.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.GenerateGetPropertyValuesMethod(NHibernate.Property.IGetter[])">
            <summary>
            Generates a dynamic method on the given type.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.GenerateSetPropertyValuesMethod(NHibernate.Property.IGetter[],NHibernate.Property.ISetter[])">
            <summary>
            Generates a dynamic method on the given type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Bytecode.EmitUtil.EmitFastInt(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Emits an <c>ldc.i4</c> opcode using the fastest available opcode choice.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.EmitUtil.PreparePropertyForSet(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Emits IL to unbox a value type and if null, create a new instance of the value type.
            </summary>
            <remarks>
            This does not work if the value type doesn't have a default constructor - we delegate
            that to the ISetter.
            </remarks>
        </member>
        <member name="M:NHibernate.Bytecode.EmitUtil.DefineDelegateType(System.String,System.Reflection.Emit.ModuleBuilder,System.Type,System.Type[])">
            <summary>
            Defines a new delegate type.
            </summary>
        </member>
        <member name="T:NHibernate.Bytecode.NullBytecodeProvider">
            <summary>
            A <see cref="T:NHibernate.Bytecode.IBytecodeProvider"/> implementation that returns
            <see langword="null"/>, disabling reflection optimization.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.CachedItem">
            <summary>
            An item of cached data, timestamped with the time it was cached, when it was locked,
            when it was unlocked
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ILockable">
            <summary>
            Summary description for ILockable.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.Lock(System.Int64,System.Int32)">
            <summary>
            Lock the item
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.IsGettable(System.Int64)">
            <summary>
            Is this item visible to the timestamped transaction?
            </summary>
            <param name="txTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Don't overwite already cached items
            </summary>
            <param name="txTimestamp"></param>
            <param name="newVersion"></param>
            <param name="comparator"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.FreshTimestamp">
            <summary>
            The timestamp on the cached data
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.Value">
            <summary>
            The actual cached data
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.IsLock">
            <summary>
            Not a lock!
            </summary>
        </member>
        <member name="T:NHibernate.Cache.CacheException">
            <summary>
            Represents any exception from an <see cref="T:NHibernate.Cache.ICache"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Cache.CacheFactory">
            <summary>
            Factory class for creating an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/>.
            </summary>
        </member>
        <member name="F:NHibernate.Cache.CacheFactory.Transactional">
            <remarks>
            No providers implement transactional caching currently,
            it was ported from Hibernate just for the sake of completeness.
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.CacheFactory.CreateCache(System.String,System.String,System.Boolean,NHibernate.Cfg.Settings,System.Collections.IDictionary)">
            <summary>
            Creates an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> from the parameters.
            </summary>
            <param name="usage">The name of the strategy that <see cref="T:NHibernate.Cache.ICacheProvider"/> should use for the class.</param>
            <param name="name">The name of the class the strategy is being created for.</param>
            <param name="mutable"><see langword="true"/> if the object being stored in the cache is mutable.</param>
            <param name="settings">Used to retrieve the global cache region prefix.</param>
            <param name="properties">Properties the cache provider can use to configure the cache.</param>
            <returns>An <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> to use for this object in the <see cref="T:NHibernate.Cache.ICache"/>.</returns>
        </member>
        <member name="T:NHibernate.Cache.CacheKey">
            <summary>
            Allows multiple entity classes / collection roles to be 
            stored in the same cache region. Also allows for composite 
            keys which do not properly implement equals()/hashCode().
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheKey.#ctor(System.Object,NHibernate.Type.IType,System.String,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Construct a new key for a collection or entity instance.
            Note that an entity name should always be the root entity 
            name, not a subclass entity name.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.CacheLock">
            <summary>
            A soft lock which supports concurrent locking,
            timestamped with the time it was released
            </summary>
            <remarks>
            This class was named Lock in H2.1
            </remarks>
        </member>
        <member name="T:NHibernate.Cache.ISoftLock">
            <summary>
            Marker interface, denoting a client-visible "soft lock" on a cached item.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.Lock(System.Int64,System.Int32)">
            <summary>
            Increment the lock, setting the
            new lock timeout
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.Unlock(System.Int64)">
            <summary>
            Decrement the lock, setting the unlock
            timestamp if now unlocked
            </summary>
            <param name="currentTimestamp"></param>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Can the timestamped transaction re-cache this
            locked item now?
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.IsGettable(System.Int64)">
            <summary>
            locks are not returned to the client!
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CacheLock.WasLockedConcurrently">
            <summary>
            Was this lock held concurrently by multiple
            transactions?
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CacheLock.IsLock">
            <summary>
            Yes, this is a lock
            </summary>
        </member>
        <member name="T:NHibernate.Cache.HashtableCache">
            <summary>
            A simple <see cref="T:System.Collections.Hashtable"/>-based cache
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ICache">
            <summary>
            Implementors define a caching algorithm.
            </summary>
            <remarks>
            <threadsafety instance="true"/>
            <para>
            All implementations <em>must</em> be threadsafe.
            </para>
            <para>
            The key is the identifier of the object that is being cached and the 
            value is a <see cref="T:NHibernate.Cache.CachedItem"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ICache.Get(System.Object)">
            <summary>
            Get the object from the Cache
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICache.Put(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Cache.ICache.Remove(System.Object)">
            <summary>
            Remove an item from the Cache.
            </summary>
            <param name="key">The Key of the Item in the Cache to remove.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Clear">
            <summary>
            Clear the Cache
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Destroy">
            <summary>
            Clean up.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Lock(System.Object)">
            <summary>
            If this is a clustered cache, lock the item
            </summary>
            <param name="key">The Key of the Item in the Cache to lock.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Unlock(System.Object)">
            <summary>
            If this is a clustered cache, unlock the item
            </summary>
            <param name="key">The Key of the Item in the Cache to unlock.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.NextTimestamp">
            <summary>
            Generate a timestamp
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cache.ICache.Timeout">
            <summary>
            Get a reasonable "lock timeout"
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ICache.RegionName">
            <summary>
            Gets the name of the cache region
            </summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Get(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Put(System.Object,System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Remove(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Destroy">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Lock(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Unlock(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.NextTimestamp">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cache.HashtableCache.Timeout">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Cache.HashtableCacheProvider">
            <summary>
            Cache Provider plugin for NHibernate that is configured by using
            <c>hibernate.cache.provider_class="NHibernate.Cache.HashtableCacheProvider"</c>
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ICacheProvider">
            <summary>
            Support for pluggable caches
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.BuildCache(System.String,System.Collections.IDictionary)">
            <summary>
            Configure the cache
            </summary>
            <param name="regionName">the name of the cache region</param>
            <param name="properties">configuration settings</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.NextTimestamp">
            <summary>
            generate a timestamp
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.Start(System.Collections.IDictionary)">
            <summary>
            Callback to perform any necessary initialization of the underlying cache implementation
            during ISessionFactory construction.
            </summary>
            <param name="properties">current configuration settings</param>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.Stop">
            <summary>
            Callback to perform any necessary cleanup of the underlying cache implementation
            during <see cref="M:NHibernate.ISessionFactory.Close"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCacheProvider.BuildCache(System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="regionName"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.HashtableCacheProvider.NextTimestamp">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.HashtableCacheProvider.Start(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="properties"></param>
        </member>
        <member name="M:NHibernate.Cache.HashtableCacheProvider.Stop">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ICacheConcurrencyStrategy">
            <summary>
            Implementors manage transactional access to cached data.
            </summary>
            <remarks>
            <para>
            Transactions pass in a timestamp indicating transaction start time.
            </para>
            <para>
            When used to cache entities and collections the key is the identifier of the
            entity/collection and the value should be set to the <see cref="T:NHibernate.Impl.CacheEntry"/> 
            for an entity and the results of <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)"/>
            for a collection.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Get(NHibernate.Cache.CacheKey,System.Int64)">
            <summary>
            Attempt to retrieve an object from the Cache
            </summary>
            <param name="key">The key (id) of the object to get out of the Cache.</param>
            <param name="txTimestamp">A timestamp prior to the transaction start time</param>
            <returns>The cached object or <see langword="null"/></returns>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
            <summary>
            Attempt to cache an object, after loading from the database
            </summary>
            <param name="key">The key (id) of the object to put in the Cache.</param>
            <param name="value">The value</param>
            <param name="txTimestamp">A timestamp prior to the transaction start time</param>
            <param name="version">the version number of the object we are putting</param>
            <param name="versionComparer">a Comparer to be used to compare version numbers</param>
            <param name="minimalPut">indicates that the cache should avoid a put if the item is already cached</param>
            <returns><see langword="true"/> if the object was successfully cached</returns>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Lock(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            We are going to attempt to update/delete the keyed object
            </summary>
            <param name="key">The key</param>
            <param name="version"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Evict(NHibernate.Cache.CacheKey)">
            <summary>
            Called after an item has become stale (before the transaction completes).
            </summary>
            <param name="key"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Update(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Called after an item has been updated (before the transaction completes),
            instead of calling Evict().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Insert(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Called after an item has been inserted (before the transaction completes), instead of calling Evict().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.ISoftLock)">
            <summary>
            Called when we have finished the attempted update/delete (which may or
            may not have been successful), after transaction completion.
            </summary>
            <param name="key">The key</param>
            <param name="lock">The soft lock</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Called after an item has been updated (after the transaction completes),
            instead of calling Release().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <param name="lock"></param>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Called after an item has been inserted (after the transaction completes), instead of calling release().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Remove(NHibernate.Cache.CacheKey)">
            <summary>
            Evict an item from the cache immediately (without regard for transaction isolation).
            </summary>
            <param name="key"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Clear">
            <summary>
            Evict all items from the cache immediately.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Destroy">
            <summary>
            Clean up all resources.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="P:NHibernate.Cache.ICacheConcurrencyStrategy.RegionName">
            <summary>
            Gets the cache region name.
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ICacheConcurrencyStrategy.Cache">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Cache.ICache"/> for this strategy to use.
            </summary>
            <value>The <see cref="T:NHibernate.Cache.ICache"/> for this strategy to use.</value>
        </member>
        <member name="T:NHibernate.Cache.IQueryCache">
            <summary>
            Defines the contract for caches capable of storing query results.  These
            caches should only concern themselves with storing the matching result ids.
            The transactional semantics are necessarily less strict than the semantics
            of an item cache.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.IQueryCacheFactory">
            <summary>
            Defines a factory for query cache instances.  These factories are responsible for
            creating individual QueryCache instances.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.IQueryCacheFactory.GetQueryCache(System.String,NHibernate.Cache.UpdateTimestampsCache,NHibernate.Cfg.Settings,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="regionName"></param>
            <param name="updateTimestampsCache"></param>
            <param name="settings"></param>
            <param name="props"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cache.NoCacheProvider">
            <summary>
            A cache provider placeholder used when caching is disabled.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NoCacheProvider.BuildCache(System.String,System.Collections.IDictionary)">
            <summary>
            Configure the cache
            </summary>
            <param name="regionName">the name of the cache region</param>
            <param name="properties">configuration settings</param>
            <exception cref="T:NHibernate.Cache.CacheException"/>
        </member>
        <member name="M:NHibernate.Cache.NoCacheProvider.NextTimestamp">
            <summary>
            Generate a timestamp
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NoCacheProvider.Start(System.Collections.IDictionary)">
            <summary>
            Callback to perform any necessary initialization of the underlying cache implementation during SessionFactory
            construction.
            </summary>
            <param name="properties">current configuration settings.</param>
        </member>
        <member name="M:NHibernate.Cache.NoCacheProvider.Stop">
            <summary>
            Callback to perform any necessary cleanup of the underlying cache implementation during SessionFactory.close().
            </summary>
        </member>
        <member name="T:NHibernate.Cache.NonstrictReadWriteCache">
            <summary>
            Caches data that is sometimes updated without ever locking the cache. 
            If concurrent access to an item is possible, this concurrency strategy 
            makes no guarantee that the item returned from the cache is the latest 
            version available in the database. Configure your cache timeout accordingly! 
            This is an "asynchronous" concurrency strategy.
            <seealso cref="T:NHibernate.Cache.ReadWriteCache"/> for a much stricter algorithm
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Get(NHibernate.Cache.CacheKey,System.Int64)">
            <summary>
            Get the most recent version, if available.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
            <summary>
            Add an item to the cache
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Do nothing
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Evict(NHibernate.Cache.CacheKey)">
            <summary>
            Invalidate the item
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Update(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Invalidate the item
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Insert(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Do nothing
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.ISoftLock)">
            <summary>
            Invalidate the item (again, for safety).
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Invalidate the item (again, for safety).
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Do nothing
            </summary>
        </member>
        <member name="P:NHibernate.Cache.NonstrictReadWriteCache.RegionName">
            <summary>
            Gets the cache region name.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.QueryKey.#ctor(NHibernate.Engine.ISessionFactoryImplementor,NHibernate.SqlCommand.SqlString,NHibernate.Engine.QueryParameters,Iesi.Collections.ISet)">
            <param name="factory">the sesion factory for this query key, required to get the identifiers of entities that are used as values.</param>
        </member>
        <member name="T:NHibernate.Cache.ReadOnlyCache">
            <summary>
            Caches data that is never updated
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Unsupported!
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.ISoftLock)">
            <summary>
            Unsupported!
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Unsupported!
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Do nothing.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Evict(NHibernate.Cache.CacheKey)">
            <summary>
            Do nothing.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Insert(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Do nothing.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Update(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Unsupported!
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ReadOnlyCache.RegionName">
            <summary>
            Gets the cache region name.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ReadWriteCache">
            <summary>
            Caches data that is sometimes updated while maintaining the semantics of
            "read committed" isolation level. If the database is set to "repeatable
            read", this concurrency strategy <em>almost</em> maintains the semantics.
            Repeatable read isolation is compromised in the case of concurrent writes.
            This is an "asynchronous" concurrency strategy.
            </summary>
            <remarks>
            If this strategy is used in a cluster, the underlying cache implementation
            must support distributed hard locks (which are held only momentarily). This
            strategy also assumes that the underlying cache implementation does not do
            asynchronous replication and that state has been fully replicated as soon
            as the lock is released.
            <seealso cref="T:NHibernate.Cache.NonstrictReadWriteCache"/> for a faster algorithm
            <seealso cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.NextLockId">
            <summary>
            Generate an id for a new lock. Uniqueness per cache instance is very
            desirable but not absolutely critical. Must be called from one of the
            synchronized methods of this class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Get(NHibernate.Cache.CacheKey,System.Int64)">
            <summary>
            Do not return an item whose timestamp is later than the current
            transaction timestamp. (Otherwise we might compromise repeatable
            read unnecessarily.) Do not return an item which is soft-locked.
            Always go straight to the database instead.
            </summary>
            <remarks>
            Note that since reading an item from that cache does not actually
            go to the database, it is possible to see a kind of phantom read
            due to the underlying row being updated after we have read it
            from the cache. This would not be possible in a lock-based
            implementation of repeatable read isolation. It is also possible
            to overwrite changes made and committed by another transaction
            after the current transaction read the item from the cache. This
            problem would be caught by the update-time version-checking, if 
            the data is versioned or timestamped.
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Stop any other transactions reading or writing this item to/from
            the cache. Send them straight to the database instead. (The lock
            does time out eventually.) This implementation tracks concurrent
            locks by transactions which simultaneously attempt to write to an
            item.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
            <summary>
            Do not add an item to the cache unless the current transaction
            timestamp is later than the timestamp at which the item was
            invalidated. (Otherwise, a stale item might be re-added if the
            database is operating in repeatable read isolation mode.)
            </summary>
            <returns>Whether the item was actually put into the cache</returns>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.DecrementLock(System.Object,NHibernate.Cache.CacheLock)">
            <summary>
            decrement a lock and put it back in the cache
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Re-cache the updated state, if and only if there there are
            no other concurrent soft locks. Release our lock.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.IsUnlockable(NHibernate.Cache.ISoftLock,NHibernate.Cache.ILockable)">
            <summary>
            Is the client's lock commensurate with the item in the cache?
            If it is not, we know that the cache expired the original
            lock.
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ReadWriteCache.RegionName">
            <summary>
            Gets the cache region name.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.StandardQueryCache">
            <summary>
            The standard implementation of the Hibernate <see cref="T:NHibernate.Cache.IQueryCache"/>
            interface.  This implementation is very good at recognizing stale query
            results and re-running queries when it detects this condition, recaching
            the new results.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.StandardQueryCacheFactory">
            <summary>
            Standard Hibernate implementation of the IQueryCacheFactory interface.  Returns
            instances of <see cref="T:NHibernate.Cache.StandardQueryCache"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.Timestamper">
            <summary>
            Generates increasing identifiers (in a single application domain only).
            </summary>
            <remarks>
            Not valid across multiple application domains. Identifiers are not necessarily
            strictly increasing, but usually are.
            </remarks>
        </member>
        <member name="F:NHibernate.Cache.Timestamper.OneMs">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.Timestamper.Next">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cache.UpdateTimestampsCache">
            <summary>
            Tracks the timestamps of the most recent updates to particular tables. It is
            important that the cache timeout of the underlying cache implementation be set
            to a higher value than the timeouts of any of the query caches. In fact, we 
            recommend that the the underlying cache not be configured for expiry at all.
            Note, in particular, that an LRU cache expiry policy is never appropriate.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.UpdateTimestampsCache.Invalidate(System.Object[])">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Cfg.AssemblyHbmOrderer">
            <summary>
            Analyzes the contents of the <c>hbm.xml</c> files embedded in the 
            <see cref="T:System.Reflection.Assembly"/> for their dependency order.
            </summary>
            <remarks>
            This solves the problem caused when you have embedded <c>hbm.xml</c> files
            that contain subclasses/joined-subclasses that make use of the <c>extends</c>
            attribute.  This ensures that those subclasses/joined-subclasses will not be
            processed until after the class they extend is processed.
            </remarks>
        </member>
        <member name="F:NHibernate.Cfg.AssemblyHbmOrderer._hbmResources">
            <summary>
            An <see cref="T:System.Collections.IList"/> of all the <c>hbm.xml</c> resources found
            in the assembly.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.AssemblyHbmOrderer.CreateWithResources(System.Reflection.Assembly,System.Collections.IEnumerable)">
            <summary>
            Creates a new instance of AssemblyHbmOrderer with the specified <paramref name="resources" />
            added.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.AssemblyHbmOrderer.#ctor(System.Reflection.Assembly)">
            <summary>
            Creates a new instance of <see cref="T:NHibernate.Cfg.AssemblyHbmOrderer"/>
            </summary>
            <param name="assembly">The <see cref="T:System.Reflection.Assembly"/> to get resource streams from.</param>
        </member>
        <member name="M:NHibernate.Cfg.AssemblyHbmOrderer.AddResource(System.String)">
            <summary>
            Adds the specified resource to the resources being ordered.
            </summary>
            <param name="fileName">Name of the file (embedded resource).</param>
        </member>
        <member name="M:NHibernate.Cfg.AssemblyHbmOrderer.GetHbmFiles">
            <summary>
            Gets an <see cref="T:System.Collections.IList"/> of <c>hbm.xml</c> resources in the correct order.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IList"/> of <c>hbm.xml</c> resources in the correct order.
            </returns>
        </member>
        <member name="M:NHibernate.Cfg.AssemblyHbmOrderer.OrderedHbmFiles(Iesi.Collections.ISet)">
            <summary>
            Returns an <see cref="T:System.Collections.IList"/> of <c>hbm.xml</c> files in the order that ensures
            base classes are loaded before their subclass/joined-subclass.
            </summary>
            <param name="unorderedClasses">An <see cref="T:Iesi.Collections.ISet"/> of <see cref="T:NHibernate.Cfg.AssemblyHbmOrderer.ClassEntry"/> objects.</param>
            <returns>
            An <see cref="T:System.Collections.IList"/> of <see cref="T:System.String"/> objects that contain the <c>hbm.xml</c> file names.
            </returns>
        </member>
        <member name="T:NHibernate.Cfg.AssemblyHbmOrderer.ClassEntry">
            <summary>
            Holds information about mapped classes found in the <c>hbm.xml</c> files.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.AssemblyHbmOrderer.ClassEntry.FileName">
            <summary>
            Gets the name of the <c>hbm.xml</c> file this class was found in.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.Configuration">
            <summary>
            Allows the application to specify properties and mapping documents to be used when creating
            a <see cref="T:NHibernate.ISessionFactory"/>.
            </summary>
            <remarks>
            <para>
            Usually an application will create a single <see cref="T:NHibernate.Cfg.Configuration"/>, build a single instance
            of <see cref="T:NHibernate.ISessionFactory"/>, and then instantiate <see cref="T:NHibernate.ISession"/> objects in threads
            servicing client requests.
            </para>
            <para>
            The <see cref="T:NHibernate.Cfg.Configuration"/> is meant only as an initialization-time object. <see cref="T:NHibernate.ISessionFactory"/>
            is immutable and does not retain any association back to the <see cref="T:NHibernate.Cfg.Configuration"/>
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.Cfg.Configuration.MappingSchemaXMLNS">
            <summary>
            The XML Namespace for the nhibernate-mapping
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.Configuration.CfgSchemaXMLNS">
            <summary>
            The XML Namespace for the nhibernate-configuration
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Reset">
            <summary>
            Clear the internal state of the <see cref="T:NHibernate.Cfg.Configuration"/> object.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.#ctor">
            <summary>
            Create a new Configuration object.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetClassMapping(System.Type)">
            <summary>
            Get the mapping for a particular class
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetCollectionMapping(System.String)">
            <summary>
            Get the mapping for a particular collection role
            </summary>
            <param name="role">a collection role</param>
            <returns><see cref="T:NHibernate.Mapping.Collection"/></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddFile(System.String)">
            <summary>
            Read mappings from a particular XML file. This method is equivalent
            to <see cref="M:NHibernate.Cfg.Configuration.AddXmlFile(System.String)"/>.
            </summary>
            <param name="xmlFile"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlFile(System.String)">
            <summary>
            Read mappings from a particular XML file.
            </summary>
            <param name="xmlFile">a path to a file</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXml(System.String,System.String)">
            <summary>
            Read mappings from a <see cref="T:System.String"/>. This method is equivalent to
            <see cref="M:NHibernate.Cfg.Configuration.AddXmlString(System.String)"/>.
            </summary>
            <param name="xml">an XML string</param>
            <param name="name">The name to use in error reporting. May be <see langword="null"/>.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlString(System.String)">
            <summary>
            Read mappings from a <see cref="T:System.String"/>.
            </summary>
            <param name="xml">an XML string</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddUrl(System.String)">
            <summary>
            Read mappings from a URL.
            </summary>
            <param name="url">a URL</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddUrl(System.Uri)">
            <summary>
            Read mappings from a URL.
            </summary>
            <param name="url">a <see cref="T:System.Uri"/> to read the mappings from.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddDocument(System.Xml.XmlDocument,System.String)">
            <summary>
            Read mappings from an <see cref="T:System.Xml.XmlDocument"/>.
            </summary>
            <param name="doc">A loaded <see cref="T:System.Xml.XmlDocument"/> that contains the mappings.</param>
            <param name="name">The name of the document, for error reporting purposes.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddValidatedDocument(System.Xml.XmlDocument,System.String)">
            <summary>
            Takes the validated XmlDocument and has the Binder do its work of
            creating Mapping objects from the Mapping Xml.
            </summary>
            <param name="doc">The <b>validated</b> XmlDocument that contains the Mappings.</param>
            <param name="name">The name of the document, for error reporting purposes.</param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.CreateMappings">
            <summary>
            Create a new <see cref="T:NHibernate.Cfg.Mappings"/> to add classes and collection
            mappings to.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddInputStream(System.IO.Stream)">
            <summary>
            Read mappings from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="xmlInputStream">The stream containing XML</param>
            <returns>This Configuration object.</returns>
            <remarks>
            The <see cref="T:System.IO.Stream"/> passed in through the parameter <paramref name="xmlInputStream"/>
            is not <em>guaranteed</em> to be cleaned up by this method.  It is the caller's responsiblity to
            ensure that <paramref name="xmlInputStream"/> is properly handled when this method
            completes.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddInputStream(System.IO.Stream,System.String)">
            <summary>
            Read mappings from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="xmlInputStream">The stream containing XML</param>
            <param name="name">The name of the stream to use in error reporting. May be <see langword="null"/>.</param>
            <returns>This Configuration object.</returns>
            <remarks>
            The <see cref="T:System.IO.Stream"/> passed in through the parameter <paramref name="xmlInputStream"/>
            is not <em>guaranteed</em> to be cleaned up by this method.  It is the caller's responsiblity to
            ensure that <paramref name="xmlInputStream"/> is properly handled when this method
            completes.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddResource(System.String,System.Reflection.Assembly)">
            <summary>
            Adds the mappings in the resource of the assembly.
            </summary>
            <param name="path">The path to the resource file in the assembly.</param>
            <param name="assembly">The assembly that contains the resource file.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddClass(System.Type)">
            <summary>
            Read a mapping from an embedded resource, using a convention.
            </summary>
            <param name="persistentClass">The type to map.</param>
            <returns>This configuration object.</returns>
            <remarks>
            The convention is for class <c>Foo.Bar.Foo</c> to be mapped by
            the resource named <c>Foo.Bar.Foo.hbm.xml</c>, embedded in
            the class' assembly. If the mappings and classes are defined
            in different assemblies or don't follow the naming convention,
            this method cannot be used.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.String)">
            <summary>
            Adds all of the assembly's embedded resources whose names end with <c>.hbm.xml</c>.
            </summary>
            <param name="assemblyName">The name of the assembly to load.</param>
            <returns>This configuration object.</returns>
            <remarks>
            The assembly must be loadable using <see cref="M:System.Reflection.Assembly.Load(System.String)"/>. If this
            condition is not satisfied, load the assembly manually and call
            <see cref="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly)"/> instead.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Adds all of the assembly's embedded resources whose names end with <c>.hbm.xml</c>.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>This configuration object.</returns>
            <remarks>
            This method assumes that the <c>hbm.xml</c> files in the Assembly need to be put
            in the correct order by NHibernate.  See <see cref="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly,System.Boolean)">
            AddAssembly(Assembly assembly, bool skipOrdering)</see> for the impacts and reasons
            for letting NHibernate order the <c>hbm.xml</c> files.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Adds all of the assembly's embedded resources whose names end with <c>.hbm.xml</c>.
            </summary>
            <param name="assembly">The loaded assembly.</param>
            <param name="skipOrdering">
            A <see cref="T:System.Boolean"/> indicating if the ordering of hbm.xml files can be skipped.
            </param>
            <returns>This configuration object.</returns>
            <remarks>
            <para>
            The order of <c>hbm.xml</c> files only matters if the attribute "extends" is used.
            The ordering should only be done when needed because it takes extra time 
            to read the XML files to find out the order the files should be passed to
            the <see cref="T:NHibernate.Cfg.HbmBinder"/>. If you don't use the "extends" attribute then it is
            reccommended to call this with <c>skipOrdering=true</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddDirectory(System.IO.DirectoryInfo)">
            <summary>
            Read all mapping documents from a directory tree. Assume that any
            file named <c>*.hbm.xml</c> is a mapping document.
            </summary>
            <param name="dir">a directory</param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GenerateDropSchemaScript(NHibernate.Dialect.Dialect)">
            <summary>
            Generate DDL for droping tables
            </summary>
            <seealso cref="T:NHibernate.Tool.hbm2ddl.SchemaExport"/>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GenerateSchemaCreationScript(NHibernate.Dialect.Dialect)">
            <summary>
            Generate DDL for creating tables
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SecondPassCompile">
            <remarks>
            This method may be called many times!!
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.BuildSessionFactory">
            <summary>
            Instantiate a new <see cref="T:NHibernate.ISessionFactory"/>, using the properties and mappings in this
            configuration. The <see cref="T:NHibernate.ISessionFactory"/> will be immutable, so changes made to the
            configuration after building the <see cref="T:NHibernate.ISessionFactory"/> will not affect it.
            </summary>
            <returns>An <see cref="T:NHibernate.ISessionFactory"/> instance.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetDefaultAssembly(System.String)">
            <summary>
            Set the default assembly to use for the mappings added to the configuration
            afterwards.
            </summary>
            <param name="defaultAssembly">The default assembly name.</param>
            <returns>This configuration instance.</returns>
            <remarks>
            This setting can be overridden for a mapping file by setting <c>default-assembly</c>
            attribute of <c>&lt;hibernate-mapping&gt;</c> element.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetDefaultNamespace(System.String)">
            <summary>
            Set the default namespace to use for the mappings added to the configuration
            afterwards.
            </summary>
            <param name="defaultNamespace">The default namespace.</param>
            <returns>This configuration instance.</returns>
            <remarks>
            This setting can be overridden for a mapping file by setting <c>default-namespace</c>
            attribute of <c>&lt;hibernate-mapping&gt;</c> element.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetInterceptor(NHibernate.IInterceptor)">
            <summary>
            Sets the default interceptor for use by all sessions.
            </summary>
            <param name="interceptor">The default interceptor.</param>
            <returns>This configuration instance.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetProperties(System.Collections.IDictionary)">
            <summary>
            Specify a completely new set of properties
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddProperties(System.Collections.IDictionary)">
            <summary>
            Adds an <see cref="T:System.Collections.IDictionary"/> of configuration properties.  The 
            Key is the name of the Property and the Value is the <see cref="T:System.String"/>
            value of the Property.
            </summary>
            <param name="properties">An <see cref="T:System.Collections.IDictionary"/> of configuration properties.</param>
            <returns>
            This <see cref="T:NHibernate.Cfg.Configuration"/> object.
            </returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetProperty(System.String,System.String)">
            <summary>
            Sets the value of the configuration property.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="value">The value of the property.</param>
            <returns>
            This configuration object.
            </returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetProperty(System.String)">
            <summary>
            Gets the value of the configuration property.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>The configured value of the property, or <see langword="null" /> if the property was not specified.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure">
            <summary>
            Configure NHibernate using the <c>&lt;hibernate-configuration&gt;</c> section
            from the application config file, if found, or the file <c>hibernate.cfg.xml</c>
            otherwise.
            </summary>
            <returns>A configuration object initialized with the file.</returns>
            <remarks>
            To configure NHibernate explicitly using <c>hibernate.cfg.xml</c>, ignoring
            the application configuration file, use this code:
            <code>
            	configuration.Configure("path/to/hibernate.cfg.xml");
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.Xml.XmlNode)">
            <summary>
            Configure NHibernate from an <see cref="T:System.Xml.XmlNode"/> representing the root
            <c>&lt;hibernate-configuration&gt;</c> element.
            </summary>
            <param name="node">Configuration node</param>
            <returns>This Configuration object</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.String)">
            <summary>
            Configure NHibernate using the file specified.
            </summary>
            <param name="fileName">The location of the XML file to use to configure NHibernate.</param>
            <returns>A Configuration object initialized with the file.</returns>
            <remarks>
            Calling Configure(string) will overwrite the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.Reflection.Assembly,System.String)">
            <summary>
            Configure NHibernate using a resource contained in an Assembly.
            </summary>
            <param name="assembly">The <see cref="T:System.Reflection.Assembly"/> that contains the resource.</param>
            <param name="resourceName">The name of the manifest resource being requested.</param>
            <returns>A Configuration object initialized from the manifest resource.</returns>
            <remarks>
            Calling Configure(Assembly, string) will overwrite the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.Xml.XmlTextReader)">
            <summary>
            Configure NHibernate using the specified XmlTextReader.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlTextReader"/> that contains the Xml to configure NHibernate.</param>
            <returns>A Configuration object initialized with the file.</returns>
            <remarks>
            Calling Configure(XmlTextReader) will overwrite the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetCacheConcurrencyStrategy(System.Type,System.String)">
            <summary>
            Set up a cache for an entity class
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetCacheConcurrencyStrategy(System.String,System.String)">
            <summary>
            Set up a cache for a collection role
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.BuildSettings">
            <summary>
            Create an object-oriented view of the configuration properties
            </summary>
            <returns>A <see cref="T:NHibernate.Cfg.Settings"/> object initialized from the settings properties.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetNamingStrategy(NHibernate.Cfg.INamingStrategy)">
            <summary>
            Set a custom naming strategy
            </summary>
            <param name="namingStrategy">the NamingStrategy to set</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.LoadMappingDocument(System.Xml.XmlTextReader,System.String)">
            <summary>
            Load and validate the mappings in the <see cref="T:System.Xml.XmlTextReader"/> against
            the nhibernate-mapping-2.2 schema, without adding them to the configuration.
            </summary>
            <remarks>
            This method is made public to be usable from the unit tests. It is not intended
            to be called by end users.
            </remarks>
            <param name="hbmReader">The XmlReader that contains the mapping.</param>
            <param name="name">The name of the document, for error reporting purposes.</param>
            <returns>Validated XmlDocument built from the XmlReader.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlReader(System.Xml.XmlTextReader)">
            <summary>
            Adds the Mappings in the <see cref="T:System.Xml.XmlTextReader"/> after validating it
            against the nhibernate-mapping-2.2 schema.
            </summary>
            <param name="hbmReader">The XmlTextReader that contains the mapping.</param>
            <returns>This Configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlReader(System.Xml.XmlTextReader,System.String)">
            <summary>
            Adds the Mappings in the <see cref="T:System.Xml.XmlTextReader"/> after validating it
            against the nhibernate-mapping-2.2 schema.
            </summary>
            <param name="hbmReader">The XmlTextReader that contains the mapping.</param>
            <param name="name">The name of the document to use for error reporting. May be <see langword="null"/>.</param>
            <returns>This Configuration object.</returns>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.MappingSchemaCollection">
            <summary></summary>
            <remarks>Allocate on first use as we are expensive in time/space</remarks>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.CfgSchemaCollection">
            <summary></summary>
            <remarks>Allocate on first use as we are expensive in time/space</remarks>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.ClassMappings">
            <summary>
            The class mappings 
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.CollectionMappings">
            <summary>
            The collection mappings
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.TableMappings">
            <summary>
            The table mappings
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamedQueries">
            <summary>
            The named queries
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Interceptor">
            <summary>
            Gets or sets the <see cref="T:NHibernate.IInterceptor"/> to use.
            </summary>
            <value>The <see cref="T:NHibernate.IInterceptor"/> to use.</value>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Properties">
            <summary>
            Gets or sets the <see cref="T:System.Collections.IDictionary"/> that contains the configuration
            properties and their values.
            </summary>
            <value>
            The <see cref="T:System.Collections.IDictionary"/> that contains the configuration
            properties and their values.
            </value>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Imports">
            <summary>
            Get the query language imports
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamedSQLQueries">
            <summary>
            The named SQL queries
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamingStrategy">
            <summary>
            Naming strategy for tables and columns
            </summary>
        </member>
        <member name="T:NHibernate.Engine.IMapping">
            <summary>
            Defines operations common to "compiled" mappings (ie. <c>SessionFactory</c>) and
            "uncompiled" mappings (ie <c>Configuration</c> that are used by implementors of <c>IType</c>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IMapping.GetIdentifierType(System.Type)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.IMapping.GetIdentifierPropertyName(System.Type)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.IMapping.GetPropertyType(System.Type,System.String)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSectionHandler">
            <summary>
            Summary description for ConfigurationSectionHandler.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.DefaultNamingStrategy">
            <summary>
            The default <cref name="INamingStrategy"/>
            </summary>
            <remarks>See <cref name="ImprovedNamingStrategy"/> for a better alternative</remarks>
        </member>
        <member name="T:NHibernate.Cfg.INamingStrategy">
            <summary>
            A set of rules for determining the physical column and table names given the information in the mapping
            document. May be used to implement project-scoped naming standards for database objects.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return a table name for an entity class
            </summary>
            <param name="className">the fully-qualified class name</param>
            <returns>a table name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return a column name for a property path expression 
            </summary>
            <param name="propertyName">a property path</param>
            <returns>a column name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.TableName(System.String)">
            <summary>
            Alter the table name given in the mapping document
            </summary>
            <param name="tableName">a table name</param>
            <returns>a table name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.ColumnName(System.String)">
            <summary>
            Alter the column name given in the mapping document
            </summary>
            <param name="columnName">a column name</param>
            <returns>a column name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return a table name for a collection
            </summary>
            <param name="className">the fully-qualified name of the owning entity class</param>
            <param name="propertyName">a property path</param>
            <returns>a table name</returns>
        </member>
        <member name="F:NHibernate.Cfg.DefaultNamingStrategy.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return the unqualified class name
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return the unqualified property name
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.TableName(System.String)">
            <summary>
            Return the argument
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.ColumnName(System.String)">
            <summary>
            Return the argument
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return the unqualified property name
            </summary>
            <param name="className"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cfg.Environment">
            <summary>
            Provides access to configuration information.
            </summary>
            <remarks>
            NHibernate has two property scopes:
            <list>
            	<item><description>
            	 Factory-level properties may be passed to the <see cref="T:NHibernate.ISessionFactory"/> when it is
            	 instantiated. Each instance might have different property values. If no properties are
            	 specified, the factory gets them from Environment
            	</description></item>
            	<item><description>
            	 System-level properties are shared by all factory instances and are always determined
            	 by the <see cref="T:NHibernate.Cfg.Environment"/> properties
            	</description></item>
            </list>
            In NHibernate, <c>&lt;nhibernate&gt;</c> section in the application configuration file
            corresponds to Java system-level properties; <c>&lt;hibernate-configuration&gt;</c>
            section is considered to be the session-factory-level configuration. It is possible
            to use the applicatoin configuration file (App.config) together with the NHibernate configuration
            file (hibernate.cfg.xml) at the same time.
            </remarks>
        </member>
        <member name="F:NHibernate.Cfg.Environment.ConnectionStringName">
            <summary>
            Used to find the .Net 2.0 named connection string
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Environment.VerifyProperties(System.Collections.IDictionary)">
            <summary>
            Issue warnings to user when any obsolete property names are used.
            </summary>
            <param name="props"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cfg.Environment.Version">
            <summary>
            NHibernate version (informational).
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Environment.Properties">
            <summary>
            Gets a copy of the configuration found in <c>&lt;nhibernate&gt;</c> section
            of app.config/web.config.
            </summary>
            <remarks>
            This is the replacement for hibernate.properties
            </remarks>
        </member>
        <member name="P:NHibernate.Cfg.Environment.BytecodeProvider">
            <summary>
            The bytecode provider to use.
            </summary>
            <remarks>
            This property is read from the <c>&lt;nhibernate&gt;</c> section
            of the application configuration file by default. Since it is not
            always convenient to configure NHibernate through the application
            configuration file, it is also possible to set the property value
            manually. This should only be done before a configuration object
            is created, otherwise the change may not take effect.
            </remarks>
        </member>
        <member name="P:NHibernate.Cfg.Environment.UseReflectionOptimizer">
            <summary>
            Whether to enable the use of reflection optimizer
            </summary>
            <remarks>
            This property is read from the <c>&lt;nhibernate&gt;</c> section
            of the application configuration file by default. Since it is not
            always convenient to configure NHibernate through the application
            configuration file, it is also possible to set the property value
            manually. This should only be done before a configuration object
            is created, otherwise the change may not take effect.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.HbmBinder.FullClassName(System.String,NHibernate.Cfg.Mappings)">
            <summary>
            Converts a partial class name into a fully qualified one
            </summary>
            <param name="className"></param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.HbmBinder.ClassForFullNameChecked(System.String,System.String)">
            <summary>
            Attempts to find a type by its full name. Throws a <see cref="T:NHibernate.MappingException"/>
            using the provided <paramref name="errorMessage"/> in case of failure.
            </summary>
            <param name="fullName">name of the class to find</param>
            <param name="errorMessage">Error message to use for
            the <see cref="T:NHibernate.MappingException"/> in case of failure. Should contain
            the <c>{0}</c> formatting placeholder.</param>
            <returns>A <see cref="T:System.Type"/> instance.</returns>
            <exception cref="T:NHibernate.MappingException">
            Thrown when there is an error loading the class.
            </exception>
        </member>
        <member name="M:NHibernate.Cfg.HbmBinder.ClassForNameChecked(System.String,NHibernate.Cfg.Mappings,System.String)">
            <summary>
            Similar to <see cref="M:NHibernate.Cfg.HbmBinder.ClassForFullNameChecked(System.String,System.String)"/>, but handles short class names
            by calling <see cref="M:NHibernate.Cfg.HbmBinder.FullClassName(System.String,NHibernate.Cfg.Mappings)"/>.
            </summary>
            <param name="name"></param>
            <param name="mappings"></param>
            <param name="errorMessage"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.HbmBinder.BindCollection(System.Xml.XmlNode,NHibernate.Mapping.Collection,System.String,System.String,System.Type,NHibernate.Cfg.Mappings)">
            <remarks>
            Called for all collections. <paramref name="containingType" /> parameter
            was added in NH to allow for reflection related to generic types.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.HbmBinder.BindArray(System.Xml.XmlNode,NHibernate.Mapping.Array,System.String,System.String,System.Type,NHibernate.Cfg.Mappings)">
            <remarks>
            Called for arrays and primitive arrays
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.HbmBinder.BindListSecondPass(System.Xml.XmlNode,NHibernate.Mapping.List,System.Collections.IDictionary,NHibernate.Cfg.Mappings)">
            <remarks>
            Called for Lists, arrays, primitive arrays
            </remarks>>
        </member>
        <member name="M:NHibernate.Cfg.HbmBinder.BindMapSecondPass(System.Xml.XmlNode,NHibernate.Mapping.Map,System.Collections.IDictionary,NHibernate.Cfg.Mappings)">
            <summary>
            Called for Maps
            </summary>
            <param name="node"></param>
            <param name="model"></param>
            <param name="classes"></param>
            <param name="mappings"></param>
        </member>
        <member name="M:NHibernate.Cfg.HbmBinder.BindCollectionSecondPass(System.Xml.XmlNode,NHibernate.Mapping.Collection,System.Collections.IDictionary,NHibernate.Cfg.Mappings)">
            <remarks>
            Called for all collections
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.ImprovedNamingStrategy">
            <summary>
            Summary description for ImprovedNamingStrategy.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.ImprovedNamingStrategy.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return the unqualified class name, mixed case converted to underscores
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return the full property path with underscore seperators, mixed case converted to underscores
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.TableName(System.String)">
            <summary>
            Convert mixed case to underscores
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.ColumnName(System.String)">
            <summary>
            Convert mixed case to underscores
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return the full property path prefixed by the unqualified class name, with underscore seperators, mixed case converted to underscores
            </summary>
            <param name="className"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cfg.Mappings">
            <summary>
            A collection of mappings from classes and collections to relational database tables.
            </summary>
            <remarks>Represents a single <c>&lt;hibernate-mapping&gt;</c> element.</remarks>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddClass(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddCollection(NHibernate.Mapping.Collection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddUniquePropertyReference(System.Type,System.String)">
            <summary>
            
            </summary>
            <param name="referencedClass"></param>
            <param name="propertyName"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.GetClass(System.Type)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.GetCollection(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddImport(System.String,System.String)">
            <summary>
            Adds an import to allow for the full class name <c>Namespace.Entity</c> 
            to be referenced as <c>Entity</c> or some other name in HQL.
            </summary>
            <param name="className">The name of the type that is being renamed.</param>
            <param name="rename">The new name to use in HQL for the type.</param>
            <exception cref="T:NHibernate.MappingException">Thrown when the rename already identifies another type.</exception>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddTable(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="schema"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.GetTable(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="schema"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.NamingStrategy">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultNamespace">
            <summary>
            The default namespace for persistent classes
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultAssembly">
            <summary>
            The default assembly for persistent classes
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.SchemaName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultCascade">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultAccess">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.IsAutoImport">
            <summary>
            Gets or sets a boolean indicating if the Fully Qualified Type name should
            automattically have an import added as the class name.
            </summary>
            <value><see langword="true" /> if the class name should be used as an import.</value>
            <remarks>
            Auto-import is used to shorten the string used to refer to types to just their
            unqualified name.  So if the type <c>MyAssembly.MyNamespace.MyClass, MyAssembly</c> has
            <c>auto-import="false"</c> then all use of it in HQL would need to be the fully qualified
            version <c>MyAssembly.MyNamespace.MyClass</c>. If <c>auto-import="true"</c>, the type could
            be referred to in HQL as just <c>MyClass</c>.
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.Settings">
            <summary>
            Settings that affect the behavior of NHibernate at runtime.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.SettingsFactory">
            <summary>
            Reads configuration properties and configures a <see cref="T:NHibernate.Cfg.Settings"/> instance. 
            </summary>
        </member>
        <member name="T:NHibernate.Classic.ILifecycle">
            <summary>
            Provides callbacks from the <see cref="T:NHibernate.ISession"/> to the persistent object. Persistent classes may
            implement this interface but they are not required to.
            </summary>
            <remarks>
            <para>
            <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)"/>, <see cref="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)"/>, and <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)"/> are intended to be used
            to cascade saves and deletions of dependent objects. This is an alternative to declaring cascaded
            operations in the mapping file.
            </para>
            <para>
            <see cref="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)"/> may be used to initialize transient properties of the object from its persistent
            state. It may <em>not</em> be used to load dependent objects since the <see cref="T:NHibernate.ISession"/> interface
            may not be invoked from inside this method.
            </para>
            <para>
            A further intended usage of <see cref="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)"/>, <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)"/>, and <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)"/>
            is to store a reference to the <see cref="T:NHibernate.ISession"/> for later use.
            </para>
            <para>
            If <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)"/>, <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)"/>, or <see cref="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)"/> return
            <see cref="F:NHibernate.Classic.LifecycleVeto.Veto"/>, the operation is silently vetoed. If a <see cref="T:NHibernate.CallbackException"/>
            is thrown, the operation is vetoed and the exception is passed back to the application.
            </para>
            <para>
            Note that <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)"/> is called after an identifier is assigned to the object, except when
            <c>identity</c> key generation is used.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)">
            <summary>
            Called when an entity is saved
            </summary>
            <param name="s">The session</param>
            <returns>If we should veto the save</returns>
        </member>
        <member name="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)">
            <summary>
            Called when an entity is passed to <see cref="M:NHibernate.ISession.Update(System.Object)"/>.
            </summary>
            <param name="s">The session</param>
            <returns>A <see cref="T:NHibernate.Classic.LifecycleVeto"/> value indicating whether the operation
            should be vetoed or allowed to proceed.</returns>
            <remarks>
            This method is <em>not</em> called every time the object's state is
            persisted during a flush.
            </remarks>
        </member>
        <member name="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)">
            <summary>
            Called when an entity is deleted
            </summary>
            <param name="s">The session</param>
            <returns>A <see cref="T:NHibernate.Classic.LifecycleVeto"/> value indicating whether the operation
            should be vetoed or allowed to proceed.</returns>
        </member>
        <member name="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)">
            <summary>
            Called after an entity is loaded. 
            </summary>
            <remarks>
            <note>It is illegal to access the <see cref="T:NHibernate.ISession"/> from inside this method.</note>. 
            However, the object may keep a reference to the session for later use
            </remarks>
            <param name="s">The session</param>
            <param name="id">The identifier</param>
        </member>
        <member name="F:NHibernate.Classic.LifecycleVeto.Veto">
            <summary>
            Veto the action
            </summary>
        </member>
        <member name="F:NHibernate.Classic.LifecycleVeto.NoVeto">
            <summary>
            Accept the action
            </summary>
        </member>
        <member name="T:NHibernate.Classic.IValidatable">
            <summary>
            Implemented by persistent classes with invariants that must be checked before inserting
            into or updating the database
            </summary>
        </member>
        <member name="M:NHibernate.Classic.IValidatable.Validate">
            <summary>
            Validate the state of the object before persisting it. If a violation occurs,
            throw a <see cref="T:NHibernate.Classic.ValidationFailure"/>. This method must not change the state of the object
            by side-effect.
            </summary>
        </member>
        <member name="T:NHibernate.Classic.ValidationFailure">
            <summary>
            Thrown from <see cref="M:NHibernate.Classic.IValidatable.Validate"/> when an invariant was violated. Some applications
            might subclass this exception in order to provide more information about the violation
            </summary>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentGenericBag`1">
            <summary>
            An unordered, unkeyed collection that can contain the same element
            multiple times. The .NET collections API, has no <c>Bag</c>.
            The <see cref="T:System.Collections.Generic.ICollection`1"/> interface closely resembles bag semantics,
            however NHibernate for .NET 1.1 used <see cref="T:System.Collections.IList"/> so 
            <see cref="T:System.Collections.Generic.IList`1"/> is used to ensure the easiest transition
            to generics.
            </summary>
            <typeparam name="T">The type of the element the bag should hold.</typeparam>
            <remarks>The underlying collection used is an <see cref="T:System.Collections.Generic.List`1"/></remarks>
        </member>
        <member name="T:NHibernate.Collection.AbstractPersistentCollection">
            <summary>
            Base class for implementing <see cref="T:NHibernate.Collection.IPersistentCollection"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Collection.IPersistentCollection">
            <summary>
            <para>
            Persistent collections are treated as value objects by NHibernate.
            ie. they have no independent existence beyond the object holding
            a reference to them. Unlike instances of entity classes, they are
            automatically deleted when unreferenced and automatically become
            persistent when held by a persistent object. Collections can be
            passed between different objects (change "roles") and this might
            cause their elements to move from one database table to another.
            </para>
            <para>
            NHibernate "wraps" a collection in an instance of
            <see cref="T:NHibernate.Collection.IPersistentCollection"/>. This mechanism is designed
            to support tracking of changes to the collection's persistent
            state and lazy instantiation of collection elements. The downside
            is that only certain abstract collection types are supported and
            any extra semantics are lost.
            </para>
            <para>
            Applications should <b>never</b> use classes in this namespace
            directly, unless extending the "framework" here.
            </para>
            <para>
            Changes to <b>structure</b> of the collection are recorded by the
            collection calling back to the session. Changes to mutable
            elements (ie. composite elements) are discovered by cloning their
            state when the collection is initialized and comparing at flush
            time.
            </para>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.PostAction">
            <summary>
            Clears out any Queued Additions.
            </summary>
            <remarks>
            After a Flush() the database is in synch with the in-memory
            contents of the Collection.  Since everything is in synch remove
            any Queued Additions.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetValue">
            <summary>
            Return the user-visible collection (or array) instance
            </summary>
            <returns>
            By default, the NHibernate wrapper is an acceptable collection for
            the end user code to work with because it is interface compatible.
            An NHibernate PersistentList is an IList, an NHibernate PersistentMap is an IDictionary
            and those are the types user code is expecting.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.BeginRead">
            <summary>
            Called just before reading any rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called after reading all rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <remarks>
            This should be overridden by sub collections that use temporary collections
            to store values read from the db.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.UnsetSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Disassociate this collection from the given session.
            </summary>
            <param name="session"></param>
            <returns>true if this was currently associated with the given session</returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.SetCurrentSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Associate the collection with the given session.
            </summary>
            <param name="session"></param>
            <returns>false if the collection was already associated with the session</returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Read the state of the collection from a disassembled cached value.
            </summary>
            <param name="persister"></param>
            <param name="disassembled"></param>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.Entries">
            <summary>
            Iterate all collection entries, during update of the database
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerable"/> that gives access to all entries
            in the collection.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)">
            <summary>
            Reads the row from the <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <remarks>
            This method should be prepared to handle duplicate elements caused by fetching multiple collections,
            or <see cref="M:NHibernate.Hql.Classic.QueryTranslator.FetchedCollections.IsUnsafe(NHibernate.Persister.Collection.IQueryableCollection)"/> should be updated
            to return <see langword="true"/> for the collection type.
            </remarks>
            <param name="reader">The IDataReader that contains the value of the Identifier</param>
            <param name="role">The persister for this Collection.</param>
            <param name="descriptor">The descriptor providing result set column names</param>
            <param name="owner">The owner of this Collection.</param>
            <returns>The object that was contained in the row.</returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetIdentifier(System.Object,System.Int32)">
            <summary>
            Get the identifier of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetIndex(System.Object,System.Int32)">
            <summary>
            Get the index of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetElement(System.Object)">
            <summary>
            Get the value of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.BeforeInitialize(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called before any elements are read into the collection,
            allowing appropriate initializations to occur.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this persistent collection.</param>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            Does the current state exactly match the snapshot?
            </summary>
            <param name="elementType">The <see cref="T:NHibernate.Type.IType"/> to compare the elements of the Collection.</param>
            <returns>
            <see langword="true"/> if the wrapped collection is different than the snapshot
            of the collection or if one of the elements in the collection is
            dirty.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Disassemble the collection, ready for the cache
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>The contents of the persistent collection in a cacheable form.</returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the rows for this collection
            need to be recreated in the table.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>
            <see langword="false"/> by default since most collections can determine which rows need to be
            individually updated/inserted/deleted.  Currently only <see cref="T:NHibernate.Collection.PersistentBag"/>'s for <c>many-to-many</c>
            need to be recreated.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetSnapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Return a new snapshot of the current state of the collection
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.ForceInitialization">
            <summary>
            To be called internally by the session, forcing
            immediate initalization.
            </summary>
            <remarks>
            This method is similar to <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)"/>, except that different exceptions are thrown.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.EntryExists(System.Object,System.Int32)">
            <summary>
            Does an element exist at this entry in the collection?
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to insert this element?
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to update this element?
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetDeletes(NHibernate.Type.IType,System.Boolean)">
            <summary>
            Get all the elements that need deleting
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.IsWrapper(System.Object)">
            <summary>
            Is this the wrapper for the given underlying collection instance?
            </summary>
            <param name="collection">The collection to see if this IPersistentCollection is wrapping.</param>
            <returns>
            <see langword="true" /> if the IPersistentCollection is wrappping the collection instance,
            <see langword="false" /> otherwise.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.PreInsert(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called before inserting rows, to ensure that any surrogate keys are fully generated
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.AfterRowInsert(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32)">
            <summary>
            Called after inserting a row, to fetch the natively generated id
            </summary>
            <param name="persister"></param>
            <param name="entry"></param>
            <param name="i"></param>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetOrphans(System.Object,System.Type)">
            <summary>
            Get all "orphaned" elements
            </summary>
            <param name="snapshot">The snapshot of the collection.</param>
            <param name="entityName">The persistent class whose objects
            the collection is expected to contain.</param>
            <returns>
            An <see cref="T:System.Collections.ICollection"/> that contains all of the elements
            that have been orphaned.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetSnapshotElement(System.Object,System.Int32)">
            <summary>
            Get the snapshot value of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.AfterInitialize(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called after initializing from cache
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.ClearDirty">
            <summary>
            Clear the dirty flag, after flushing changes
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.Dirty">
            <summary>
            Mark the collection as dirty
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.Owner">
            <summary>
            The owning entity.
            </summary>
            <remarks>
            Note that the owner is only set during the flush
            cycle, and when a new collection wrapper is created
            while loading an entity.
            </remarks>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.Empty">
            <summary>
            Is the initialized collection empty?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.IsDirectlyAccessible">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the underlying collection is directly
            accessable through code.
            </summary>
            <value>
            <see langword="true"/> if we are not guaranteed that the NHibernate collection wrapper
            is being used.
            </value>
            <remarks>
            This is typically <see langword="false"/> whenever a transient object that contains a collection is being
            associated with an <see cref="T:NHibernate.ISession"/> through <see cref="M:NHibernate.ISession.Save(System.Object)"/> or <see cref="M:NHibernate.ISession.SaveOrUpdate(System.Object)"/>.
            NHibernate can't guarantee that it will know about all operations that would cause NHibernate's collections
            to call <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Read"/> or <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Write"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.WasInitialized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.HasQueuedAdds">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.QueuedAddsCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.CollectionSnapshot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.IsDirty">
            <summary>
            Is the collection dirty? Note that this is only
            reliable during the flush cycle, after the
            collection elements are dirty checked against
            the snapshot.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Read">
            <summary>
            Called by any read-only method of the collection interface
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Write">
            <summary>
            Called by any writer method of the collection interface
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.QueueAdd(System.Object)">
            <summary>
            Queue an addition if the peristent collection supports it
            </summary>
            <returns>
            <see langword="true" /> if the addition was queued up, <see langword="false" /> if the persistent collection
            doesn't support Queued Addition.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.QueueAddAll(System.Collections.ICollection)">
            <summary>
            Queue additions
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.DelayedAddAll(System.Collections.ICollection,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            After reading all existing elements from the database,
            add the queued elements to the underlying collection.
            </summary>
            <param name="coll">The <see cref="T:System.Collections.ICollection"/> to add.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that
            is currently loading the collection.</param>
            <remarks>
            The default implementation is to throw an <see cref="T:NHibernate.AssertionFailure"/>
            because most collections do not support delayed addition.  If the collection
            does then override this method.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.PostAction">
            <summary>
            Clears out any Queued Additions.
            </summary>
            <remarks>
            After a Flush() the database is in synch with the in-memory
            contents of the Collection.  Since everything is in synch remove
            any Queued Additions.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.#ctor">
            <summary>
            Not called by Hibernate, but used by non-NET serialization, eg. SOAP libraries.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Not called by Hibernate, but used by non-NET serialization, eg. SOAP libraries.
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetValue">
            <summary>
            Return the user-visible collection (or array) instance
            </summary>
            <returns>
            By default, the NHibernate wrapper is an acceptable collection for
            the end user code to work with because it is interface compatible.
            An NHibernate PersistentList is an IList, an NHibernate PersistentMap is an IDictionary
            and those are the types user code is expecting.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.BeginRead">
            <summary>
            Called just before reading any rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called after reading all rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <remarks>
            This should be overridden by sub collections that use temporary collections
            to store values read from the db.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)">
            <summary>
            Initialize the collection, if possible, wrapping any exceptions
            in a runtime exception
            </summary>
            <param name="writing">currently obsolete</param>
            <exception cref="T:NHibernate.LazyInitializationException">if we cannot initialize</exception>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.SetInitialized">
            <summary>
            Mark the collection as initialized.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.UnsetSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Disassociate this collection from the given session.
            </summary>
            <param name="session"></param>
            <returns>true if this was currently associated with the given session</returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.SetCurrentSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Associate the collection with the given session.
            </summary>
            <param name="session"></param>
            <returns>false if the collection was already associated with the session</returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Read the state of the collection from a disassembled cached value.
            </summary>
            <param name="persister"></param>
            <param name="disassembled"></param>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Entries">
            <summary>
            Iterate all collection entries, during update of the database
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)">
            <summary>
            Reads the row from the <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="reader">The IDataReader that contains the value of the Identifier</param>
            <param name="role">The persister for this Collection.</param>
            <param name="descriptor">The descriptor providing result set column names</param>
            <param name="owner">The owner of this Collection.</param>
            <returns>The object that was contained in the row.</returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetIndex(System.Object,System.Int32)">
            <summary>
            Get the index of the given collection entry
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.BeforeInitialize(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called before any elements are read into the collection,
            allowing appropriate initializations to occur.
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            Does the current state exactly match the snapshot?
            </summary>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Snapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Return a new snapshot of the current state
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Disassemble the collection, ready for the cache
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the rows for this collection
            need to be recreated in the table.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>
            <see langword="false"/> by default since most collections can determine which rows need to be
            individually updated/inserted/deleted.  Currently only <see cref="T:NHibernate.Collection.PersistentBag"/>'s for <c>many-to-many</c>
            need to be recreated.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetSnapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.ForceInitialization">
            <summary>
            To be called internally by the session, forcing
            immediate initalization.
            </summary>
            <remarks>
            This method is similar to <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)"/>, except that different exceptions are thrown.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.EntryExists(System.Object,System.Int32)">
            <summary>
            Does an element exist at this entry in the collection?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to insert this element?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to update this element?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetDeletes(NHibernate.Type.IType,System.Boolean)">
            <summary>
            Get all the elements that need deleting
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.IsWrapper(System.Object)">
            <summary>
            Is this the wrapper for the given underlying collection instance?
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetSnapshot">
            <summary>
            Gets the Snapshot from the current session the collection 
            is in.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.PreInsert(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called before inserting rows, to ensure that any surrogate keys are fully generated
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.AfterRowInsert(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32)">
            <summary>
            Called after inserting a row, to fetch the natively generated id
            </summary>
            <param name="persister"></param>
            <param name="entry"></param>
            <param name="i"></param>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetOrphans(System.Object,System.Type)">
            <summary>
            Get all "orphaned" elements
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.Empty">
            <summary>
            Is the initialized collection empty?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsConnectedToSession">
            <summary>
            Is the collection currently connected to an open session?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsQueueAdditionEnabled">
            <summary>
            Is this collection in a state that would allow us to "queue" additions?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsDirectlyAccessible">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the underlying collection is directly
            accessable through code.
            </summary>
            <value>
            <see langword="true"/> if we are not guaranteed that the NHibernate collection wrapper
            is being used.
            </value>
            <remarks>
            This is typically <see langword="false"/> whenever a transient object that contains a collection is being
            associated with an <see cref="T:NHibernate.ISession"/> through <see cref="M:NHibernate.ISession.Save(System.Object)"/> or <see cref="M:NHibernate.ISession.SaveOrUpdate(System.Object)"/>.
            NHibernate can't guarantee that it will know about all operations that would cause NHibernate's collections
            to call <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Read"/> or <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Write"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.WasInitialized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.HasQueuedAdds">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.QueuedAddsCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.CollectionSnapshot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.Session">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericBag`1.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/>
            in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the bag is in.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericBag`1.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.Generic.IList{`0})">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/>
            that wraps an existing <see cref="T:System.Collections.Generic.IList`1"/> in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the bag is in.</param>
            <param name="coll">The <see cref="T:System.Collections.Generic.IList`1"/> to wrap.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericBag`1.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this Bag needs to be recreated
            in the database.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>
            <see langword="false"/> if this is a <c>one-to-many</c> bag, <see langword="true"/> if this is not
            a <c>one-to-many</c> bag.  Since a bag is an unordered, unindexed collection 
            that permits duplicates it is not possible to determine what has changed in a
            <c>many-to-many</c> so it is just recreated.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericBag`1.CountOccurrences(`0,System.Collections.Generic.ICollection{`0},NHibernate.Type.IType)">
            <summary>
            Counts the number of times that the <paramref name="element"/> occurs
            in the <paramref name="list"/>.
            </summary>
            <param name="element">The element to find in the list.</param>
            <param name="list">The <see cref="T:System.Collections.Generic.ICollection`1"/> to search.</param>
            <param name="elementType">The <see cref="T:NHibernate.Type.IType"/> that can determine equality.</param>
            <returns>
            The number of occurrences of the element in the list.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericBag`1.IsWrapper(System.Object)">
            <summary>
            Is this the wrapper for the given underlying bag instance?
            </summary>
            <param name="collection">The bag that might be wrapped.</param>
            <returns>
            <see langword="true" /> if the <paramref name="collection"/> is equal to the
            wrapped collection by object reference.
            </returns>
        </member>
        <member name="P:NHibernate.Collection.Generic.PersistentGenericBag`1.Empty">
            <summary>
            Is the initialized GenericBag empty?
            </summary>
            <value><see langword="true" /> if the bag has a Count==0, <see langword="false" /> otherwise.</value>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentIdentifierBag`1">
            <summary>
            Implements "bag" semantics more efficiently than <see cref="T:NHibernate.Collection.PersistentBag"/> by adding
            a synthetic identifier column to the table.
            </summary>
            <remarks>
            <para>
            The identifier is unique for all rows in the table, allowing very efficient
            updates and deletes.  The value of the identifier is never exposed to the 
            application. 
            </para>
            <para>
            Identifier bags may not be used for a many-to-one association.  Furthermore,
            there is no reason to use <c>inverse="true"</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentIdentifierBag`1.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this Bag from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentIdentifierBag.</param>
            <param name="disassembled">The disassembled PersistentIdentifierBag.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentGenericList`1">
            <summary>
            A persistent wrapper for an <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
            <typeparam name="T">The type of the element the list should hold.</typeparam>
            <remarks>The underlying collection used is a <see cref="T:System.Collections.Generic.List`1"/></remarks>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericList`1.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1"/>
            in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the list is in.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericList`1.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.Generic.IList{`0})">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1"/>
            that wraps an existing <see cref="T:System.Collections.Generic.IList`1"/> in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the bag is in.</param>
            <param name="coll">The <see cref="T:System.Collections.Generic.IList`1"/> to wrap.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericList`1.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            Does the current state of the list exactly match the snapshot?
            </summary>
            <param name="elementType">The <see cref="T:NHibernate.Type.IType"/> to compare the elements of the Collection.</param>
            <returns>
            <see langword="true"/> if the wrapped list is different than the snapshot
            of the list or if one of the elements in the collection is
            dirty.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericList`1.Snapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Return a new snapshot of the current state.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>
            A new <see cref="T:System.Collections.Generic.IList`1"/> that contains Deep Copies of the 
            Elements stored in this wrapped collection.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericList`1.GetOrphans(System.Object,System.Type)">
            <summary>
            Get all "orphaned" elements.
            </summary>
            <param name="snapshot">The snapshot of the collection.</param>
            <param name="entityName">The type of the entities the collection
            is supposed to contain.</param>
            <returns>
            An <see cref="T:System.Collections.ICollection"/> that contains all of the elements
            that have been orphaned.
            </returns>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentGenericMap`2">
            <summary>
            A persistent wrapper for a <see cref="T:System.Collections.Generic.IDictionary`2"/>.  Underlying
            collection is a <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </summary>
            <typeparam name="TKey">The type of the keys in the IDictionary.</typeparam>
            <typeparam name="TValue">The type of the elements in the IDictionary.</typeparam>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericMap`2.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.Generic.PersistentGenericMap`2"/>
            in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the map is in.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericMap`2.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.Generic.PersistentGenericMap`2"/>
            that wraps an existing <see cref="T:System.Collections.Generic.IDictionary`2"/> in the 
            <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the bag is in.</param>
            <param name="map">The <see cref="T:System.Collections.Generic.IDictionary`2"/> to wrap.</param>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentGenericSet`1">
            <summary>
            .NET has no design equivalent for Java's Set so we are going to use the
            Iesi.Collections library. This class is internal to NHibernate and shouldn't
            be used by user code.
            </summary>
            <remarks>
            The code for the Iesi.Collections library was taken from the article
            <a href="http://www.codeproject.com/csharp/sets.asp">Add Support for "Set" Collections
            to .NET</a> that was written by JasonSmith.
            </remarks>
        </member>
        <member name="F:NHibernate.Collection.Generic.PersistentGenericSet`1.internalSet">
            <summary>
            The <see cref="T:Iesi.Collections.Generic.ISet`1"/> that NHibernate is wrapping.
            </summary>
        </member>
        <member name="F:NHibernate.Collection.Generic.PersistentGenericSet`1.tempList">
            <summary>
            A temporary list that holds the objects while the set is being
            populated from the database.  
            </summary>
            <remarks>
            This is necessary to ensure that the object being added to the set doesn't
            have its <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>
            methods called during the load process.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.Snapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Returns a Hashtable where the Key &amp; the Value are both a Copy of the
            same object.
            <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Snapshot(NHibernate.Persister.Collection.ICollectionPersister)"/>
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            This constructor is NOT meant to be called from user code.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.#ctor(NHibernate.Engine.ISessionImplementor,Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Creates a new PersistentGenericSet initialized to the values in the Map.
            This constructor is NOT meant to be called from user code.
            </summary>
            <remarks>
            Only call this constructor if you consider the map initialized.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentGenericSet from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the set.</param>
            <param name="disassembled">The disassembled set.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.CopyTo(System.Array,System.Int32)">
            <summary>
            <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.BeginRead">
            <summary>
            Set up the temporary List that will be used in the EndRead() 
            to fully create the set.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Takes the contents stored in the temporary list created during <see cref="M:NHibernate.Collection.Generic.PersistentGenericSet`1.BeginRead"/>
            that was populated during <see cref="M:NHibernate.Collection.Generic.PersistentGenericSet`1.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)"/> and writes it to the underlying 
            set.
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Generic.PersistentGenericSet`1.Count">
            <summary>
            <see cref="P:System.Collections.ICollection.Count"/>
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Generic.PersistentGenericSet`1.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.ICollection.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Generic.PersistentGenericSet`1.SyncRoot">
            <summary>
            <see cref="P:System.Collections.ICollection.SyncRoot"/>
            </summary>
        </member>
        <member name="T:NHibernate.Collection.PersistentArrayHolder">
            <summary>
            A persistent wrapper for an array. lazy initialization is NOT supported
            </summary>
        </member>
        <member name="F:NHibernate.Collection.PersistentArrayHolder.array">
            <summary>
            The <see cref="P:NHibernate.Collection.PersistentArrayHolder.Array"/> that NHibernate is wrapping.
            </summary>
        </member>
        <member name="F:NHibernate.Collection.PersistentArrayHolder.tempList">
            <summary>
            A temporary list that holds the objects while the PersistentArrayHolder is being
            populated from the database.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.Snapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.IsWrapper(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.Elements">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.Entries">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.BeginRead">
            <summary>
            Before <see cref="M:NHibernate.Collection.PersistentArrayHolder.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)"/> is called the PersistentArrayHolder needs to setup 
            a temporary list to hold the objects.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Takes the contents stored in the temporary list created during <see cref="M:NHibernate.Collection.PersistentArrayHolder.BeginRead"/>
            that was populated during <see cref="M:NHibernate.Collection.PersistentArrayHolder.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)"/> and write it to the underlying 
            array.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this array holder from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the Array.</param>
            <param name="disassembled">The disassembled Array.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.GetValue">
            <summary>
            Returns the user-visible portion of the NHibernate PersistentArrayHolder.
            </summary>
            <returns>
            The array that contains the data, not the NHibernate wrapper.
            </returns>
        </member>
        <member name="P:NHibernate.Collection.PersistentArrayHolder.Array">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentArrayHolder.Empty">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Collection.PersistentBag">
            <summary>
            An unordered, unkeyed collection that can contain the same element
            multiple times. The .NET collections API has no Bag class.
            Most developers seem to use <see cref="T:System.Collections.IList"/>s to represent bag semantics,
            so NHibernate follows this practice.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentBag.CountOccurrences(System.Object,System.Collections.IList,NHibernate.Type.IType)">
            <summary>
            Counts the number of times that the <paramref name="element"/> occurs
            in the <paramref name="list"/>.
            </summary>
            <param name="element">The element to find in the list.</param>
            <param name="list">The <see cref="T:System.Collections.IList"/> to search.</param>
            <param name="elementType">The <see cref="T:NHibernate.Type.IType"/> that can determine equality.</param>
            <returns>
            The number of occurrences of the element in the list.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentBag.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentBag from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentBag.</param>
            <param name="disassembled">The disassembled PersistentBag.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.PersistentBag.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this PersistentBag needs to be recreated
            in the database.
            </summary>
            <param name="persister"></param>
            <returns>
            <see langword="false"/> if this is a <c>one-to-many</c> Bag, <see langword="true"/> if this is not
            a <c>one-to-many</c> Bag.  Since a Bag is an unordered, unindexed collection 
            that permits duplicates it is not possible to determine what has changed in a
            <c>many-to-many</c> so it is just recreated.
            </returns>
        </member>
        <member name="T:NHibernate.Collection.PersistentIdentifierBag">
            <summary>
            Implements "bag" semantics more efficiently than a regular <see cref="T:NHibernate.Collection.PersistentBag"/>
            by adding a synthetic identifier column to the table.
            </summary>
            <remarks>
            <para>
            The identifier is unique for all rows in the table, allowing very efficient
            updates and deletes.  The value of the identifier is never exposed to the 
            application. 
            </para>
            <para>
            PersistentIdentifierBags may not be used for a many-to-one association.  Furthermore,
            there is no reason to use <c>inverse="true"</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.PersistentIdentifierBag.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this Bag from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentIdentifierBag.</param>
            <param name="disassembled">The disassembled PersistentIdentifierBag.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="T:NHibernate.Collection.PersistentList">
            <summary>
            A persistent wrapper for an <see cref="T:System.Collections.IList"/>
            </summary>	
            <remarks>
            The underlying collection used in an <see cref="T:System.Collections.ArrayList"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.PersistentList.Snapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Return a new snapshot of the current state.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>
            A new <see cref="T:System.Collections.ArrayList"/> that contains Deep Copies of the 
            Elements stored in this wrapped collection.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentList.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            Does the current state of the list exactly match the snapshot?
            </summary>
            <param name="elementType">The <see cref="T:NHibernate.Type.IType"/> to compare the elements of the Collection.</param>
            <returns>
            <see langword="true"/> if the wrapped list is different than the snapshot
            of the list or if one of the elements in the collection is
            dirty.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentList.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.PersistentList"/>
            in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the list is in.</param>
        </member>
        <member name="M:NHibernate.Collection.PersistentList.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IList)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.PersistentList"/>
            that wraps an existing <see cref="T:System.Collections.IList"/> in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the list is in.</param>
            <param name="list">The <see cref="T:System.Collections.IList"/> to wrap.</param>
        </member>
        <member name="M:NHibernate.Collection.PersistentList.Contains(System.Object)">
            <seealso cref="M:System.Collections.IList.Contains(System.Object)"/>
        </member>
        <member name="M:NHibernate.Collection.PersistentList.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentList from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentList.</param>
            <param name="disassembled">The disassembled PersistentList.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="P:NHibernate.Collection.PersistentList.SyncRoot">
            <seealso cref="P:System.Collections.ICollection.SyncRoot"/>
        </member>
        <member name="P:NHibernate.Collection.PersistentList.IsSynchronized">
            <seealso cref="P:System.Collections.ICollection.IsSynchronized"/>
        </member>
        <member name="P:NHibernate.Collection.PersistentList.IsFixedSize">
            <seealso cref="P:System.Collections.IList.IsFixedSize"/>
        </member>
        <member name="P:NHibernate.Collection.PersistentList.IsReadOnly">
            <seealso cref="P:System.Collections.IList.IsReadOnly"/>
        </member>
        <member name="T:NHibernate.Collection.PersistentMap">
            <summary>
            A persistent wrapper for a <see cref="T:System.Collections.IDictionary"/>. Underlying collection
            is a <see cref="T:System.Collections.Hashtable"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentMap.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Construct an uninitialized PersistentMap.
            </summary>
            <param name="session">The ISession the PersistentMap should be a part of.</param>
        </member>
        <member name="M:NHibernate.Collection.PersistentMap.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IDictionary)">
            <summary>
            Construct an initialized PersistentMap based off the values from the existing IDictionary.
            </summary>
            <param name="session">The ISession the PersistentMap should be a part of.</param>
            <param name="map">The IDictionary that contains the initial values.</param>
        </member>
        <member name="M:NHibernate.Collection.PersistentMap.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentMap from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentMap.</param>
            <param name="disassembled">The disassembled PersistentMap.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="T:NHibernate.Collection.PersistentSet">
            <summary>
            .NET has no design equivalent for Java's Set so we are going to use the
            Iesi.Collections library. This class is internal to NHibernate and shouldn't
            be used by user code.
            </summary>
            <remarks>
            The code for the Iesi.Collections library was taken from the article
            <a href="http://www.codeproject.com/csharp/sets.asp">Add Support for "Set" Collections
            to .NET</a> that was written by JasonSmith.
            </remarks>
        </member>
        <member name="F:NHibernate.Collection.PersistentSet.internalSet">
            <summary>
            The <see cref="T:Iesi.Collections.ISet"/> that NHibernate is wrapping.
            </summary>
        </member>
        <member name="F:NHibernate.Collection.PersistentSet.tempList">
            <summary>
            A temporary list that holds the objects while the PersistentSet is being
            populated from the database.  
            </summary>
            <remarks>
            This is necessary to ensure that the object being added to the PersistentSet doesn't
            have its' <c>GetHashCode()</c> and <c>Equals()</c> methods called during the load
            process.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.PersistentSet.Snapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Returns a Hashtable where the Key &amp; the Value are both a Copy of the
            same object.
            <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Snapshot(NHibernate.Persister.Collection.ICollectionPersister)"/>
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentSet.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            This constructor is NOT meant to be called from user code.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentSet.#ctor(NHibernate.Engine.ISessionImplementor,Iesi.Collections.ISet)">
            <summary>
            Creates a new PersistentSet initialized to the values in the Map.
            This constructor is NOT meant to be called from user code.
            </summary>
            <remarks>
            Only call this constructor if you consider the map initialized.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.PersistentSet.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentSet from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentSet.</param>
            <param name="disassembled">The disassembled PersistentSet.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.PersistentSet.CopyTo(System.Array,System.Int32)">
            <summary>
            <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentSet.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentSet.BeginRead">
            <summary>
            Set up the temporary List that will be used in the EndRead() 
            to fully create the set.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentSet.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Takes the contents stored in the temporary list created during <c>BeginRead()</c>
            that was populated during <c>ReadFrom()</c> and write it to the underlying 
            PersistentSet.
            </summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentSet.Count">
            <summary>
            <see cref="P:System.Collections.ICollection.Count"/>
            </summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentSet.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.ICollection.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentSet.SyncRoot">
            <summary>
            <see cref="P:System.Collections.ICollection.SyncRoot"/>
            </summary>
        </member>
        <member name="T:NHibernate.Connection.ConnectionProvider">
            <summary>
            The base class for the ConnectionProvider.
            </summary>
        </member>
        <member name="T:NHibernate.Connection.IConnectionProvider">
            <summary>
            A strategy for obtaining ADO.NET <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <remarks>
            The <c>IConnectionProvider</c> interface is not intended to be exposed to the application.
            Instead it is used internally by NHibernate to obtain <see cref="T:System.Data.IDbConnection"/>. 
            Implementors should provide a public default constructor.
            </remarks>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.Configure(System.Collections.IDictionary)">
            <summary>
            Initialize the connection provider from the given properties.
            </summary>
            <param name="settings">The connection provider settings</param>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Dispose of a used <see cref="T:System.Data.IDbConnection"/>
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.GetConnection">
            <summary>
            Get an open <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <returns>An open <see cref="T:System.Data.IDbConnection"/>.</returns>
        </member>
        <member name="P:NHibernate.Connection.IConnectionProvider.Driver">
            <summary>
            Gets the <see cref="T:NHibernate.Driver.IDriver"/> this ConnectionProvider should use to 
            communicate with the .NET Data Provider
            </summary>
            <value>
            The <see cref="T:NHibernate.Driver.IDriver"/> to communicate with the .NET Data Provider.
            </value>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Closes the <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Configure(System.Collections.IDictionary)">
            <summary>
            Configures the ConnectionProvider with the Driver and the ConnectionString.
            </summary>
            <param name="settings">An <see cref="T:System.Collections.IDictionary"/> that contains the settings for this ConnectionProvider.</param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when a <see cref="F:NHibernate.Cfg.Environment.ConnectionString"/> could not be found 
            in the <c>settings</c> parameter or the Driver Class could not be loaded.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.GetNamedConnectionString(System.Collections.IDictionary)">
            <summary>
            Get the .NET 2.0 named connection string 
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when a <see cref="F:NHibernate.Cfg.Environment.ConnectionStringName"/> was found 
            in the <c>settings</c> parameter but could not be found in the app.config
            </exception>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.ConfigureDriver(System.Collections.IDictionary)">
            <summary>
            Configures the driver for the ConnectionProvider.
            </summary>
            <param name="settings">An <see cref="T:System.Collections.IDictionary"/> that contains the settings for the Driver.</param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <see cref="F:NHibernate.Cfg.Environment.ConnectionDriver"/> could not be 
            found in the <c>settings</c> parameter or there is a problem with creating
            the <see cref="T:NHibernate.Driver.IDriver"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.GetConnection">
            <summary>
            Get an open <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <returns>An open <see cref="T:System.Data.IDbConnection"/>.</returns>
        </member>
        <member name="F:NHibernate.Connection.ConnectionProvider._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this ConnectionProvider is being Disposed of or Finalized.</param>
            <remarks>
            <p>
            If this ConnectionProvider is being Finalized (<c>isDisposing==false</c>) then make 
            sure not to call any methods that could potentially bring this 
            ConnectionProvider back to life.
            </p>
            <p>
            If any subclasses manage resources that also need to be disposed of this method
            should be overridden, but don't forget to call it in the override.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Connection.ConnectionProvider.ConnectionString">
            <summary>
            Gets the <see cref="T:System.String"/> for the <see cref="T:System.Data.IDbConnection"/>
            to connect to the database.
            </summary>
            <value>
            The <see cref="T:System.String"/> for the <see cref="T:System.Data.IDbConnection"/>
            to connect to the database.
            </value>
        </member>
        <member name="P:NHibernate.Connection.ConnectionProvider.Driver">
            <summary>
            Gets the <see cref="T:NHibernate.Driver.IDriver"/> that can create the <see cref="T:System.Data.IDbConnection"/> object.
            </summary>
            <value>
            The <see cref="T:NHibernate.Driver.IDriver"/> that can create the <see cref="T:System.Data.IDbConnection"/>.
            </value>
        </member>
        <member name="T:NHibernate.Connection.ConnectionProviderFactory">
            <summary>
            Instanciates a connection provider given configuration properties.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProviderFactory.NewConnectionProvider(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Connection.DriverConnectionProvider">
            <summary>
            A ConnectionProvider that uses an IDriver to create connections.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.DriverConnectionProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Connection.DriverConnectionProvider"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.DriverConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Closes and Disposes of the <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.DriverConnectionProvider.GetConnection">
            <summary>
            Gets a new open <see cref="T:System.Data.IDbConnection"/> through 
            the <see cref="T:NHibernate.Driver.IDriver"/>.
            </summary>
            <returns>
            An Open <see cref="T:System.Data.IDbConnection"/>.
            </returns>
            <exception cref="T:System.Exception">
            If there is any problem creating or opening the <see cref="T:System.Data.IDbConnection"/>.
            </exception>
        </member>
        <member name="T:NHibernate.Connection.UserSuppliedConnectionProvider">
            <summary>
            An implementation of the <c>IConnectionProvider</c> that simply throws an exception when
            a connection is requested.
            </summary>
            <remarks>
            This implementation indicates that the user is expected to supply an ADO.NET connection
            </remarks>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> if this method is called
            because the user is responsible for closing <see cref="T:System.Data.IDbConnection"/>s.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called.  User is responsible for closing
            <see cref="T:System.Data.IDbConnection"/>s.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.GetConnection">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> if this method is called
            because the user is responsible for creating <see cref="T:System.Data.IDbConnection"/>s.
            </summary>
            <returns>
            No value is returned because an <see cref="T:System.InvalidOperationException"/> is thrown.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called.  User is responsible for creating
            <see cref="T:System.Data.IDbConnection"/>s.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.Configure(System.Collections.IDictionary)">
            <summary>
            Configures the ConnectionProvider with only the Driver class.
            </summary>
            <param name="settings"></param>
            <remarks>
            All other settings of the Connection are the responsibility of the User since they configured
            NHibernate to use a Connection supplied by the User.
            </remarks>
        </member>
        <member name="T:NHibernate.Context.ICurrentSessionContext">
            <summary>
            Defines the contract for implementations which know how to
            scope the notion of a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>.
            </summary>
            <remarks>
            <para>
            Implementations should adhere to the following:
            <list type="bullet">
            <item><description>contain a constructor accepting a single argument of type
            <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/></description></item>
            <item><description>should be thread safe</description></item>
            <item><description>should be fully serializable</description></item>
            </list>
            </para>
            <para>
            Implementors should be aware that they are also fully responsible for
            cleanup of any generated current-sessions.
            </para>
            <para>
            Note that there will be exactly one instance of the configured
            ICurrentSessionContext implementation per <see cref="T:NHibernate.ISessionFactory"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Context.ICurrentSessionContext.CurrentSession">
            <summary>
            Retrieve the current session according to the scoping defined
            by this implementation.
            </summary>
            <returns>The current session.</returns>
            <exception cref="T:NHibernate.HibernateException">Typically indicates an issue
            locating or creating the current session.</exception>
        </member>
        <member name="T:NHibernate.DebugHelpers.DictionaryProxy">
            <summary>
            Used to show a better debug display for dictionaries
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.AnsiSubstringFunction">
             <summary>
             ANSI-SQL substring  
             Documented in:
             ANSI X3.135-1992
             American National Standard for Information Systems - Database Language - SQL
             </summary>
             <remarks>
             Syntax:
            <![CDATA[
             <character substring function> ::=
             SUBSTRING <left paren> <character value expression> FROM < start position>
             [ FOR <string length> ] <right paren>
            ]]>
             </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Function.ISQLFunction">
             <summary>
             Provides support routines for the HQL functions as used
             in the various SQL Dialects
            
             Provides an interface for supporting various HQL functions that are
             translated to SQL. The Dialect and its sub-classes use this interface to
             provide details required for processing of the function.
             </summary>
        </member>
        <member name="M:NHibernate.Dialect.Function.ISQLFunction.ReturnType(NHibernate.Type.IType,NHibernate.Engine.IMapping)">
            <summary>
            The function return type
            </summary>
            <param name="columnType">The type of the first argument</param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Function.ISQLFunction.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Render the function call as SQL.
            </summary>
            <param name="args">List of arguments</param>
            <param name="factory"></param>
            <returns>SQL fragment for the fuction.</returns>
        </member>
        <member name="P:NHibernate.Dialect.Function.ISQLFunction.HasArguments">
            <summary>
            Does this function have any arguments?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Function.ISQLFunction.HasParenthesesIfNoArguments">
            <summary>
            If there are no arguments, are parens required?
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.AnsiTrimEmulationFunction">
            <summary>
            A SQLFunction implementation that emulates the ANSI SQL trim function
            on dialects which do not support the full definition.  However, this function
            definition does assume the availability of ltrim, rtrim, and replace functions
            which it uses in various combinations to emulate the desired ANSI trim()
            functionality.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Function.AnsiTrimEmulationFunction.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
             <summary>
             
             </summary>
             <param name="args"></param>
             <param name="factory"></param>
             <returns></returns>
             <remarks>
             according to both the ANSI-SQL and EJB3 specs, trim can either take
             exactly one parameter or a variable number of parameters between 1 and 4.
             from the SQL spec:
             <![CDATA[
             <trim function> ::=
                  TRIM <left paren> <trim operands> <right paren>
            
             <trim operands> ::=
                  [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>
            
             <trim specification> ::=
                  LEADING
                  | TRAILING
                  | BOTH
             ]]>
             If only trim specification is omitted, BOTH is assumed;
             if trim character is omitted, space is assumed
             </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Function.CastFunction">
            <summary>
            ANSI-SQL style cast(foo as type) where the type is a NHibernate type
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.CharIndexFunction">
            <summary>
            Emulation of locate() on Sybase
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Function.ClassicAggregateFunction.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
            <param name="acceptAsterisk">Whether the function accepts an asterisk (*) in place of arguments</param>
        </member>
        <member name="M:NHibernate.Dialect.Function.ClassicAggregateFunction.#ctor(System.String,System.Boolean,NHibernate.Type.IType)">
            <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
            <param name="acceptAsterisk">True if accept asterisk like argument</param>
            <param name="typeValue">Return type for the fuction.</param>
        </member>
        <member name="T:NHibernate.Dialect.Function.ClassicAvgFunction">
            <summary>
            Classic AVG sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.ClassicCountFunction">
            <summary>
            Classic COUNT sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.ClassicSumFunction">
            <summary>
            Classic SUM sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.NoArgSQLFunction">
            <summary>
            Summary description for NoArgSQLFunction.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.NvlFunction">
            <summary>
            Emulation of coalesce() on Oracle, using multiple nvl() calls
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.PositionSubstringFunction">
            <summary>
            Emulation of locate() on PostgreSQL
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.SQLFunctionTemplate">
            <summary>
            Represents HQL functions that can have different representations in different SQL dialects.
            E.g. in HQL we can define function <code>concat(?1, ?2)</code> to concatenate two strings 
            p1 and p2. Target SQL function will be dialect-specific, e.g. <code>(?1 || ?2)</code> for 
            Oracle, <code>concat(?1, ?2)</code> for MySql, <code>(?1 + ?2)</code> for MS SQL.
            Each dialect will define a template as a string (exactly like above) marking function 
            parameters with '?' followed by parameter's index (first index is 1).
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Function.SQLFunctionTemplate.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Applies the template to passed in arguments.
            </summary>
            <param name="args">args function arguments</param>
            <param name="factory">generated SQL function call</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Dialect.Function.StandardSQLFunction">
            <summary>
            Provides a standard implementation that supports the majority of the HQL
            functions that are translated to SQL.
            </summary>
            <remarks>
            The Dialect and its sub-classes use this class to provide details required
            for processing of the associated function.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Function.StandardSQLFunction.#ctor(System.String)">
            <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
        </member>
        <member name="M:NHibernate.Dialect.Function.StandardSQLFunction.#ctor(System.String,NHibernate.Type.IType)">
            <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
            <param name="typeValue">Return type for the fuction.</param>
        </member>
        <member name="T:NHibernate.Dialect.Function.VarArgsSQLFunction">
            <summary>
            Support for slightly more general templating than StandardSQLFunction,
            with an unlimited number of arguments.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.DB2400Dialect">
            <summary>
            An SQL dialect for DB2 on iSeries OS/400.
            </summary>
            <remarks>
            The DB2400Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.DB2400Driver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.DB2Dialect">
            <summary>
            An SQL dialect for DB2.
            </summary>
            <remarks>
            The DB2Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.DB2Driver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Dialect">
            <summary>
            Represents a dialect of SQL implemented by a particular RDBMS. Sublcasses
            implement NHibernate compatibility with different systems.
            </summary>
            <remarks>
            Subclasses should provide a public default constructor that <c>Register()</c>
            a set of type mappings and default Hibernate properties.
            </remarks>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.DefaultBatchSize">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.NoBatch">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.PossibleQuoteChars">
            <summary>
            Characters used for quoting sql identifiers
            </summary>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.PossibleClosedQuoteChars">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.#ctor">
            <summary>
            The base constructor for Dialect.
            </summary>
            <remarks>
            Every subclass should override this and call Register() with every <see cref="T:System.Data.DbType"/> except
            <see cref="F:System.Data.DbType.Object"/>, <see cref="F:System.Data.DbType.SByte"/>, <see cref="F:System.Data.DbType.UInt16"/>, <see cref="F:System.Data.DbType.UInt32"/>, 
            <see cref="F:System.Data.DbType.UInt64"/>, <see cref="F:System.Data.DbType.VarNumeric"/>.
            
            <para>
            The Default properties for this Dialect should also be set - such as whether or not to use outer-joins
            and what the batch size should be.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetTypeName(NHibernate.SqlTypes.SqlType)">
            <summary>
            Get the name of the database type associated with the given 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>,
            </summary>
            <param name="sqlType">The SqlType</param>
            <returns>The database type name used by ddl.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetTypeName(NHibernate.SqlTypes.SqlType,System.Int32)">
            <summary>
            Get the name of the database type associated with the given
            <see cref="T:NHibernate.SqlTypes.SqlType"/>.
            </summary>
            <param name="sqlType">The SqlType </param>
            <param name="length">The length of the SqlType</param>
            <returns>The database type name used by ddl.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterFunction(System.String,NHibernate.Dialect.Function.ISQLFunction)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="function"></param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterColumnType(System.Data.DbType,System.Int32,System.String)">
            <summary>
            Subclasses register a typename for the given type code and maximum
            column length. <c>$1</c> in the type name will be replaced by the column
            length (if appropriate)
            </summary>
            <param name="code">The typecode</param>
            <param name="capacity">Maximum length of database type</param>
            <param name="name">The database type name</param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterColumnType(System.Data.DbType,System.String)">
            <summary>
            Suclasses register a typename for the given type code. <c>$1</c> in the 
            typename will be replaced by the column length (if appropriate).
            </summary>
            <param name="code">The typecode</param>
            <param name="name">The database type name</param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetAddForeignKeyConstraintString(System.String,System.String[],System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="constraintName"></param>
            <param name="foreignKey"></param>
            <param name="referencedTable"></param>
            <param name="primaryKey"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropForeignKeyConstraintString(System.String)">
            <summary>
            The syntax used to drop a foreign key constraint from a table.
            </summary>
            <param name="constraintName">The name of the foreign key constraint to drop.</param>
            <returns>
            The SQL string to drop the foreign key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetAddPrimaryKeyConstraintString(System.String)">
            <summary>
            The syntax used to add a primary key constraint to a table
            </summary>
            <param name="constraintName"></param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropPrimaryKeyConstraintString(System.String)">
            <summary>
            The syntax used to drop a primary key constraint from a table.
            </summary>
            <param name="constraintName">The name of the primary key constraint to drop.</param>
            <returns>
            The SQL string to drop the primary key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropIndexConstraintString(System.String)">
            <summary>
            The syntax used to drop an index constraint from a table.
            </summary>
            <param name="constraintName">The name of the index constraint to drop.</param>
            <returns>
            The SQL string to drop the primary key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.AddIdentitySelectToInsert(NHibernate.SqlCommand.SqlString,System.String,System.String)">
            <summary>
            Generate SQL to get the identifier of an inserted row.
            If the returned value is not null, the caller will prepare a statement from it,
            set SQL parameters just as it would for insertSQL, and execute it as a query
            which is expected to return the identifier of the inserted row.
            If the returned value is null, the caller will execute insertSQL as an update
            and then execute IdentitySelectString as a query.
            The default implementation (in this class) returns <see langword="null" />.
            </summary>
            <param name="insertSql">a parameterized SQL statement to insert a row into a table.</param>
            <param name="identityColumn">The column for which the identity generator was specified.</param>
            <param name="tableName">The name of the table the row is being inserted in.</param>
            <returns>a SQL statement that has the same effect as insertSQL
            and also gets the identifier of the inserted row.
            Return <see langword="null" /> if this dialect doesn't support this feature.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetIdentitySelectString(System.String,System.String)">
            <summary>
            The syntax that returns the identity value of the last insert, if native
            key generation is supported
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetSequenceNextValString(System.String)">
            <summary>
            The syntax that fetches the next value of a sequence, if sequences are supported.
            </summary>
            <param name="sequenceName">The name of the sequence</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String)">
            <summary>
            The syntax used to create a sequence, if sequences are supported
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropSequenceString(System.String)">
            <summary>
            The syntax used to drop a sequence, if sequences are supported
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDialect">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDialect(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="props"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.CreateOuterJoinFragment">
            <summary>
            Create an <c>JoinFragment</c> for this dialect
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.CreateCaseFragment">
            <summary>
            Create an <c>CaseFragment</c> for this dialect
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="hasOffset">Offset of the first row is not zero</param>
            <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
            <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="offset">Offset of the first row to be returned by the query (zero-based)</param>
            <param name="limit">Maximum number of rows to be returned by the query</param>
            <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropTableString(System.String)">
            <summary>
            Return SQL needed to drop the named table. May (and should) use
            some form of "if exists" clause, and cascade constraints.
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.IsQuoted(System.String)">
            <summary>
            Checks to see if the name has been quoted.
            </summary>
            <param name="name">The name to check if it is quoted</param>
            <returns>true if name is already quoted.</returns>
            <remarks>
            The default implementation is to compare the first character
            to Dialect.OpenQuote and the last char to Dialect.CloseQuote
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.UnQuote(System.String)">
            <summary>
            Unquotes and unescapes an already quoted name
            </summary>
            <param name="quoted">Quoted string</param>
            <returns>Unquoted string</returns>
            <remarks>
            <p>
            This method checks the string <c>quoted</c> to see if it is 
            quoted.  If the string <c>quoted</c> is already enclosed in the OpenQuote
            and CloseQuote then those chars are removed.
            </p>
            <p>
            After the OpenQuote and CloseQuote have been cleaned from the string <c>quoted</c>
            then any chars in the string <c>quoted</c> that have been escaped by doubling them
            up are changed back to a single version.
            </p>
            <p>
            The following quoted values return these results
            "quoted" = quoted
            "quote""d" = quote"d
            quote""d = quote"d 
            </p>
            <p>
            If this implementation is not sufficient for your Dialect then it needs to be overridden.
            MsSql2000Dialect is an example of where UnQuoting rules are different.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.UnQuote(System.String[])">
            <summary>
            Unquotes an array of Quoted Names.
            </summary>
            <param name="quoted">strings to Unquote</param>
            <returns>an array of unquoted strings.</returns>
            <remarks>
            This use UnQuote(string) for each string in the quoted array so
            it should not need to be overridden - only UnQuote(string) needs
            to be overridden unless this implementation is not sufficient.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.Quote(System.String)">
            <summary>
            Quotes a name.
            </summary>
            <param name="name">The string that needs to be Quoted.</param>
            <returns>A QuotedName </returns>
            <remarks>
            <p>
            This method assumes that the name is not already Quoted.  So if the name passed
            in is <c>"name</c> then it will return <c>"""name"</c>.  It escapes the first char
            - the " with "" and encloses the escaped string with OpenQuote and CloseQuote. 
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForAliasName(System.String)">
            <summary>
            Quotes a name for being used as a aliasname
            </summary>
            <remarks>Original implementation calls <see cref="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)"/></remarks>
            <param name="aliasName">Name of the alias</param>
            <returns>A Quoted name in the format of OpenQuote + aliasName + CloseQuote</returns>
            <remarks>
            <p>
            If the aliasName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the aliasName that was passed in without going through any
            Quoting process.  So if aliasName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForColumnName(System.String)">
            <summary>
            Quotes a name for being used as a columnname
            </summary>
            <remarks>Original implementation calls <see cref="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)"/></remarks>
            <param name="columnName">Name of the column</param>
            <returns>A Quoted name in the format of OpenQuote + columnName + CloseQuote</returns>
            <remarks>
            <p>
            If the columnName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the columnName that was passed in without going through any
            Quoting process.  So if columnName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)">
            <summary>
            Quotes a name for being used as a tablename
            </summary>
            <param name="tableName">Name of the table</param>
            <returns>A Quoted name in the format of OpenQuote + tableName + CloseQuote</returns>
            <remarks>
            <p>
            If the tableName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the tableName that was passed in without going through any
            Quoting process.  So if tableName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForSchemaName(System.String)">
            <summary>
            Quotes a name for being used as a schemaname
            </summary>
            <param name="schemaName">Name of the schema</param>
            <returns>A Quoted name in the format of OpenQuote + schemaName + CloseQuote</returns>
            <remarks>
            <p>
            If the schemaName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the schemaName that was passed in without going through any
            Quoting process.  So if schemaName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.HasAlterTable">
            <summary>
            Does this dialect support the <c>ALTER TABLE</c> syntax?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DropConstraints">
            <summary>
            Do we need to drop constraints before dropping tables in the dialect?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.QualifyIndexName">
            <summary>
            Do we need to qualify index names with the schema name?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.MultipleQueriesSeparator">
            <summary>
            How we seperate the queries when we use multiply queries.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.ForUpdateString">
            <summary>
            Retrieves the <c>FOR UPDATE</c> syntax specific to this dialect
            </summary>
            <value>The appropriate <c>FOR UPDATE</c> clause string.</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.ForUpdateNowaitString">
            <summary>
            Retrieves the <c>FOR UPDATE NOWAIT</c> syntax specific to this dialect
            </summary>
            <value>The appropriate <c>FOR UPDATE NOWAIT</c> clause string.</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSubSelects">
            <summary>
            Does this dialect support subselects?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsUnique">
            <summary>
            Does this dialect support the <c>UNIQUE</c> column syntax?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.AddColumnString">
            <summary>
            The syntax used to add a column to a table. Note this is deprecated
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.NullColumnString">
            <summary>
            The keyword used to specify a nullable column
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIdentityColumns">
            <summary>
            Does this dialect support identity column key generation?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSequences">
            <summary>
            Does this dialect support sequences?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentityColumnString">
            <summary>
            The keyword used to specify an identity column, if native key generation is supported
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentityInsertString">
            <summary>
            The keyword used to insert a generated value into an identity column (or null)
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.NoColumnsInsertString">
            <summary>
            The keyword used to insert a row without specifying any column values
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DefaultProperties">
            <summary>
            Retrieve a set of default Hibernate properties for this database.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CascadeConstraintsString">
            <summary>
            Completely optional cascading drop clause
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.LowercaseFunction">
            <summary>
            The name of the SQL function that transforms a string to lowercase
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>False, unless overridden.</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsVariableLimit">
            <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.BindLimitParametersInReverseOrder">
            <summary>
            Does the <c>LIMIT</c> clause specify arguments in the "reverse" order
            limit, offset instead of offset, limit?
            </summary>
            <value>False, unless overridden.</value>
            <remarks>Inheritors should return true if the correct order is limit, offset</remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.BindLimitParametersFirst">
            <summary>
            Does the <c>LIMIT</c> clause come at the start of the 
            <c>SELECT</c> statement rather than at the end?
            </summary>
            <value>false, unless overridden</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.UseMaxForLimit">
            <summary>
            Does the <c>LIMIT</c> clause take a "maximum" row number
            instead of a total number of returned rows?
            </summary>
            <returns>false, unless overridden</returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.OpenQuote">
            <summary>
            The opening quote for a quoted identifier.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CloseQuote">
            <summary>
            The closing quote for a quoted identifier.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.HasDataTypeInIdentityColumn">
            <summary>
            Whether this dialect has an identity clause added to the data type or a
            completely seperate identity data type.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.Functions">
            <summary>
            Aggregate SQL functions as defined in general. This is
            a case-insensitive hashtable!
            </summary>
            <remarks>
            The results of this method should be integrated with the 
            specialization's data.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIfExistsBeforeTableName">
            <summary>
            Does the dialect support the syntax 'drop table if exists NAME'
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIfExistsAfterTableName">
            <summary>
            Does the dialect support the syntax 'drop table NAME if exists'
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.TimestampResolutionInTicks">
            <summary>
            Gives the best resolution that the database can use for storing
            date/time values, in ticks.
            </summary>
            <remarks>
            <para>
            For example, if the database can store values with 100-nanosecond
            precision, this property is equal to 1L. If the database can only
            store values with 1-millisecond precision, this property is equal
            to 10000L (number of ticks in a millisecond).
            </para>
            <para>
            Used in TimestampType.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetIdentitySelectString(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetSequenceNextValString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetCreateSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetDropSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="hasOffset">Offset of the first row is not zero</param>
            <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.DropConstraints">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.IdentityInsertString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsSequences">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.BindLimitParametersInReverseOrder">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.UseMaxForLimit">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.FirebirdDialect">
            <summary>
            Summary description for FirebirdDialect.
            </summary>
            <remarks>
            The FirebirdDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.FirebirdDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.FirebirdDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
            <summary>
            Add a <c>FIRST x [SKIP] y</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="limit">Maximum number of rows to be returned by the query</param>
            <param name="offset">Offset of the first row to process in the result set</param>
            <returns>A new SqlString that contains the <c>FIRST</c> clause.</returns>
        </member>
        <member name="P:NHibernate.Dialect.FirebirdDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.GenericDialect">
            <summary>
            A generic SQL dialect which may or may not work on any actual databases
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.GenericDialect.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.GenericDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.InformixDialect">
            <summary>
            Summary description for InformixDialect.
            </summary>
            <remarks>
            The InformixDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.OdbcDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.GetIdentitySelectString(System.String,System.String)">
            <summary>
            The syntax that returns the identity value of the last insert, if native
            key generation is supported
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.IdentityColumnString">
            <summary>
            The keyword used to specify an identity column, if native key generation is supported
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.HasDataTypeInIdentityColumn">
            <summary>
            Whether this dialect have an Identity clause added to the data type or a
            completely seperate identity data type
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.IngresDialect">
            <summary>
            An SQL dialect for IngresSQL.
            </summary>
            <remarks>
            The IngresDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><see langword="true"/></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.IngresDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.MsSql2000Dialect">
            <summary>
            An SQL dialect compatible with Microsoft SQL Server 2000.
            </summary>
            <remarks>
            The MsSql2000Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><see langword="true"/></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.SqlClientDriver"/></description>
            	</item>
            	<item>
            		<term>hibernate.prepare_sql</term>
            		<description><see langword="false"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.GetDropTableString(System.String)">
            <summary>
            Generates the string to drop the table using SQL Server syntax.
            </summary>
            <param name="tableName">The name of the table to drop.</param>
            <returns>The SQL with the <paramref name="tableName" /> inserted.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.GetIdentitySelectString(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
            <summary>
            Add a <c>LIMIT (TOP)</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="limit">Maximum number of rows to be returned by the query</param>
            <param name="offset">Offset of the first row to process in the result set</param>
            <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.Quote(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
            <remarks>
            MsSql does not require the OpenQuote to be escaped as long as the first char
            is an OpenQuote.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.UnQuote(System.String)">
            <summary>
            
            </summary>
            <param name="quoted"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.NullColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.QualifyIndexName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.NoColumnsInsertString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.CloseQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.OpenQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>True, we'll use the SELECT TOP nn syntax.</value>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsVariableLimit">
            <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.UseMaxForLimit">
            <summary>
            Does the <c>LIMIT</c> clause take a "maximum" row number
            instead of a total number of returned rows?
            </summary>
            <returns>false, unless overridden</returns>
        </member>
        <member name="T:NHibernate.Dialect.MsSql2005Dialect">
            <summary>
            A <see cref="T:NHibernate.Dialect.Dialect"/> for <c>Microsoft Sql Server 2005</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2005Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
            <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to base the limit query off of.</param>
            <param name="offset">Offset of the first row to be returned by the query (zero-based)</param>
            <param name="last">Maximum number of rows to be returned by the query</param>
            <returns>A new <see cref="T:NHibernate.SqlCommand.SqlString"/> with the <c>LIMIT</c> clause applied.</returns>
            <remarks>
            The <c>LIMIT</c> SQL will look like
            <code>
            WITH query AS
                (SELECT TOP last ROW_NUMBER() OVER (ORDER BY orderby) as __hibernate_row_nr__, ... original_query)
             SELECT * 
               FROM query
               WHERE __hibernate_row_nr__ &gt; offset
               ORDER BY __hibernate_row_nr__
            </code>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2005Dialect.SupportsLimit">
            <summary>
            Sql Server 2005 supports a query statement that provides <c>LIMIT</c>
            functionallity.
            </summary>
            <value><see langword="true" /></value>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2005Dialect.SupportsLimitOffset">
            <summary>
            Sql Server 2005 supports a query statement that provides <c>LIMIT</c>
            functionallity with an offset.
            </summary>
            <value><see langword="true" /></value>
        </member>
        <member name="T:NHibernate.Dialect.MsSql7Dialect">
            <summary>
            An SQL dialect compatible with Microsoft SQL Server 7.
            </summary>
            <remarks>
            There have been no test run with this because the NHibernate team does not
            have a machine with Sql 7 installed on it.  But there have been users using
            Ms Sql 7 with NHibernate.  As issues with Ms Sql 7 and NHibernate become known
            this Dialect will be updated.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MsSql7Dialect.GetIdentitySelectString(System.String,System.String)">
            <summary>
            Uses @@identity to get the Id value.
            </summary>
            <remarks>
            There is a well known problem with @@identity and triggers that insert into
            rows into other tables that also use an identity column.  The only way I know
            of to get around this problem is to upgrade your database server to Ms Sql 2000.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.MsSqlCeDialect">
            <summary>
            A dialect for SQL Server Everywhere (SQL Server CE).
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.MySQLDialect">
            <summary>
            A SQL dialect for MySQL
            </summary>
            <remarks>
            The MySQLDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><see langword="true"/></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.MySqlDataDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetIdentitySelectString(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            
            </summary>
            <param name="querySqlString"></param>
            <param name="hasOffset"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetAddForeignKeyConstraintString(System.String,System.String[],System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="constraintName"></param>
            <param name="foreignKey"></param>
            <param name="referencedTable"></param>
            <param name="primaryKey"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropForeignKeyConstraintString(System.String)">
            <summary>
            Create the SQL string to drop a foreign key constraint.
            </summary>
            <param name="constraintName">The name of the foreign key to drop.</param>
            <returns>The SQL string to drop the foreign key constraint.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropPrimaryKeyConstraintString(System.String)">
            <summary>
            Create the SQL string to drop a primary key constraint.
            </summary>
            <param name="constraintName">The name of the primary key to drop.</param>
            <returns>The SQL string to drop the primary key constraint.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropIndexConstraintString(System.String)">
            <summary>
            Create the SQL string to drop an index.
            </summary>
            <param name="constraintName">The name of the index to drop.</param>
            <returns>The SQL string to drop the index constraint.</returns>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.QualifyIndexName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.CloseQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.OpenQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.Oracle9Dialect">
            <summary>
            It's a immature version, it just work.
            An SQL dialect for Oracle 9
            </summary>
            <remarks>
            The Oracle9Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><see langword="true"/></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.OracleClientDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.GetSequenceNextValString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.GetCreateSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.GetDropSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.CascadeConstraintsString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.SupportsSequences">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.BindLimitParametersInReverseOrder">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.UseMaxForLimit">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.OracleDialect">
            <summary>
            An SQL dialect for Oracle, compatible with Oracle 8.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.OracleDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.OracleDialect.CreateOuterJoinFragment">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.OracleDialect.CreateCaseFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.PostgreSQL81Dialect">
            <summary>
            An SQL dialect for PostgreSQL 8.1 and above.
            </summary>
            <remarks>
            <para>
            PostgreSQL 8.1 supports <c>FOR UPDATE ... NOWAIT</c> syntax.
            </para>
            <para>
            PostgreSQL supports Identity column using the "SERIAL" type.
            Serial type is a "virtual" type that will automatically:
            </para>
            <list type="bullet">
            <item><description>Create a sequence named tablename_colname_seq.</description></item>
            <item><description>Set the default value of this column to the next value of the 
            sequence. (using function <c>nextval('tablename_colname_seq')</c>)</description></item>
            <item><description>Add a "NOT NULL" constraint to this column.</description></item>
            <item><description>Set the sequence as "owned by" the table.</description></item>
            </list>
            <para>
            To insert the next value of the sequence into the serial column,
            exclude the column from the list of columns 
            in the INSERT statement or use the DEFAULT key word.
            </para>
            <para>
            If the table or the column is dropped, the sequence is dropped too.
            </para>
            </remarks>
            <seealso cref="T:NHibernate.Dialect.PostgreSQLDialect"/>
        </member>
        <member name="T:NHibernate.Dialect.PostgreSQLDialect">
            <summary>
            An SQL dialect for PostgreSQL.
            </summary>
            <remarks>
            The PostgreSQLDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><see langword="true"/></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.NpgsqlDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQLDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQLDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            
            </summary>
            <param name="querySqlString"></param>
            <param name="hasOffset">Offset of the first row to process in the result set is non-zero</param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.DropConstraints">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQL81Dialect.GetIdentitySelectString(System.String,System.String)">
            <summary>
            PostgreSQL 8.1 and above defined the fuction <c>lastval()</c> that returns the
            value of the last sequence that <c>nextval()</c> was used on in the current session.
            Call <c>lastval()</c> if <c>nextval()</c> has not yet been called in the current
            session throw an exception.
            </summary>
            <param name="identityColumn">not used</param>
            <param name="tableName">not used</param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.SupportsIdentityColumns">
            <summary>
            PostgreSQL supports Identity column using the "SERIAL" type.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.HasDataTypeInIdentityColumn">
            <summary>
            PostgreSQL doesn't have type in identity column.
            </summary>
            <remarks>
            To create an identity column it uses the SQL syntax
            <c>CREATE TABLE tablename (colname SERIAL);</c> or 
            <c>CREATE TABLE tablename (colname BIGSERIAL);</c>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.IdentityColumnString">
            <summary>
            PostgreSQL supports <c>serial</c> and <c>serial4</c> type for 4 bytes integer auto increment column.
            <c>bigserial</c> or <c>serial8</c> can be used for 8 bytes integer auto increment column.
            This dialect uses <c>serial</c>
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.NoColumnsInsertString">
            <summary>
            The sql syntax to insert a row without specifying any column in PostgreSQL is
            <c>INSERT INTO table DEFAULT VALUES;</c>
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.PostgreSQL82Dialect">
            <summary>
            An SQL dialect for PostgreSQL 8.2 and above.
            </summary>
            <remarks>
            PostgreSQL 8.2 supports <c>DROP TABLE IF EXISTS tablename</c>
            and <c>DROP SEQUENCE IF EXISTS sequencename</c> syntax.
            See <see cref="T:NHibernate.Dialect.PostgreSQLDialect"/> for more information.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.SQLiteDialect">
            <summary>
            A SQL dialect for SQLite.
            </summary>
            <remarks>
            <p>
            Author: <a href="mailto:ib@stalker.ro"> Ioan Bizau </a>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.SQLiteDialect.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.SQLiteDialect.GetIdentitySelectString(System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.SybaseAnywhereDialect">
            <summary>
            An SQL dialect for Sybase Adaptive Server Anywhere 9.0
            </summary>
            <remarks>
            <p>
            This dialect probably will not work with schema-export.  If anyone out there
            can fill in the ctor with DbTypes to Strings that would be helpful.
            </p>
            The SybaseAnywhereDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><see langword="true"/></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.SybaseClientDriver"/></description>
            	</item>
            	<item>
            		<term>hibernate.prepare_sql</term>
            		<description><see langword="false"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.SybaseAnywhereDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.SybaseAnywhereDialect.GetIdentitySelectString(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseAnywhereDialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseAnywhereDialect.NoColumnsInsertString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseAnywhereDialect.DropConstraints">
            <summary>
            ASA does not require to drop constraint before dropping tables, and DROP statement
            syntax used by Hibernate to drop constraint is not compatible with ASA, so disable it.  
            Comments matchs SybaseAnywhereDialect from Hibernate-3.1 src
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.SybaseDialect">
            <summary>
            An SQL dialect compatible with Sybase.
            </summary>
            <remarks>
            <p>
            This dialect probably will not work with schema-export.  If anyone out there
            can fill in the ctor with DbTypes to Strings that would be helpful.
            </p>
            The SybaseDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><see langword="true"/></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.SybaseClientDriver"/></description>
            	</item>
            	<item>
            		<term>hibernate.prepare_sql</term>
            		<description><see langword="false"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.SybaseDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.SybaseDialect.GetIdentitySelectString(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.SybaseDialect.QuoteForAliasName(System.String)">
            <remarks>
            Sybase does not support quoted aliases, this function thus returns
            <c>aliasName</c> as is.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.NullColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.QualifyIndexName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.ForUpdateString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.NoColumnsInsertString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.TypeNames">
            <summary>
            This class maps a DbType to names.
            </summary>
            <remarks>
            Associations may be marked with a capacity. Calling the <c>Get()</c>
            method with a type and actual size n will return the associated
            name with smallest capacity >= n, if available and an unmarked
            default type otherwise.
            Eg, setting
            <code>
            	Names.Put(DbType,			"TEXT" );
            	Names.Put(DbType,	255,	"VARCHAR($1)" );
            	Names.Put(DbType,	65534,	"LONGVARCHAR($1)" );
            </code>
            will give you back the following:
            <code>
            	Names.Get(DbType)			// --> "TEXT" (default)
            	Names.Get(DbType,100)		// --> "VARCHAR(100)" (100 is in [0:255])
            	Names.Get(DbType,1000)	// --> "LONGVARCHAR(1000)" (100 is in [256:65534])
            	Names.Get(DbType,100000)	// --> "TEXT" (default)
            </code>
            On the other hand, simply putting
            <code>
            	Names.Put(DbType, "VARCHAR($1)" );
            </code>
            would result in
            <code>
            	Names.Get(DbType)			// --> "VARCHAR($1)" (will cause trouble)
            	Names.Get(DbType,100)		// --> "VARCHAR(100)" 
            	Names.Get(DbType,1000)	// --> "VARCHAR(1000)"
            	Names.Get(DbType,10000)	// --> "VARCHAR(10000)"
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="placeholder">String to be replaced by actual size/length in type names</param>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Get(System.Data.DbType)">
            <summary>
            Get default type name for specified type
            </summary>
            <param name="typecode">the type key</param>
            <returns>the default type name associated with the specified key</returns>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Get(System.Data.DbType,System.Int32)">
            <summary>
            Get the type name specified type and size
            </summary>
            <param name="typecode">the type key</param>
            <param name="size">the (maximum) type size/length</param>
            <returns>
            The associated name with smallest capacity >= size if available and the
            default type name otherwise
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Put(System.Data.DbType,System.Int32,System.String)">
            <summary>
            Set a type name for specified type key and capacity
            </summary>
            <param name="typecode">the type key</param>
            <param name="capacity">the (maximum) type size/length</param>
            <param name="value">The associated name</param>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Put(System.Data.DbType,System.String)">
            <summary>
            
            </summary>
            <param name="typecode"></param>
            <param name="value"></param>
        </member>
        <member name="T:NHibernate.Driver.ASAClientDriver">
            <summary>
            The ASAClientDriver Driver provides a database driver for Adaptive Server Anywhere 9.0.
            </summary>
        </member>
        <member name="T:NHibernate.Driver.DriverBase">
            <summary>
            Base class for the implementation of IDriver
            </summary>
        </member>
        <member name="T:NHibernate.Driver.IDriver">
            <summary>
            A strategy for describing how NHibernate should interact with the different .NET Data
            Providers.
            </summary>
            <remarks>
            <para>
            The <c>IDriver</c> interface is not intended to be exposed to the application.
            Instead it is used internally by NHibernate to obtain connection objects, command objects, and
            to generate and prepare <see cref="T:System.Data.IDbCommand">IDbCommands</see>. Implementors should provide a
            public default constructor.
            </para>
            <para>
            This is the interface to implement, or you can inherit from <see cref="T:NHibernate.Driver.DriverBase"/> 
            if you have an ADO.NET data provider that NHibernate does not have built in support for.
            To use the driver, NHibernate property <c>hibernate.connection.driver_class</c> should be
            set to the assembly-qualified name of the driver class.
            </para>
            <code>
            key="hibernate.connection.driver_class"
            value="FullyQualifiedClassName, AssemblyName"
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.IDriver.Configure(System.Collections.IDictionary)">
            <summary>
            Configure the driver using <paramref name="settings"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.IDriver.CreateConnection">
            <summary>
            Creates an uninitialized IDbConnection object for the specific Driver
            </summary>
        </member>
        <member name="M:NHibernate.Driver.IDriver.GenerateCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
            <summary>
            Generates an IDbCommand from the SqlString according to the requirements of the DataProvider.
            </summary>
            <param name="type">The <see cref="T:System.Data.CommandType"/> of the command to generate.</param>
            <param name="sqlString">The SqlString that contains the SQL.</param>
            <param name="parameterTypes">The types of the parameters to generate for the command.</param>
            <returns>An IDbCommand with the CommandText and Parameters fully set.</returns>
        </member>
        <member name="M:NHibernate.Driver.IDriver.PrepareCommand(System.Data.IDbCommand)">
            <summary>
            Prepare the <paramref name="command"/> by calling <see cref="M:System.Data.IDbCommand.Prepare"/>.
            May be a no-op if the driver does not support preparing commands, or for any other reason.
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:NHibernate.Driver.IDriver.CreateBatcher(NHibernate.Impl.ConnectionManager)">
            <summary>
            Create an instance of <see cref="T:NHibernate.Engine.IBatcher"/> according to the configuration 
            and the capabilities of the driver
            </summary>
            <param name="connectionManager">The connection manager for the batcher.</param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.IDriver.SupportsMultipleOpenReaders">
            <summary>
            Does this Driver support having more than 1 open IDataReader with
            the same IDbConnection.
            </summary>
            <remarks>
            <para>
            A value of <see langword="false"/> indicates that an exception would be thrown if NHibernate
            attempted to have 2 IDataReaders open using the same IDbConnection.  NHibernate
            (since this version is a close to straight port of Hibernate) relies on the 
            ability to recursively open 2 IDataReaders.  If the Driver does not support it
            then NHibernate will read the values from the IDataReader into an <see cref="T:NHibernate.Driver.NDataReader"/>.
            </para>
            <para>
            A value of <see langword="true"/> will result in greater performance because an IDataReader can be used
            instead of the <see cref="T:NHibernate.Driver.NDataReader"/>.  So if the Driver supports it then make sure
            it is set to <see langword="true"/>.
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.IDriver.SupportsMultipleQueries">
            <summary>
            Can we issue several select queries in a single query, and get
            several result sets back?
            </summary>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.FormatNameForSql(System.String)">
            <summary>
            Change the parameterName into the correct format IDbCommand.CommandText
            for the ConnectionProvider
            </summary>
            <param name="parameterName">The unformatted name of the parameter</param>
            <returns>A parameter formatted for an IDbCommand.CommandText</returns>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.FormatNameForParameter(System.String)">
            <summary>
            Changes the parameterName into the correct format for an IDbParameter
            for the Driver.
            </summary>
            <remarks>
            For SqlServerConnectionProvider it will change <c>id</c> to <c>@id</c>
            </remarks>
            <param name="parameterName">The unformatted name of the parameter</param>
            <returns>A parameter formatted for an IDbParameter.</returns>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.CreateBatcher(NHibernate.Impl.ConnectionManager)">
            <summary>
            Create an instance of <see cref="T:NHibernate.Engine.IBatcher"/> according to the configuration 
            and the capabilities of the driver
            </summary>
            <remarks>
            By default, .Net doesn't have any batching capabilities, drivers that does have
            batching support need to override this method and return their own batcher.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.GenerateParameter(System.Data.IDbCommand,System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Generates an IDbDataParameter for the IDbCommand.  It does not add the IDbDataParameter to the IDbCommand's
            Parameter collection.
            </summary>
            <param name="command">The IDbCommand to use to create the IDbDataParameter.</param>
            <param name="name">The name to set for IDbDataParameter.Name</param>
            <param name="sqlType">The SqlType to set for IDbDataParameter.</param>
            <returns>An IDbDataParameter ready to be added to an IDbCommand.</returns>
        </member>
        <member name="P:NHibernate.Driver.DriverBase.UseNamedPrefixInSql">
            <summary>
            Does this Driver require the use of a Named Prefix in the SQL statement.  
            </summary>
            <remarks>
            For example, SqlClient requires <c>select * from simple where simple_id = @simple_id</c>
            If this is false, like with the OleDb provider, then it is assumed that  
            the <c>?</c> can be a placeholder for the parameter in the SQL statement.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.DriverBase.UseNamedPrefixInParameter">
            <summary>
            Does this Driver require the use of the Named Prefix when trying
            to reference the Parameter in the Command's Parameter collection.  
            </summary>
            <remarks>
            This is really only useful when the UseNamedPrefixInSql == true.  When this is true the
            code will look like:
            <code>IDbParameter param = cmd.Parameters["@paramName"]</code>
            if this is false the code will be 
            <code>IDbParameter param = cmd.Parameters["paramName"]</code>.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.DriverBase.NamedPrefix">
            <summary>
            The Named Prefix for parameters.  
            </summary>
            <remarks>
            Sql Server uses <c>"@"</c> and Oracle uses <c>":"</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.DriverBase.SupportsPreparingCommands">
            <summary>
            Does this Driver support IDbCommand.Prepare().
            </summary>
            <remarks>
            <para>
            A value of <see langword="false" /> indicates that an exception would be thrown or the 
            company that produces the Driver we are wrapping does not recommend using
            IDbCommand.Prepare().
            </para>
            <para>
            A value of <see langword="true" /> indicates that calling IDbCommand.Prepare() will function
            fine on this Driver.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.ReflectionBasedDriver.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.ReflectionBasedDriver"/> with
            type names that are loaded from the specified assembly.
            </summary>
            <param name="driverAssemblyName">Assembly to load the types from.</param>
            <param name="connectionTypeName">Connection type name.</param>
            <param name="commandTypeName">Command type name.</param>
        </member>
        <member name="M:NHibernate.Driver.ASAClientDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.ASAClientDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the ASA.Data.AseClient assembly is not and can not be loaded.
            </exception>
        </member>
        <member name="P:NHibernate.Driver.ASAClientDriver.UseNamedPrefixInSql">
            <summary>
            iAnywhere.Data.AsaClient uses named parameters in the sql.
            </summary>
            <value><see langword="true" /> - Sybase uses <c>String.Empty</c> in the sql.</value>
        </member>
        <member name="P:NHibernate.Driver.ASAClientDriver.NamedPrefix">
            <summary>
            iAnywhere.Data.AsaClient use the <c>string.Empty</c> to locate parameters in sql.
            </summary>
        </member>
        <member name="T:NHibernate.Driver.DB2400Driver">
            <summary>
            A NHibernate Driver for using the IBM.Data.DB2.iSeries DataProvider.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.DB2400Driver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.DB2Driver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.DB2.iSeries</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.DB2Driver">
            <summary>
            A NHibernate Driver for using the IBM.Data.DB2 DataProvider.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.DB2Driver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.DB2Driver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.DB2</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.FirebirdClientDriver">
            <summary>
            A NHibernate Driver for using the Firebird data provider located in
            <c>FirebirdSql.Data.FirebirdClient</c> assembly.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.FirebirdClientDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.FirebirdDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>FirebirdSql.Data.Firebird</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.FirebirdDriver">
            <summary>
            A NHibernate Driver for using the FirebirdSql.Data.Firebird DataProvider.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.FirebirdDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.FirebirdDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>FirebirdSql.Data.Firebird</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.IngresDriver">
            <summary>
            A NHibernate Driver for using the Ingres DataProvider
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.IngresDriver.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.IngresDriver.UseNamedPrefixInSql">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.IngresDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.IngresDriver.NamedPrefix">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.MySqlDataDriver">
            <summary>
            Provides a database driver for MySQL.
            </summary>
            <remarks>
            <para>
            In order to use this driver you must have the assembly <c>MySql.Data.dll</c> available for 
            NHibernate to load, including its dependencies (<c>ICSharpCode.SharpZipLib.dll</c> is required by
            the assembly <c>MySql.Data.dll</c> as of the time of this writing).
            </para>
            <para>
            Please check the product's <see href="http://www.mysql.com/products/connector/net/">website</see>
            for any updates and/or documentation regarding MySQL.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.MySqlDataDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.MySqlDataDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>MySql.Data</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.UseNamedPrefixInSql">
            <summary>
            MySql.Data uses named parameters in the sql.
            </summary>
            <value><see langword="true" /> - MySql uses <c>?</c> in the sql.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.NamedPrefix">
            <summary>
            MySql.Data use the <c>?</c> to locate parameters in sql.
            </summary>
            <value><c>?</c> is used to locate parameters in sql.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.SupportsMultipleOpenReaders">
            <summary>
            The MySql.Data driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
            <value><see langword="false" /> - it is not supported.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.SupportsPreparingCommands">
            <summary>
            MySql.Data does not support preparing of commands.
            </summary>
            <value><see langword="false" /> - it is not supported.</value>
            <remarks>
            With the Gamma MySql.Data provider it is throwing an exception with the 
            message "Expected End of data packet" when a select command is prepared.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.NDataReader">
            <summary>
            Some Data Providers (ie - SqlClient) do not support Multiple Active Result Sets (MARS).
            NHibernate relies on being able to create MARS to read Components and entities inside
            of Collections.
            </summary>
            <remarks>
            This is a completely off-line DataReader - the underlying IDataReader that was used to create
            this has been closed and no connections to the Db exists.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Creates a NDataReader from a <see cref="T:System.Data.IDataReader"/>
            </summary>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to get the records from the Database.</param>
            <param name="isMidstream"><see langword="true"/> if we are loading the <see cref="T:System.Data.IDataReader"/> in the middle of reading it.</param>
            <remarks>
            NHibernate attempts to not have to read the contents of an <see cref="T:System.Data.IDataReader"/> into memory until it absolutely
            has to.  What that means is that it might have processed some records from the <see cref="T:System.Data.IDataReader"/> and will
            pick up the <see cref="T:System.Data.IDataReader"/> midstream so that the underlying <see cref="T:System.Data.IDataReader"/> can be closed 
            so a new one can be opened.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.ClearCache">
            <summary>
            Sets the values that can be cached back to null and sets the 
            index of the cached column to -1
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NextResult">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Close">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Read">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <remarks>
            There are not any unmanaged resources or any disposable managed 
            resources that this class is holding onto.  It is in here
            to comply with the <see cref="T:System.Data.IDataReader"/> interface.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt32(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetValue(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.IsDBNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferOffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetByte(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDecimal(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetValues(System.Object[])">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt64(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDouble(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetBoolean(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetGuid(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDateTime(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetFloat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetData(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferOffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetString(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetChar(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt16(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.RecordsAffected">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.IsClosed">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Depth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Item(System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Item(System.Int32)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.FieldCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NDataReader.NResult">
            <summary>
            Stores a Result from a DataReader in memory.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Initializes a new instance of the NResult class.
            </summary>
            <param name="reader">The IDataReader to populate the Result with.</param>
            <param name="isMidstream">
            <see langword="true"/> if the <see cref="T:System.Data.IDataReader"/> is already positioned on the record
            to start reading from.
            </param>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetFieldCount">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="colName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValue(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValue(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="colName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValues(System.Int32,System.Object[])">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.NResult.RowCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NHybridDataReader">
            <summary>
            An implementation of <see cref="T:System.Data.IDataReader"/> that will work with either an 
            <see cref="T:System.Data.IDataReader"/> returned by Execute or with an <see cref="T:System.Data.IDataReader"/>
            whose contents have been read into a <see cref="T:NHibernate.Driver.NDataReader"/>.
            </summary>
            <remarks>
            <para>
            This allows NHibernate to use the underlying <see cref="T:System.Data.IDataReader"/> for as long as
            possible without the need to read everything into the <see cref="T:NHibernate.Driver.NDataReader"/>.
            </para>
            <para>
            The consumer of the <see cref="T:System.Data.IDataReader"/> returned from <see cref="T:NHibernate.Engine.IBatcher"/> does
            not need to know the underlying reader and can use it the same even if it switches from an
            <see cref="T:System.Data.IDataReader"/> to <see cref="T:NHibernate.Driver.NDataReader"/> in the middle of its use.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.#ctor(System.Data.IDataReader)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.NHybridDataReader"/> class.
            </summary>
            <param name="reader">The underlying IDataReader to use.</param>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Initializes a new instance of the NHybridDataReader class.
            </summary>
            <param name="reader">The underlying IDataReader to use.</param>
            <param name="inMemory"><see langword="true" /> if the contents of the IDataReader should be read into memory right away.</param>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.ReadIntoMemory">
            <summary>
            Reads all of the contents into memory because another <see cref="T:System.Data.IDataReader"/>
            needs to be opened.
            </summary>
            <remarks>
            This will result in a no op if the reader is closed or is already in memory.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.NextResult">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Close">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Read">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Driver.NHybridDataReader._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this NHybridDataReader is being Disposed of or Finalized.</param>
            <remarks>
            If this NHybridDataReader is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this NHybridDataReader back to life.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt32(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetValue(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.IsDBNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferoffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetByte(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDecimal(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetValues(System.Object[])">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt64(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDouble(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetBoolean(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetGuid(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDateTime(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetFloat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetData(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldoffset"></param>
            <param name="buffer"></param>
            <param name="bufferoffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetString(System.Int32)">
            <summary>
             
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetChar(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt16(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.IsMidstream">
            <summary>
            Gets if the object is in the middle of reading a Result.
            </summary>
            <value><see langword="true"/> if NextResult and Read have been called on the <see cref="T:System.Data.IDataReader"/>.</value>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.RecordsAffected">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.IsClosed">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.Depth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.Item(System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.System#Data#IDataRecord#Item(System.Int32)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.FieldCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NpgsqlDriver">
            <summary>
            The PostgreSQL data provider provides a database driver for PostgreSQL.
            <p>
            Author: <a href="mailto:oliver@weichhold.com">Oliver Weichhold</a>
            </p>
            </summary>
            <remarks>
            <p>
            In order to use this Driver you must have the Npgsql.dll Assembly available for 
            NHibernate to load it.
            </p>
            <p>
            Please check the products website 
            <a href="http://www.postgresql.org/">http://www.postgresql.org/</a>
            for any updates and or documentation.
            </p>
            <p>
            The homepage for the .NET DataProvider is: 
            <a href="http://gborg.postgresql.org/project/npgsql/projdisplay.php">http://gborg.postgresql.org/project/npgsql/projdisplay.php</a>. 
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NpgsqlDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.NpgsqlDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Npgsql</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.OdbcDriver">
            <summary>
            A NHibernate Driver for using the Odbc DataProvider
            </summary>
            <remarks>
            Always look for a native .NET DataProvider before using the Odbc DataProvider.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.OleDbDriver">
            <summary>
            A NHibernate Driver for using the OleDb DataProvider
            </summary>
            <remarks>
            Always look for a native .NET DataProvider before using the OleDb DataProvider.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.OleDbDriver.SupportsMultipleOpenReaders">
            <summary>
            OLE DB provider does not support multiple open data readers
            </summary>
        </member>
        <member name="T:NHibernate.Driver.OracleClientDriver">
            <summary>
            A NHibernate Driver for using the Oracle DataProvider.
            </summary>
        </member>
        <member name="T:NHibernate.Driver.OracleDataClientDriver">
            <summary>
            A NHibernate Driver for using the Oracle.DataAccess DataProvider
            </summary>
            <remarks>
            Code was contributed by <a href="http://sourceforge.net/users/jemcalgary/">James Mills</a>
            on the NHibernate forums in this 
            <a href="http://sourceforge.net/forum/message.php?msg_id=2952662">post</a>.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.OracleDataClientDriver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.OracleDataClientDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Oracle.DataAccess</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="M:NHibernate.Driver.OracleDataClientDriver.InitializeParameter(System.Data.IDbDataParameter,System.String,NHibernate.SqlTypes.SqlType)">
            <remarks>
            This adds logic to ensure that a DbType.Boolean parameter is not created since
            ODP.NET doesn't support it.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.UseNamedPrefixInSql">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.NamedPrefix">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.SqlClientDriver">
            <summary>
            A NHibernate Driver for using the SqlClient DataProvider
            </summary>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.CreateConnection">
            <summary>
            Creates an uninitialized <see cref="T:System.Data.IDbConnection"/> object for 
            the SqlClientDriver.
            </summary>
            <value>An unitialized <see cref="T:System.Data.SqlClient.SqlConnection"/> object.</value>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.CreateCommand">
            <summary>
            Creates an uninitialized <see cref="T:System.Data.IDbCommand"/> object for 
            the SqlClientDriver.
            </summary>
            <value>An unitialized <see cref="T:System.Data.SqlClient.SqlCommand"/> object.</value>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.CreateBatcher(NHibernate.Impl.ConnectionManager)">
            <summary>
            Create an instance of <see cref="T:NHibernate.Engine.IBatcher"/> according to the configuration 
            and the capabilities of the driver
            </summary>
            <remarks>
            By default, .Net doesn't have any batching capabilities, drivers that does have
            batching support need to override this method and return their own batcher.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.UseNamedPrefixInSql">
            <summary>
            MsSql requires the use of a Named Prefix in the SQL statement.  
            </summary>
            <remarks>
            <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.UseNamedPrefixInParameter">
            <summary>
            MsSql requires the use of a Named Prefix in the Parameter.  
            </summary>
            <remarks>
            <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.NamedPrefix">
            <summary>
            The Named Prefix for parameters.  
            </summary>
            <value>
            Sql Server uses <c>"@"</c>.
            </value>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.SupportsMultipleOpenReaders">
            <summary>
            The SqlClient driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
            <value><see langword="false" /> - it is not supported.</value>
            <remarks>
            MS SQL Server 2000 (and 7) throws an exception when multiple IDataReaders are 
            attempted to be opened.  When SQL Server 2005 comes out a new driver will be 
            created for it because SQL Server 2005 is supposed to support it.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.SQLite20Driver">
            <summary>
            NHibernate driver for the System.Data.SQLite data provider for .NET 2.0.
            </summary>
            <remarks>
            <p>
            In order to use this driver you must have the System.Data.SQLite.dll assembly available
            for NHibernate to load. This assembly includes the SQLite.dll or SQLite3.dll libraries.
            </p>    
            <p>
            You can get the System.Data.SQLite.dll assembly from http://sourceforge.net/projects/sqlite-dotnet2.
            </p>
            <p>
            Please check <a href="http://www.sqlite.org/">http://www.sqlite.org/</a> for more information regarding SQLite.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.SQLite20Driver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.SQLiteDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>SQLite.NET</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.SQLiteDriver">
            <summary>
            NHibernate driver for the SQLite.NET data provider.
            <p>
            Author: <a href="mailto:ib@stalker.ro"> Ioan Bizau </a>
            </p>
            </summary>
            <remarks>
            <p>
            In order to use this Driver you must have the SQLite.NET.dll Assembly available for NHibernate to load it.
            You must also have the SQLite.dll and SQLite3.dll libraries.
            </p>
            <p>
            Please check <a href="http://www.sqlite.org/"> http://www.sqlite.org/ </a> for more information regarding SQLite.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.SQLiteDriver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.SQLiteDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>SQLite.NET</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.SqlServerCeDriver">
            <summary>
            A NHibernate driver for Microsoft SQL Server CE data provider
            </summary>
        </member>
        <member name="M:NHibernate.Driver.SqlServerCeDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SqlServerCeDriver"/> class.
            </summary>
        </member>
        <member name="P:NHibernate.Driver.SqlServerCeDriver.UseNamedPrefixInSql">
            <summary>
            MsSql requires the use of a Named Prefix in the SQL statement.  
            </summary>
            <remarks>
            <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlServerCeDriver.UseNamedPrefixInParameter">
            <summary>
            MsSql requires the use of a Named Prefix in the Parameter.  
            </summary>
            <remarks>
            <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlServerCeDriver.NamedPrefix">
            <summary>
            The Named Prefix for parameters.  
            </summary>
            <value>
            Sql Server uses <c>"@"</c>.
            </value>
        </member>
        <member name="P:NHibernate.Driver.SqlServerCeDriver.SupportsMultipleOpenReaders">
            <summary>
            The SqlClient driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
            <value><see langword="false" /> - it is not supported.</value>
            <remarks>
            Ms Sql 2000 (and 7) throws an Exception when multiple DataReaders are 
            attempted to be Opened.  When Yukon comes out a new Driver will be 
            created for Yukon because it is supposed to support it.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.SybaseClientDriver">
            <summary>
            The SybaseClientDriver Driver provides a database driver for Sybase.
            </summary>
            <remarks>
            It has been reported to work with the <see cref="T:NHibernate.Dialect.MsSql2000Dialect"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.SybaseClientDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SybaseClientDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the Sybase.Data.AseClient assembly can not be loaded.
            </exception>
        </member>
        <member name="P:NHibernate.Driver.SybaseClientDriver.UseNamedPrefixInSql">
            <summary>
            Sybase.Data.AseClient uses named parameters in the sql.
            </summary>
            <value><see langword="true" /> - Sybase uses <c>@</c> in the sql.</value>
        </member>
        <member name="P:NHibernate.Driver.SybaseClientDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.SybaseClientDriver.NamedPrefix">
            <summary>
            Sybase.Data.AseClient use the <c>@</c> to locate parameters in sql.
            </summary>
            <value><c>@</c> is used to locate parameters in sql.</value>
        </member>
        <member name="T:NHibernate.Engine.Query.ParameterParser">
            <summary>
            The single available method <see cref="M:NHibernate.Engine.Query.ParameterParser.Parse(System.String,NHibernate.Engine.Query.ParameterParser.IRecognizer)"/>
            is responsible for parsing a query string and recognizing tokens in
            relation to parameters (either named, ejb3-style, or ordinal) and
            providing callbacks about such recognitions.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Query.ParameterParser.Parse(System.String,NHibernate.Engine.Query.ParameterParser.IRecognizer)">
            <summary>
            Performs the actual parsing and tokenizing of the query string making appropriate
            callbacks to the given recognizer upon recognition of the various tokens.
            </summary>
            <remarks>
            Note that currently, this only knows how to deal with a single output
            parameter (for callable statements).  If we later add support for
            multiple output params, this, obviously, needs to change.
            </remarks>
            <param name="sqlString">The string to be parsed/tokenized.</param>
            <param name="recognizer">The thing which handles recognition events.</param>
            <exception cref="T:NHibernate.QueryException"/>
        </member>
        <member name="F:NHibernate.Engine.BatchFetchQueue.batchLoadableEntityKeys">
            <summary>
            Defines a sequence of <see cref="T:NHibernate.Engine.EntityKey"/> elements that are currently
            eligible for batch fetching.
            </summary>
            <remarks>
            Even though this is a map, we only use the keys.  A map was chosen in
            order to utilize a <see cref="T:NHibernate.Util.SequencedHashMap"/> to maintain sequencing
            as well as uniqueness.
            </remarks>
        </member>
        <member name="F:NHibernate.Engine.BatchFetchQueue.subselectsByEntityKey">
            <summary>
            A map of <see cref="T:NHibernate.Engine.SubselectFetch">subselect-fetch descriptors</see>
            keyed by the <see cref="T:NHibernate.Engine.EntityKey"/> against which the descriptor is
            registered.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.BatchFetchQueue.session">
            <summary>
            The owning persistence context.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Constructs a queue for the given context.
            </summary>
            <param name="session">The owning persistence context.</param>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.Clear">
            <summary>
            Clears all entries from this fetch queue.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.GetSubselect(NHibernate.Engine.EntityKey)">
            <summary>
            Retrieve the fetch descriptor associated with the given entity key.
            </summary>
            <param name="key">The entity key for which to locate any defined subselect fetch.</param>
            <returns>The fetch descriptor; may return null if no subselect fetch queued for
            this entity key.</returns>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.AddSubselect(NHibernate.Engine.EntityKey,NHibernate.Engine.SubselectFetch)">
            <summary>
            Adds a subselect fetch decriptor for the given entity key.
            </summary>
            <param name="key">The entity for which to register the subselect fetch.</param>
            <param name="subquery">The fetch descriptor.</param>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.RemoveSubselect(NHibernate.Engine.EntityKey)">
            <summary>
            After evicting or deleting an entity, we don't need to
            know the query that was used to load it anymore (don't
            call this after loading the entity, since we might still
            need to load its collections)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.ClearSubselects">
            <summary>
            Clears all pending subselect fetches from the queue.
            </summary>
            <remarks>
            Called after flushing.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.AddBatchLoadableEntityKey(NHibernate.Engine.EntityKey)">
            <summary>
            If an EntityKey represents a batch loadable entity, add
            it to the queue.
            </summary>
            <remarks>
            Note that the contract here is such that any key passed in should
            previously have been been checked for existence within the
            <see cref="T:NHibernate.ISession"/>; failure to do so may cause the
            referenced entity to be included in a batch even though it is
            already associated with the <see cref="T:NHibernate.ISession"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.RemoveBatchLoadableEntityKey(NHibernate.Engine.EntityKey)">
            <summary>
            After evicting or deleting or loading an entity, we don't
            need to batch fetch it anymore, remove it from the queue
            if necessary
            </summary>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.GetCollectionBatch(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32)">
            <summary>
            Get a batch of uninitialized collection keys for a given role
            </summary>
            <param name="collectionPersister">The persister for the collection role.</param>
            <param name="id">A key that must be included in the batch fetch</param>
            <param name="batchSize">the maximum number of keys to return</param>
            <returns>an array of collection keys, of length batchSize (padded with nulls)</returns>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.GetEntityBatch(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Int32)">
            <summary>
            Get a batch of unloaded identifiers for this class, using a slightly
            complex algorithm that tries to grab keys registered immediately after
            the given key.
            </summary>
            <param name="persister">The persister for the entities being loaded.</param>
            <param name="id">The identifier of the entity currently demanding load.</param>
            <param name="batchSize">The maximum number of keys to return</param>
            <returns>an array of identifiers, of length batchSize (possibly padded with nulls)</returns>
        </member>
        <member name="T:NHibernate.Engine.CascadePoint">
            <summary>
            The types of children to cascade to
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeAfterInsertBeforeDelete">
            <summary>
            A cascade point that occurs just after the insertion of the parent
            entity and just before deletion
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeBeforeInsertAfterDelete">
            <summary>
            A cascade point that occurs just before the insertion of the parent entity
            and just after deletion
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeAfterInsertBeforeDeleteViaCollection">
            <summary>
            A cascade point that occurs just after the insertion of the parent entity
            and just before deletion, inside a collection
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeOnUpdate">
            <summary>
            A cascade point that occurs just after the update of the parent entity
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeOnEvict">
            <summary>
            A cascade point that occurs just after eviction of the parent entity from the
            session cache
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeOnLock">
            <summary>
            A cascade point that occurs just after locking a transient parent entity into the session cache
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeOnCopy">
            <summary>
            A cascade point that occurs just after copying from a transient parent entity into the object in the session cache
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Cascades">
            <summary>
            Summary description for Cascades.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.Cascade(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType,NHibernate.Engine.Cascades.CascadingAction,NHibernate.Engine.Cascades.CascadeStyle,NHibernate.Engine.CascadePoint,System.Object)">
            <summary>
            Cascade an action to the child or children
            </summary>
            <param name="session"></param>
            <param name="child"></param>
            <param name="type"></param>
            <param name="action"></param>
            <param name="style"></param>
            <param name="cascadeTo"></param>
            <param name="anything"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.Cascade(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.Engine.Cascades.CascadingAction,NHibernate.Engine.CascadePoint)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <param name="parent"></param>
            <param name="action"></param>
            <param name="cascadeTo"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.Cascade(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.Engine.Cascades.CascadingAction,NHibernate.Engine.CascadePoint,System.Object)">
            <summary>
            Cascade an action from the parent object to all its children.
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <param name="parent"></param>
            <param name="action"></param>
            <param name="cascadeTo"></param>
            <param name="anything"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadeCollection(NHibernate.Engine.Cascades.CascadingAction,NHibernate.Engine.Cascades.CascadeStyle,NHibernate.Type.CollectionType,NHibernate.Type.IType,System.Object,NHibernate.Engine.CascadePoint,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Cascade to the collection elements
            </summary>
            <param name="action"></param>
            <param name="style"></param>
            <param name="collectionType"></param>
            <param name="elemType"></param>
            <param name="child"></param>
            <param name="cascadeVia"></param>
            <param name="session"></param>
            <param name="anything"></param>
        </member>
        <member name="T:NHibernate.Engine.Cascades.CascadingAction">
            <summary>
            A session action that may be cascaded from parent entity to its children
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadingAction.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadingAction.Cascade(NHibernate.Engine.ISessionImplementor,System.Object,System.Object)">
            <summary>
            Cascade the action to the child object
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadingAction.CascadableChildrenCollection(NHibernate.Type.CollectionType,System.Object)">
            <summary>
            The children to whom we should cascade.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadingAction.DeleteOrphans">
            <summary>
            Do we need to handle orphan delete for this action?
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionDelete">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionLock">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionEvict">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionSaveUpdate">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionCopy">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionReplicate">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Engine.Cascades.CascadeStyle">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadeStyle.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadeStyle.DoCascade(NHibernate.Engine.Cascades.CascadingAction)">
            <summary>
            Should the given action be cascaded?
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleAllDeleteOrphan">
            <summary>
            Save / Delete / Update / Evict / Lock / Replicate + delete orphans
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleAll">
            <summary>
            Save / Delete / Update / Evict / Lock / Replicate
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleSaveUpdate">
            <summary>
            Save / Update / Lock / Replicate
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleOnlyDelete">
            <summary>
            Delete
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleDeleteOrphan">
            <summary>
            Delete + delete orphans
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleNone">
            <summary>
            No Cascades
            </summary>
        </member>
        <member name="P:NHibernate.Engine.Cascades.CascadeStyle.HasOrphanDelete">
            <summary>
            Do we delete orphans automatically?
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Cascades.IdentifierValue">
            <summary>
            A strategy for determining if an identifier value is an identifier of a new 
            transient instance or a previously persistent transient instance. The strategy
            is determined by the <c>Unsaved-Value</c> attribute in the mapping file.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.IdentifierValue.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.IdentifierValue.#ctor(System.Object)">
            <summary>
            Assume the transient instance is newly instantiated if its identifier is null or
            equal to <c>Value</c>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.IdentifierValue.IsUnsaved(System.Object)">
            <summary>
            Does the given identifier belong to a new instance
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.IdentifierValue.SaveAny">
            <summary>
            Always assume the transient instance is newly instantiated
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.IdentifierValue.SaveNone">
            <summary>
            Never assume that transient instance is newly instantiated
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.IdentifierValue.SaveNull">
            <summary>
            Assume the transient instance is newly instantiated if the identifier
            is null.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Cascades.VersionValue">
            <summary>
            A strategy for determining if a version value is an version of
            a new transient instance or a previously persistent transient instance.
            The strategy is determined by the <c>Unsaved-Value</c> attribute in the mapping file.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.VersionValue.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.VersionValue.#ctor(System.Object)">
            <summary>
            Assume the transient instance is newly instantiated if its version is null or
            equal to <c>Value</c>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.VersionValue.IsUnsaved(System.Object)">
            <summary>
            Does the given identifier belong to a new instance
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.VersionValue.VersionSaveNull">
            <summary>
            Assume the transient instance is newly instantiated if the version
            is null, otherwise assume it is a detached instance.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.VersionValue.VersionUndefined">
            <summary>
            Assume the transient instance is newly instantiated if the version
            is null, otherwise defer to the identifier unsaved-value.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.VersionValue.VersionNegative">
            <summary>
            Assume the transient instance is newly instantiated if the identifier
            is null.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.EntityKey">
            <summary>
            A globally unique identifier of an instance, consisting of the user-visible identifier
            and the identifier space (eg. tablename)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.EntityKey.#ctor(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Construct a unique identifier for an entity class instance
            </summary>
            <param name="id"></param>
            <param name="p"></param>
        </member>
        <member name="M:NHibernate.Engine.EntityKey.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Engine.EntityKey.Identifier">
            <summary>
            The user-visible identifier
            </summary>
        </member>
        <member name="P:NHibernate.Engine.EntityKey.MappedClass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Engine.EntityKey.IsBatchLoadable">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Engine.FilterDefinition">
            <summary>
            A FilterDefinition defines the global attributes of a dynamic filter.  This
            information includes its name as well as its defined parameters (name and type).
            </summary>
        </member>
        <member name="M:NHibernate.Engine.FilterDefinition.#ctor(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            Set the named parameter's value list for this filter. 
            </summary>
            <param name="name">The name of the filter for which this configuration is in effect.</param>
            <param name="defaultCondition">The default filter condition.</param>
            <param name="parameterTypes">A dictionary storing the NHibernate <see cref="T:NHibernate.Type.IType"/> type
            of each parameter under its name.</param>
        </member>
        <member name="M:NHibernate.Engine.FilterDefinition.GetParameterType(System.String)">
            <summary>
            Retreive the type of the named parameter defined for this filter.
            </summary>
            <param name="parameterName">The name of the filter parameter for which to return the type.</param>
            <returns>The type of the named parameter.</returns>
        </member>
        <member name="P:NHibernate.Engine.FilterDefinition.FilterName">
            <summary>
            Get the name of the filter this configuration defines.
            </summary>
            <returns>The filter name for this configuration.</returns>
        </member>
        <member name="P:NHibernate.Engine.FilterDefinition.ParameterNames">
            <summary>
            Get a set of the parameters defined by this configuration.
            </summary>
            <returns>The parameters named by this configuration.</returns>
        </member>
        <member name="T:NHibernate.Engine.IBatcher">
            <summary>
            Manages <see cref="T:System.Data.IDbCommand"/>s and <see cref="T:System.Data.IDataReader"/>s 
            for an <see cref="T:NHibernate.ISession"/>. 
            </summary>
            <remarks>
            <p>
            Abstracts ADO.NET batching to maintain the illusion that a single logical batch 
            exists for the whole session, even when batching is disabled.
            Provides transparent <c>IDbCommand</c> caching.
            </p>
            <p>
            This will be useful once ADO.NET gets support for batching.  Until that point
            no code exists that will do batching, but this will provide a good point to do
            error checking and making sure the correct number of rows were affected.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareQueryCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
            <summary>
            Get an <see cref="T:System.Data.IDbCommand"/> for using in loading / querying.
            </summary>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <param name="commandType">The <see cref="T:System.Data.CommandType"/> of the command.</param>
            <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql"/>.</param>
            <returns>
            An <see cref="T:System.Data.IDbCommand"/> that is ready to be executed.
            </returns>
            <remarks>
            <para>
            If not explicitly released by <see cref="M:NHibernate.Engine.IBatcher.CloseCommand(System.Data.IDbCommand,System.Data.IDataReader)"/>, it will be 
            released when the session is closed or disconnected.
            </para>
            <para>
            This does NOT add anything to the batch - it only creates the IDbCommand and 
            does NOT cause the batch to execute...
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
            <summary>
            Get a non-batchable an <see cref="T:System.Data.IDbCommand"/> to use for inserting / deleting / updating.
            Must be explicitly released by <c>CloseCommand()</c>
            </summary>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <param name="commandType">The <see cref="T:System.Data.CommandType"/> of the command.</param>
            <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql"/>.</param>
            <returns>
            An <see cref="T:System.Data.IDbCommand"/> that is ready to have the parameter values set
            and then executed.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CloseCommand(System.Data.IDbCommand,System.Data.IDataReader)">
            <summary>
            Close a <see cref="T:System.Data.IDbCommand"/> opened using <c>PrepareCommand()</c>
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to ensure is closed.</param>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to ensure is closed.</param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareBatchCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
            <summary>
            Get a batchable <see cref="T:System.Data.IDbCommand"/> to use for inserting / deleting / updating
            (might be called many times before a single call to <c>ExecuteBatch()</c>
            </summary>
            <remarks>
            After setting parameters, call <c>AddToBatch()</c> - do not execute the statement
            explicitly.
            </remarks>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <param name="commandType">The <see cref="T:System.Data.CommandType"/> of the command.</param>
            <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql"/>.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.AddToBatch(NHibernate.AdoNet.IExpectation)">
            <summary>
            Add an insert / delete / update to the current batch (might be called multiple times
            for a single <c>PrepareBatchStatement()</c>)
            </summary>
            <param name="expectation">Determines whether the number of rows affected by query is correct.</param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteBatch">
            <summary>
            Execute the batch
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CloseCommands">
            <summary>
            Close any query statements that were left lying around
            </summary>
            <remarks>
            Use this method instead of <c>Dispose</c> if the <see cref="T:NHibernate.Engine.IBatcher"/>
            can be used again.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteReader(System.Data.IDbCommand)">
            <summary>
            Gets an <see cref="T:System.Data.IDataReader"/> by calling ExecuteReader on the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to execute to get the <see cref="T:System.Data.IDataReader"/>.</param>
            <returns>The <see cref="T:System.Data.IDataReader"/> from the <see cref="T:System.Data.IDbCommand"/>.</returns>
            <remarks>
            The Batcher is responsible for ensuring that all of the Drivers rules for how many open
            <see cref="T:System.Data.IDataReader"/>s it can have are followed.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteNonQuery(System.Data.IDbCommand)">
            <summary>
            Executes the <see cref="T:System.Data.IDbCommand"/>. 
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to execute.</param>
            <returns>The number of rows affected.</returns>
            <remarks>
            The Batcher is responsible for ensuring that all of the Drivers rules for how many open
            <see cref="T:System.Data.IDataReader"/>s it can have are followed.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.AbortBatch(System.Exception)">
            <summary>
            Must be called when an exception occurs.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CancelLastQuery">
            <summary>
            Cancel the current query statement
            </summary>
        </member>
        <member name="P:NHibernate.Engine.IBatcher.HasOpenResources">
            <summary>
            Gets the value indicating whether there are any open resources
            managed by this batcher (IDbCommands or IDataReaders).
            </summary>
        </member>
        <member name="T:NHibernate.Engine.ICollectionSnapshot">
            <summary>
            Defines a complete "snapshot" of a particular collection.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.Key">
            <summary>
            Gets the identifier of the Entity that owns this Collection.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.Role">
            <summary>
            Gets the role that identifies this Collection.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.Snapshot">
            <summary>
            Gets the snapshot copy of the Collection's elements.
            </summary>
            <remarks>
            In most cases this is the same collection type as the one being snapshotted. 
            ie - the snapshot of an IList will return an IList.
            </remarks>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.WasDereferenced">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the collection was at one time
            associated with an Entity and then later dereferenced during a Flush().
            </summary>
        </member>
        <member name="T:NHibernate.Engine.ISessionFactoryImplementor">
            <summary>
            Defines the internal contract between the <c>ISessionFactory</c> and other parts of NHibernate
            such as implementors of <c>IType</c>.
            </summary>
        </member>
        <member name="T:NHibernate.ISessionFactory">
            <summary>
            Creates <c>ISession</c>s.
            </summary>
            <remarks>
            <para>
            Usually an application has a single <c>SessionFactory</c>. Threads servicing client requests
            obtain <c>ISession</c>s from the factory. Implementors must be threadsafe.
            </para>
            <para>
            <c>ISessionFactory</c>s are immutable. The behaviour of a <c>SessionFactory</c>
            is controlled by properties supplied at configuration time.
            These properties are defined on <c>Environment</c>
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection)">
            <summary>
            Open a <c>ISession</c> on the given connection
            </summary>
            <param name="conn">A connection provided by the application</param>
            <returns>A session</returns>
            <remarks>
            Note that the second-level cache will be disabled if you
            supply a ADO.NET connection. NHibernate will not be able to track
            any statements you might have executed in the same transaction.
            Consider implementing your own <see cref="T:NHibernate.Connection.IConnectionProvider"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(NHibernate.IInterceptor)">
            <summary>
            Create database connection and open a <c>ISession</c> on it, specifying an interceptor
            </summary>
            <param name="interceptor">A session-scoped interceptor</param>
            <returns>A session</returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection,NHibernate.IInterceptor)">
            <summary>
            Open a <c>ISession</c> on the given connection, specifying an interceptor
            </summary>
            <param name="conn">A connection provided by the application</param>
            <param name="interceptor">A session-scoped interceptor</param>
            <returns>A session</returns>
            <remarks>
            Note that the second-level cache will be disabled if you
            supply a ADO.NET connection. NHibernate will not be able to track
            any statements you might have executed in the same transaction.
            Consider implementing your own <see cref="T:NHibernate.Connection.IConnectionProvider"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession">
            <summary>
            Create a database connection and open a <c>ISession</c> on it
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenDatabinder">
            <summary>
            Create a new databinder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetClassMetadata(System.Type)">
            <summary>
            Get the <c>ClassMetadata</c> associated with the given entity class
            </summary>
            <param name="persistentType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetCollectionMetadata(System.String)">
            <summary>
            Get the <c>CollectionMetadata</c> associated with the named collection role
            </summary>
            <param name="roleName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetAllClassMetadata">
            <summary>
            Get all <c>ClassMetadata</c> as a <c>IDictionary</c> from <c>Type</c>
            to metadata object
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetAllCollectionMetadata">
            <summary>
            Get all <c>CollectionMetadata</c> as a <c>IDictionary</c> from role name
            to metadata object
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.Close">
            <summary>
            Destroy this <c>SessionFactory</c> and release all resources 
            connection pools, etc). It is the responsibility of the application
            to ensure that there are no open <c>Session</c>s before calling
            <c>close()</c>. 
            </summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.Evict(System.Type)">
            <summary>
            Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="persistentClass"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.Evict(System.Type,System.Object)">
            <summary>
            Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="persistentClass"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictCollection(System.String)">
            <summary>
            Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="roleName"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictCollection(System.String,System.Object)">
            <summary>
            Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="roleName"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictQueries">
            <summary>
            Evict any query result sets cached in the default query cache region.
            </summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictQueries(System.String)">
            <summary>
            Evict any query result sets cached in the named query cache region.
            </summary>
            <param name="cacheRegion"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetFilterDefinition(System.String)">
            <summary>
            Obtain the definition of a filter by name.
            </summary>
            <param name="filterName">The name of the filter for which to obtain the definition.</param>
            <return>The filter definition.</return>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetCurrentSession">
            <summary>
            Obtains the current session.
            </summary>
            <remarks>
            <para>
            The definition of what exactly "current" means is controlled by the <see cref="T:NHibernate.Context.ICurrentSessionContext"/>
            implementation configured for use.
            </para>
            </remarks>
            <returns>The current session.</returns>
            <exception cref="T:NHibernate.HibernateException">Indicates an issue locating a suitable current session.</exception>
        </member>
        <member name="P:NHibernate.ISessionFactory.ConnectionProvider">
            <summary>
            Get the <see cref="T:NHibernate.Connection.IConnectionProvider"/> used.
            </summary>
        </member>
        <member name="P:NHibernate.ISessionFactory.Dialect">
            <summary>
            Get the SQL <c>Dialect</c>
            </summary>
        </member>
        <member name="P:NHibernate.ISessionFactory.DefinedFilterNames">
            <summary>
            Obtain a set of the names of all filters defined on this SessionFactory.
            </summary>
            <return>The set of filter names.</return>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetEntityPersister(System.Type)">
            <summary>
            Get the persister for a class
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetEntityPersister(System.String)">
            <summary>
            Get the persister for the named class
            </summary>
            <param name="className">The name of the class that is persisted.</param>
            <returns>The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class.</returns>
            <exception cref="T:NHibernate.MappingException">If no <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> can be found.</exception>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetEntityPersister(System.String,System.Boolean)">
            <summary>
            Get the persister for the named class
            </summary>
            <param name="className">The name of the class that is persisted.</param>
            <param name="throwIfNotFound">Whether to throw an exception if the class is not found,
            or just return <see langword="null"/></param>
            <returns>The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class.</returns>
            <exception cref="T:NHibernate.MappingException">If no <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> can be found
            and throwIfNotFound is true.</exception>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetCollectionPersister(System.String)">
            <summary>
            Get the persister object for a collection role
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetReturnTypes(System.String)">
            <summary>
            Get the return types of a query
            </summary>
            <param name="queryString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetImplementors(System.Type)">
            <summary>
            Get the names of all persistent classes that implement/extend the given interface/class
            </summary>
            <param name="clazz"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetImportedClassName(System.String)">
            <summary>
            Get a class name, using query language imports
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetQueryCache(System.String)">
            <summary>
            Get a particular named query cache, or the default cache
            </summary>
            <param name="regionName">the name of the cache region, or null for the default
            query cache</param>
            <returns>the existing cache, or a newly created cache if none by that
            region name</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.OpenConnection">
            <summary>
            Obtain an ADO.NET connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Release an ADO.NET connection
            </summary>
            <param name="conn"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetIdentifierGenerator(System.Type)">
            <summary>
            Get the identifier generator for the hierarchy
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.OpenSession(System.Data.IDbConnection,NHibernate.ConnectionReleaseMode)">
            <summary>
            Open a session conforming to the given parameters. For use mainly by
            <see cref="T:NHibernate.Context.ICurrentSessionContext"/> implementations.
            </summary>
            <param name="connection">The external ADO.NET connection to use, if any (i.e., optional).</param>
            <param name="connectionReleaseMode">The release mode for managed database connections.</param>
            <returns>An appropriate session.</returns>
            <exception cref="T:NHibernate.HibernateException"/>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsOuterJoinedFetchEnabled">
            <summary>
            Is outerjoin fetching enabled?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsScrollableResultSetsEnabled">
            <summary>
            Are scrollable <c>ResultSet</c>s supported?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsGetGeneratedKeysEnabled">
            <summary>
            Is <c>PreparedStatement.getGeneratedKeys</c> supported (Java-specific?)
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.DefaultSchema">
            <summary>
            Get the database schema specified in <c>hibernate.default_schema</c>
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.BatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.FetchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.MaximumFetchDepth">
            <summary>
            Maximum depth of outer join fetching
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsShowSqlEnabled">
            <summary>
            Are we logging SQL to the console?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.QueryCache">
            <summary>
            Get the default query cache
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsQueryCacheEnabled">
            <summary>
            Is query caching enabled?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.Isolation">
            <summary>
            Gets the IsolationLevel an IDbTransaction should be set to.
            </summary>
            <remarks>
            This is only applicable to manually controlled NHibernate Transactions.
            </remarks>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsBatchUpdateEnabled">
            <summary>
            Gets a boolean indicating if the sql statement should be prepared.  The value
            is calculated from <c>hibernate.adonet.batch_size</c> if the value exists and greater than 0.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.ISessionImplementor">
            <summary>
            Defines the internal contract between the <c>Session</c> and other parts of Hibernate
            such as implementors of <c>Type</c> or <c>ClassPersister</c>
            </summary>
        </member>
        <member name="T:NHibernate.ISession">
            <summary>
            The main runtime interface between a Java application and Hibernate. This is the central
            API class abstracting the notion of a persistence service.
            </summary>
            <remarks>
            <para>
            The lifecycle of a <c>ISession</c> is bounded by the beginning and end of a logical
            transaction. (Long transactions might span several database transactions.)
            </para>
            <para>
            The main function of the <c>ISession</c> is to offer create, find and delete operations
            for instances of mapped entity classes. Instances may exist in one of two states:
            <list>
            	<item>transient: not associated with any <c>ISession</c></item>
            	<item>persistent: associated with a <c>ISession</c></item>
            </list>
            </para>
            <para>
            Transient instances may be made persistent by calling <c>Save()</c>, <c>Insert()</c>,
            or <c>Update()</c>. Persistent instances may be made transient by calling <c>Delete()</c>.
            Any instance returned by a <c>Find()</c>, <c>Iterate()</c>, <c>Load()</c>, or <c>Create</c>
            method is persistent.
            </para>
            <para>
            <c>Save()</c> results in an SQL <c>INSERT</c>, <c>Delete()</c>
            in an SQL <c>DELETE</c> and <c>Update()</c> in an SQL <c>UPDATE</c>. Changes to
            <em>persistent</em> instances are deteced at flush time and also result in an SQL
            <c>UPDATE</c>.
            </para>
            <para>
            It is not intended that implementors be threadsafe. Instead each thread/transaction should obtain
            its own instance from an <c>ISessionFactory</c>.
            </para>
            <para>
            A <c>ISession</c> instance is serializable if its persistent classes are serializable
            </para>
            <para>
            A typical transaction should use the following idiom:
            	<code>
            		ISession sess = factory.OpenSession();
            		ITransaction tx;
            		try {
            			tx = sess.BeginTransaction();
            			//do some work
            			...
            			tx.Commit();
            		} catch (Exception e) {
            			if (tx != null) tx.Rollback();
            			throw;
            		} finally {
            			sess.Close();
            		}
            	</code>
            </para>
            <para>
            If the <c>ISession</c> throws an exception, the transaction must be rolled back and the session
            discarded. The internal state of the <c>ISession</c> might not be consistent with the database
            after the exception occurs.
            </para>
            <seealso cref="T:NHibernate.ISessionFactory"/>
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Flush">
            <summary>
            Force the <c>ISession</c> to flush.
            </summary>
            <remarks>
            Must be called at the end of a unit of work, before commiting the transaction and closing
            the session (<c>Transaction.Commit()</c> calls this method). <i>Flushing</i> if the process
            of synchronising the underlying persistent store with persistable state held in memory.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Disconnect">
            <summary>
            Disconnect the <c>ISession</c> from the current ADO.NET connection.
            </summary>
            <remarks>
            If the connection was obtained by Hibernate, close it or return it to the connection
            pool. Otherwise return it to the application. This is used by applications which require
            long transactions.
            </remarks>
            <returns>The connection provided by the application or <see langword="null" /></returns>
        </member>
        <member name="M:NHibernate.ISession.Reconnect">
            <summary>
            Obtain a new ADO.NET connection.
            </summary>
            <remarks>
            This is used by applications which require long transactions
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Reconnect(System.Data.IDbConnection)">
            <summary>
            Reconnect to the given ADO.NET connection.
            </summary>
            <remarks>This is used by applications which require long transactions</remarks>
            <param name="connection">An ADO.NET connection</param>
        </member>
        <member name="M:NHibernate.ISession.Close">
            <summary>
            End the <c>ISession</c> by disconnecting from the ADO.NET connection and cleaning up.
            </summary>
            <remarks>
            It is not strictly necessary to <c>Close()</c> the <c>ISession</c> but you must
            at least <c>Disconnect()</c> it.
            </remarks>
            <returns>The connection provided by the application or <see langword="null" /></returns>
        </member>
        <member name="M:NHibernate.ISession.CancelQuery">
            <summary>
            Cancel execution of the current query.
            </summary>
            <remarks>
            May be called from one thread to stop execution of a query in another thread.
            Use with care!
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.IsDirty">
            <summary>
            Does this <c>ISession</c> contain any changes which must be
            synchronized with the database? Would any SQL be executed if
            we flushed this session?
            </summary>
        </member>
        <member name="M:NHibernate.ISession.GetIdentifier(System.Object)">
            <summary>
            Return the identifier of an entity instance cached by the <c>ISession</c>
            </summary>
            <remarks>
            Throws an exception if the instance is transient or associated with a different
            <c>ISession</c>
            </remarks>
            <param name="obj">a persistent instance</param>
            <returns>the identifier</returns>
        </member>
        <member name="M:NHibernate.ISession.Contains(System.Object)">
            <summary>
            Is this instance associated with this Session?
            </summary>
            <param name="obj">an instance of a persistent class</param>
            <returns>true if the given instance is associated with this Session</returns>
        </member>
        <member name="M:NHibernate.ISession.Evict(System.Object)">
            <summary>
            Remove this instance from the session cache.
            </summary>
            <remarks>
            Changes to the instance will not be synchronized with the database.
            This operation cascades to associated instances if the association is mapped
            with <c>cascade="all"</c> or <c>cascade="all-delete-orphan"</c>.
            </remarks>
            <param name="obj">a persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode.
            </summary>
            <param name="theType">A persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <param name="lockMode">The lock level</param>
            <returns>the persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Type,System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            assuming that the instance exists.
            </summary>
            <remarks>
            You should not use this method to determine if an instance exists (use a query or
            <see cref="M:NHibernate.ISession.Get(System.Type,System.Object)"/> instead). Use this only to retrieve an instance
            that you assume exists, where non-existence would be an actual error.
            </remarks>
            <param name="theType">A persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <returns>The persistent instance or proxy</returns>
        </member>
        <member name="M:NHibernate.ISession.Load``1(System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode.
            </summary>
            <typeparam name="T">A persistent class</typeparam>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <param name="lockMode">The lock level</param>
            <returns>the persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.Load``1(System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            assuming that the instance exists.
            </summary>
            <remarks>
            You should not use this method to determine if an instance exists (use a query or
            <see cref="M:NHibernate.ISession.Get``1(System.Object)"/> instead). Use this only to retrieve an instance that you
            assume exists, where non-existence would be an actual error.
            </remarks>
            <typeparam name="T">A persistent class</typeparam>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <returns>The persistent instance or proxy</returns>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Object,System.Object)">
            <summary>
            Read the persistent state associated with the given identifier into the given transient 
            instance.
            </summary>
            <param name="obj">An "empty" instance of the persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
        </member>
        <member name="M:NHibernate.ISession.Replicate(System.Object,NHibernate.ReplicationMode)">
            <summary>
            Persist all reachable transient objects, reusing the current identifier 
            values. Note that this will not trigger the Interceptor of the Session.
            </summary>
            <param name="obj"></param>
            <param name="replicationMode"></param>
        </member>
        <member name="M:NHibernate.ISession.Save(System.Object)">
            <summary>
            Persist the given transient instance, first assigning a generated identifier.
            </summary>
            <remarks>
            Save will use the current value of the identifier property if the <c>Assigned</c>
            generator is used.
            </remarks>
            <param name="obj">A transient instance of a persistent class</param>
            <returns>The generated identifier</returns>
        </member>
        <member name="M:NHibernate.ISession.Save(System.Object,System.Object)">
            <summary>
            Persist the given transient instance, using the given identifier.
            </summary>
            <param name="obj">A transient instance of a persistent class</param>
            <param name="id">An unused valid identifier</param>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdate(System.Object)">
            <summary>
            Either <c>Save()</c> or <c>Update()</c> the given instance, depending upon the value of
            its identifier property.
            </summary>
            <remarks>
            By default the instance is always saved. This behaviour may be adjusted by specifying
            an <c>unsaved-value</c> attribute of the identifier property mapping
            </remarks>
            <param name="obj">A transient instance containing new or updated state</param>
        </member>
        <member name="M:NHibernate.ISession.Update(System.Object)">
            <summary>
            Update the persistent instance with the identifier of the given transient instance.
            </summary>
            <remarks>
            If there is a persistent instance with the same identifier, an exception is thrown. If
            the given transient instance has a <see langword="null" /> identifier, an exception will be thrown.
            </remarks>
            <param name="obj">A transient instance containing updated state</param>
        </member>
        <member name="M:NHibernate.ISession.Update(System.Object,System.Object)">
            <summary>
            Update the persistent state associated with the given identifier.
            </summary>
            <remarks>
            An exception is thrown if there is a persistent instance with the same identifier
            in the current session.
            </remarks>
            <param name="obj">A transient instance containing updated state</param>
            <param name="id">Identifier of persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdateCopy(System.Object)">
            <summary>
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with 
            the session, it will be loaded. Return the persistent instance. If the 
            given instance is unsaved or does not exist in the database, save it and 
            return it as a newly persistent instance. Otherwise, the given instance
            does not become associated with the session.
            </summary>
            <param name="obj">a transient instance with state to be copied</param>
            <returns>an updated persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdateCopy(System.Object,System.Object)">
            <summary>
            Copy the state of the given object onto the persistent object with the 
            given identifier. If there is no persistent instance currently associated 
            with the session, it will be loaded. Return the persistent instance. If
            there is no database row with the given identifier, save the given instance
            and return it as a newly persistent instance. Otherwise, the given instance
            does not become associated with the session.
            </summary>
            <param name="obj">a persistent or transient instance with state to be copied</param>
            <param name="id">the identifier of the instance to copy to</param>
            <returns>an updated persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.Object)">
            <summary>
            Remove a persistent instance from the datastore.
            </summary>
            <remarks>
            The argument may be an instance associated with the receiving <c>ISession</c> or a
            transient instance with an identifier associated with existing persistent state.
            </remarks>
            <param name="obj">The instance to be removed</param>
        </member>
        <member name="M:NHibernate.ISession.Find(System.String)">
            <summary>
            Execute a query
            </summary>
            <param name="query">A query expressed in Hibernate's query language</param>
            <returns>A distinct list of instances</returns>
            <remarks>See <see cref="M:NHibernate.IQuery.List"/> for implications of <c>cache</c> usage.</remarks>
        </member>
        <member name="M:NHibernate.ISession.Find(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Execute a query, binding a value to a "?" parameter in the query string.
            </summary>
            <param name="query">The query string</param>
            <param name="value">A value to be bound to a "?" placeholder</param>
            <param name="type">The Hibernate type of the value</param>
            <returns>A distinct list of instances</returns>
            <remarks>See <see cref="M:NHibernate.IQuery.List"/> for implications of <c>cache</c> usage.</remarks>
        </member>
        <member name="M:NHibernate.ISession.Find(System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Execute a query, binding an array of values to a "?" parameters in the query string.
            </summary>
            <param name="query">The query string</param>
            <param name="values">An array of values to be bound to the "?" placeholders</param>
            <param name="types">An array of Hibernate types of the values</param>
            <returns>A distinct list of instances</returns>
            <remarks>See <see cref="M:NHibernate.IQuery.List"/> for implications of <c>cache</c> usage.</remarks>
        </member>
        <member name="M:NHibernate.ISession.Enumerable(System.String)">
            <summary>
            Execute a query and return the results in an interator.
            </summary>
            <remarks>
            <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
            <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>Find()</c>.
            </para>
            </remarks>
            <param name="query">The query string</param>
            <returns>An enumerator</returns>
        </member>
        <member name="M:NHibernate.ISession.Enumerable(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Execute a query and return the results in an interator, 
            binding a value to a "?" parameter in the query string.
            </summary>
            <remarks>
            <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
            <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>Find()</c>.
            </para>
            </remarks>
            <param name="query">The query string</param>
            <param name="value">A value to be written to a "?" placeholder in the query string</param>
            <param name="type">The hibernate type of the value</param>
            <returns>An enumerator</returns>
        </member>
        <member name="M:NHibernate.ISession.Enumerable(System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Execute a query and return the results in an interator, 
            binding the values to "?"s parameters in the query string.
            </summary>
            <remarks>
            <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
            <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>Find()</c>.
            </para>
            </remarks>
            <param name="query">The query string</param>
            <param name="values">A list of values to be written to "?" placeholders in the query</param>
            <param name="types">A list of hibernate types of the values</param>
            <returns>An enumerator</returns>
        </member>
        <member name="M:NHibernate.ISession.Filter(System.Object,System.String)">
            <summary>
            Apply a filter to a persistent collection.
            </summary>
            <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
            <param name="collection">A persistent collection to filter</param>
            <param name="filter">A filter query string</param>
            <returns>The resulting collection</returns>
        </member>
        <member name="M:NHibernate.ISession.Filter(System.Object,System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Apply a filter to a persistent collection, binding the given parameter to a "?" placeholder
            </summary>
            <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
            <param name="collection">A persistent collection to filter</param>
            <param name="filter">A filter query string</param>
            <param name="value">A value to be written to a "?" placeholder in the query</param>
            <param name="type">The hibernate type of value</param>
            <returns>A collection</returns>
        </member>
        <member name="M:NHibernate.ISession.Filter(System.Object,System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Apply a filter to a persistent collection, binding the given parameters to "?" placeholders.
            </summary>
            <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
            <param name="collection">A persistent collection to filter</param>
            <param name="filter">A filter query string</param>
            <param name="values">The values to be written to "?" placeholders in the query</param>
            <param name="types">The hibernate types of the values</param>
            <returns>A collection</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String)">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <returns>Returns the number of objects deleted.</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <param name="value">A value to be written to a "?" placeholer in the query</param>
            <param name="type">The hibernate type of value.</param>
            <returns>The number of instances deleted</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <param name="values">A list of values to be written to "?" placeholders in the query</param>
            <param name="types">A list of Hibernate types of the values</param>
            <returns>The number of instances deleted</returns>
        </member>
        <member name="M:NHibernate.ISession.Lock(System.Object,NHibernate.LockMode)">
            <summary>
            Obtain the specified lock level upon the given object.
            </summary>
            <param name="obj">A persistent instance</param>
            <param name="lockMode">The lock level</param>
        </member>
        <member name="M:NHibernate.ISession.Refresh(System.Object)">
            <summary>
            Re-read the state of the given instance from the underlying database.
            </summary>
            <remarks>
            <para>
            It is inadvisable to use this to implement long-running sessions that span many
            business tasks. This method is, however, useful in certain special circumstances.
            </para>
            <para>
            For example,
            <list>
            	<item>Where a database trigger alters the object state upon insert or update</item>
            	<item>After executing direct SQL (eg. a mass update) in the same session</item>
            	<item>After inserting a <c>Blob</c> or <c>Clob</c></item>
            </list>
            </para>
            </remarks>
            <param name="obj">A persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.Refresh(System.Object,NHibernate.LockMode)">
            <summary>
            Re-read the state of the given instance from the underlying database, with
            the given <c>LockMode</c>.
            </summary>
            <remarks>
            It is inadvisable to use this to implement long-running sessions that span many
            business tasks. This method is, however, useful in certain special circumstances.
            </remarks>
            <param name="obj">a persistent or transient instance</param>
            <param name="lockMode">the lock mode to use</param>
        </member>
        <member name="M:NHibernate.ISession.GetCurrentLockMode(System.Object)">
            <summary>
            Determine the current lock mode of the given object
            </summary>
            <param name="obj">A persistent instance</param>
            <returns>The current lock mode</returns>
        </member>
        <member name="M:NHibernate.ISession.BeginTransaction">
            <summary>
            Begin a unit of work and return the associated <c>ITransaction</c> object.
            </summary>
            <remarks>
            If a new underlying transaction is required, begin the transaction. Otherwise
            continue the new work in the context of the existing underlying transaction.
            The class of the returned <see cref="T:NHibernate.ITransaction"/> object is determined by
            the property <c>hibernate.transaction_factory</c>
            </remarks>
            <returns>A transaction instance</returns>
        </member>
        <member name="M:NHibernate.ISession.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Begin a transaction with the specified <c>isolationLevel</c>
            </summary>
            <param name="isolationLevel">Isolation level for the new transaction</param>
            <returns>A transaction instance having the specified isolation level</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria(System.Type)">
            <summary>
            Creates a new <c>Criteria</c> for the entity class.
            </summary>
            <param name="persistentClass">The class to Query</param>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria(System.Type,System.String)">
            <summary>
            Creates a new <c>Criteria</c> for the entity class with a specific alias
            </summary>
            <param name="persistentClass">The class to Query</param>
            <param name="alias">The alias of the entity</param>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateQuery(System.String)">
            <summary>
            Create a new instance of <c>Query</c> for the given query string
            </summary>
            <param name="queryString">A hibernate query string</param>
            <returns>The query</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateFilter(System.Object,System.String)">
            <summary>
            Create a new instance of <c>Query</c> for the given collection and filter string
            </summary>
            <param name="collection">A persistent collection</param>
            <param name="queryString">A hibernate query</param>
            <returns>A query</returns>
        </member>
        <member name="M:NHibernate.ISession.GetNamedQuery(System.String)">
            <summary>
            Obtain an instance of <see cref="T:NHibernate.IQuery"/> for a named query string defined in the
            mapping file.
            </summary>
            <param name="queryName">The name of a query defined externally.</param>
            <returns>An <see cref="T:NHibernate.IQuery"/> from a named query string.</returns>
            <remarks>
            The query can be either in <c>HQL</c> or <c>SQL</c> format.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String,System.Type)">
            <summary>
            Create a new instance of <c>IQuery</c> for the given SQL string.
            </summary>
            <param name="sql">a query expressed in SQL</param>
            <param name="returnAlias">a table alias that appears inside <c>{}</c> in the SQL string</param>
            <param name="returnClass">the returned persistent class</param>
            <returns>An <see cref="T:NHibernate.IQuery"/> from the SQL string</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])">
            <summary>
            Create a new instance of <see cref="T:NHibernate.IQuery"/> for the given SQL string.
            </summary>
            <param name="sql">a query expressed in SQL</param>
            <param name="returnAliases">an array of table aliases that appear inside <c>{}</c> in the SQL string</param>
            <param name="returnClasses">the returned persistent classes</param>
            <returns>An <see cref="T:NHibernate.IQuery"/> from the SQL string</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateSQLQuery(System.String)">
            <summary>
            Create a new instance of <see cref="T:NHibernate.ISQLQuery"/> for the given SQL query string.
            </summary>
            <param name="queryString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISession.Clear">
            <summary>
            Completely clear the session. Evict all loaded instances and cancel all pending
            saves, updates and deletions. Do not close open enumerables or instances of
            <c>ScrollableResults</c>.
            </summary>
        </member>
        <member name="M:NHibernate.ISession.Get(System.Type,System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier, or null
            if there is no such persistent instance. (If the instance, or a proxy for the instance, is
            already associated with the session, return that instance or proxy.)
            </summary>
            <param name="clazz">a persistent class</param>
            <param name="id">an identifier</param>
            <returns>a persistent instance or null</returns>
        </member>
        <member name="M:NHibernate.ISession.Get(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier, or null
            if there is no such persistent instance. Obtain the specified lock mode if the instance
            exists.
            </summary>
            <param name="clazz">a persistent class</param>
            <param name="id">an identifier</param>
            <param name="lockMode">the lock mode</param>
            <returns>a persistent instance or null</returns>
        </member>
        <member name="M:NHibernate.ISession.Get``1(System.Object)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.ISession.Get(System.Type,System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.ISession.Get``1(System.Object,NHibernate.LockMode)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.ISession.Get(System.Type,System.Object,NHibernate.LockMode)"/>
            </summary>
        </member>
        <member name="M:NHibernate.ISession.EnableFilter(System.String)">
            <summary>
            Enable the named filter for this current session.
            </summary>
            <param name="filterName">The name of the filter to be enabled.</param>
            <returns>The Filter instance representing the enabled fiter.</returns>
        </member>
        <member name="M:NHibernate.ISession.GetEnabledFilter(System.String)">
            <summary>
            Retrieve a currently enabled filter by name.
            </summary>
            <param name="filterName">The name of the filter to be retrieved.</param>
            <returns>The Filter instance representing the enabled fiter.</returns>
        </member>
        <member name="M:NHibernate.ISession.DisableFilter(System.String)">
            <summary>
            Disable the named filter for the current session.
            </summary>
            <param name="filterName">The name of the filter to be disabled.</param>
        </member>
        <member name="M:NHibernate.ISession.CreateMultiQuery">
            <summary>
            Create a multi query, a query that can send several
            queries to the server, and return all their results in a single
            call.
            </summary>
            <returns>
            An <see cref="T:NHibernate.IMultiQuery"/> that can return
            a list of all the results of all the queries.
            Note that each query result is itself usually a list.
            </returns>
        </member>
        <member name="M:NHibernate.ISession.GetSessionImplementation">
            <summary>
            Gets the session implementation.
            </summary>
            <remarks>
            This method is provided in order to get the <b>NHibernate</b> implementation of the session from wrapper implementions.
            Implementors of the <seealso cref="T:NHibernate.ISession"/> interface should return the NHibernate implementation of this method.
            </remarks>
            <returns>
            An NHibernate implementation of the <seealso cref="T:NHibernate.Engine.ISessionImplementor"/> interface 
            </returns>
        </member>
        <member name="P:NHibernate.ISession.FlushMode">
            <summary>
            Determines at which points Hibernate automatically flushes the session.
            </summary>
            <remarks>
            For a readonly session, it is reasonable to set the flush mode to <c>FlushMode.Never</c>
            at the start of the session (in order to achieve some extra performance).
            </remarks>
        </member>
        <member name="P:NHibernate.ISession.SessionFactory">
            <summary>
            Get the <see cref="T:NHibernate.ISessionFactory"/> that created this instance.
            </summary>
        </member>
        <member name="P:NHibernate.ISession.Connection">
            <summary>
            Gets the ADO.NET connection.
            </summary>
            <remarks>
            Applications are responsible for calling commit/rollback upon the connection before
            closing the <c>ISession</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.ISession.IsOpen">
            <summary>
            Is the <c>ISession</c> still open?
            </summary>
        </member>
        <member name="P:NHibernate.ISession.IsConnected">
            <summary>
            Is the <c>ISession</c> currently connected?
            </summary>
        </member>
        <member name="P:NHibernate.ISession.Transaction">
            <summary>
            Get the current Unit of Work and return the associated <c>ITransaction</c> object.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetLoadedCollectionKey(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Get the pre-flush identifier of the collection
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetSnapshot(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Get the snapshot of the pre-flush collection state
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetArrayHolder(System.Object)">
            <summary>
            Get the <see cref="T:NHibernate.Collection.IPersistentCollection"/> object for an array
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AddArrayHolder(NHibernate.Collection.PersistentArrayHolder)">
            <summary>
            Register a <see cref="T:NHibernate.Collection.IPersistentCollection"/> object for an array
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InitializeCollection(NHibernate.Collection.IPersistentCollection,System.Boolean)">
            <summary>
            Initialize the collection (if not already initialized)
            </summary>
            <param name="coolection"></param>
            <param name="writing"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.IsInverseCollection(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Is this the "inverse" end of a bidirectional association?
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetLoadingCollection(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            new in h2.1 and no javadoc
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="resultSetId"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.EndLoadingCollections(NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            new in h2.1 and no javadoc
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AfterLoad">
            <summary>
            new in h2.1 and no javadoc
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.BeforeLoad">
            <summary>
            new in h2.1 and no javadoc
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InitializeNonLazyCollections">
            <summary>
            new in h2.1 and no javadoc
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetCollection(System.String,System.Object,System.Object)">
            <summary>
            Gets the NHibernate collection wrapper from the ISession.
            </summary>
            <param name="role"></param>
            <param name="id"></param>
            <param name="owner"></param>
            <returns>
            A NHibernate wrapped collection.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InternalLoad(System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Load an instance without checking if it was deleted. If it does not exist and isn't nullable, throw an exception.
            This method may create a new proxy or return an existing proxy.
            </summary>
            <param name="persistentClass">The <see cref="T:System.Type"/> to load.</param>
            <param name="id">The identifier of the object in the database.</param>
            <param name="isNullable">Allow null instance</param>
            <param name="eager">When enabled, the object is eagerly fetched.</param>
            <returns>
            A proxy of the object or an instance of the object if the <c>persistentClass</c> does not have a proxy.
            </returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">No object could be found with that <c>id</c>.</exception>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ImmediateLoad(System.Type,System.Object)">
            <summary>
            Load an instance immediately. Do not return a proxy.
            </summary>
            <param name="persistentClass"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.LoadByUniqueKey(System.Type,System.String,System.Object)">
            <summary>
            Load an instance by a unique key that is not the primary key.
            </summary>
            <param name="persistentClass"></param>
            <param name="uniqueKeyPropertyName"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.PostDelete(System.Object)">
            <summary>
            After actually deleting a row, record the fact that the instance no longer exists on the
            database (needed for identity-column key generation)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Find(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a <c>Find()</c> query
            </summary>
            <param name="query"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Find``1(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.Find(System.String,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Find``1(NHibernate.Impl.CriteriaImpl)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.Find(NHibernate.Impl.CriteriaImpl)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute an <c>Iterate()</c> query
            </summary>
            <param name="query"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable``1(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.Enumerable(System.String,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Filter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a filter
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Filter``1(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a filter (strongly-typed version).
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Collection from a filter
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter``1(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityPersister(System.Object)">
            <summary>
            Get the <c>IEntityPersister</c> for an object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AddUninitializedEntity(NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode)">
            <summary>
            Add an uninitialized instance of an entity class, as a placeholder to ensure object identity.
            Must be called before <c>PostHydrate()</c>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.PostHydrate(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object[],System.Object,NHibernate.LockMode)">
            <summary>
            Register the "hydrated" state of an entity instance, after the first step of 2-phase loading
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InitializeEntity(System.Object)">
            <summary>
            Perform the second step of 2-phase load (ie. fully initialize the entity instance)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntity(NHibernate.Engine.EntityKey)">
            <summary>
            Get the entity instance associated with the given <c>EntityKey</c>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ProxyFor(NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            Return the existing proxy associated with the given <c>EntityKey</c>, or the second
            argument (the entity associated with the key) if no proxy exists.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> to see if it should be Proxied.</param>
            <param name="key">The <see cref="T:NHibernate.Engine.EntityKey"/> that identifies the entity.</param>
            <param name="impl"></param>
            <returns>Returns a the Proxy for the class or the parameter impl.</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ProxyFor(System.Object)">
            <summary>
            Return the existing proxy associated with the given object. (Slower than the form above)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AfterTransactionBegin(NHibernate.ITransaction)">
            <summary>
            Notify the session that an NHibernate transaction has begun.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.BeforeTransactionCompletion(NHibernate.ITransaction)">
            <summary>
            Notify the session that the transaction is about to complete
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AfterTransactionCompletion(System.Boolean,NHibernate.ITransaction)">
            <summary>
            Notify the session that the transaction completed, so we no longer own the old locks.
            (Also we shold release cache softlocks). May be called multiple times during the transaction
            completion process.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityIdentifier(System.Object)">
            <summary>
            Return the identifier of the persistent object, or null if transient
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityIdentifierIfNotUnsaved(System.Object)">
            <summary>
            Return the identifer of the persistent or transient object, or throw
            an exception if the instance is "unsaved"
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Instantiate(System.Type,System.Object)">
            <summary>
            Instantiate the entity class, initializing with the given identifier
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.SetLockMode(System.Object,NHibernate.LockMode)">
            <summary>
            Set the lock mode of the entity to the given lock mode
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetVersion(System.Object)">
            <summary>
            Get the current version of the entity
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetLockMode(System.Object)">
            <summary>
            Get the lock mode of the entity
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.Engine.Query.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute an SQL Query
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List``1(NHibernate.Engine.Query.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.Engine.Query.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AddNonExist(NHibernate.Engine.EntityKey)">
            <summary>
            new in 2.1 no javadoc
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Copy(System.Object,System.Collections.IDictionary)">
            <summary>
            new in 2.1 no javadoc
            </summary>
            <param name="obj"></param>
            <param name="copiedAlready"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetCollectionOwner(System.Object,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            new in 2.1 no javadoc
            </summary>
            <param name="key"></param>
            <param name="collectionPersister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntry(System.Object)">
            <summary>
            Retrieve the <see cref="T:NHibernate.Impl.EntityEntry"/> representation of the given entity.
            </summary>
            <param name="entity">The entity for which to locate the EntityEntry.</param>
            <returns>The EntityEntry for the given entity.</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetFilterParameterValue(System.String)">
            <summary>
            Retreive the currently set value for a filter parameter.
            </summary>
            <param name="filterParameterName">The filter parameter name in the format 
            {FILTER_NAME.PARAMETER_NAME}.</param>
            <returns>The filter parameter value.</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetFilterParameterType(System.String)">
            <summary>
            Retreive the type for a given filter parrameter.
            </summary>
            <param name="filterParameterName">The filter parameter name in the format 
            {FILTER_NAME.PARAMETER_NAME}.</param>
            <returns>The filter parameter type.</returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Timestamp">
            <summary>
            System time before the start of the transaction
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Factory">
            <summary>
            Get the creating SessionFactoryImplementor
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Batcher">
            <summary>
            Get the prepared statement <c>Batcher</c> for this session
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.EnabledFilters">
            <summary>
            Return the currently enabled filters.  The filter map is keyed by filter
            name, with values corresponding to the {@link org.hibernate.impl.FilterImpl}
            instance.
            </summary>
            <returns>The currently enabled filters.</returns>
        </member>
        <member name="M:NHibernate.Engine.JoinHelper.GetAliasedLHSColumnNames(NHibernate.Type.IAssociationType,System.String,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,NHibernate.Engine.IMapping)">
            <summary>
            Get the aliased columns of the owning entity which are to 
            be used in the join
            </summary>
        </member>
        <member name="M:NHibernate.Engine.JoinHelper.GetLHSColumnNames(NHibernate.Type.IAssociationType,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,NHibernate.Engine.IMapping)">
            <summary>
            Get the columns of the owning entity which are to 
            be used in the join
            </summary>
        </member>
        <member name="M:NHibernate.Engine.JoinHelper.GetAliasedLHSColumnNames(NHibernate.Type.IAssociationType,System.String,System.Int32,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,NHibernate.Engine.IMapping)">
            <summary>
            Get the aliased columns of the owning entity which are to 
            be used in the join
            </summary>
        </member>
        <member name="M:NHibernate.Engine.JoinHelper.GetLHSColumnNames(NHibernate.Type.IAssociationType,System.Int32,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,NHibernate.Engine.IMapping)">
            <summary>
            Get the columns of the owning entity which are to 
            be used in the join
            </summary>
        </member>
        <member name="M:NHibernate.Engine.JoinHelper.GetRHSColumnNames(NHibernate.Type.IAssociationType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Get the columns of the associated table which are to 
            be used in the join
            </summary>
        </member>
        <member name="T:NHibernate.Engine.QueryParameters">
            <summary>
            Container for data that is used during the NHibernate query/load process. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.#ctor(NHibernate.Type.IType[],System.Object[])">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Engine.QueryParameters"/> class.
            </summary>
            <param name="positionalParameterTypes">An array of <see cref="T:NHibernate.Type.IType"/> objects for the parameters.</param>
            <param name="positionalParameterValues">An array of <see cref="T:System.Object"/> objects for the parameters.</param>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.#ctor(NHibernate.Type.IType[],System.Object[],System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Engine.RowSelection,System.Boolean,System.String,System.Boolean,System.Object[],System.Object,System.Type,System.Object,NHibernate.Transform.IResultTransformer)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Engine.QueryParameters"/> class.
            </summary>
            <param name="positionalParameterTypes">An array of <see cref="T:NHibernate.Type.IType"/> objects for the parameters.</param>
            <param name="positionalParameterValues">An array of <see cref="T:System.Object"/> objects for the parameters.</param>
            <param name="namedParameters">An <see cref="T:System.Collections.IDictionary"/> that is <c>parameter name</c> keyed to a <see cref="T:NHibernate.Engine.TypedValue"/> value.</param>
            <param name="lockModes">An <see cref="T:System.Collections.IDictionary"/> that is <c>hql alias</c> keyed to a LockMode value.</param>
            <param name="rowSelection"></param>
            <param name="cacheable"></param>
            <param name="cacheRegion"></param>
            <param name="forceCacheRefresh"></param>
            <param name="collectionKeys"></param>
            <param name="optionalObject"></param>
            <param name="optionalEntityName"></param>
            <param name="optionalId"></param>
            <param name="resultTransformer"></param>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.LogParameters(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.ValidateParameters">
            <summary>
            Ensure the Types and Values are the same length.
            </summary>
            <exception cref="T:NHibernate.QueryException">
            If the Lengths of <see cref="P:NHibernate.Engine.QueryParameters.PositionalParameterTypes"/> and 
            <see cref="P:NHibernate.Engine.QueryParameters.PositionalParameterValues"/> are not equal.
            </exception>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.HasRowSelection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.NamedParameters">
            <summary>
            Gets or sets an <see cref="T:System.Collections.IDictionary"/> that contains the named 
            parameter as the key and the <see cref="T:NHibernate.Engine.TypedValue"/> as the value.
            </summary>
            <value>An <see cref="T:System.Collections.IDictionary"/> of named parameters.</value>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.PositionalParameterTypes">
            <summary>
            Gets or sets an array of <see cref="T:NHibernate.Type.IType"/> objects that is stored at the index 
            of the Parameter.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.PositionalParameterValues">
            <summary>
            Gets or sets an array of <see cref="T:System.Object"/> objects that is stored at the index 
            of the Parameter.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.RowSelection">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Engine.QueryParameters.RowSelection"/> for the Query.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.LockModes">
            <summary>
            Gets or sets an <see cref="T:System.Collections.IDictionary"/> that contains the alias name of the
            object from hql as the key and the <see cref="T:NHibernate.LockMode"/> as the value.
            </summary>
            <value>An <see cref="T:System.Collections.IDictionary"/> of lock modes.</value>
        </member>
        <member name="T:NHibernate.Engine.RowSelection">
            <summary>
            Information to determine how to run an IDbCommand and what
            records to return from the IDataReader.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.RowSelection.NoValue">
            <summary>
            Indicates that the no value has been set on the Property.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.FirstRow">
            <summary>
            Gets or Sets the Index of the First Row to Select
            </summary>
            <value>The Index of the First Rows to Select</value>
            <remarks>Defaults to 0 unless specifically set.</remarks>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.MaxRows">
            <summary>
            Gets or Sets the Maximum Number of Rows to Select
            </summary>
            <value>The Maximum Number of Rows to Select</value>
            <remarks>Defaults to NoValue unless specifically set.</remarks>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.Timeout">
            <summary>
            Gets or Sets the Timeout of the Query
            </summary>
            <value>The Query Timeout</value>
            <remarks>Defaults to NoValue unless specifically set.</remarks>
        </member>
        <member name="T:NHibernate.Engine.TypedValue">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.TypedValue.#ctor(NHibernate.Type.IType,System.Object)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="value"></param>
        </member>
        <member name="P:NHibernate.Engine.TypedValue.Value">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Engine.TypedValue.Type">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.UnsavedValueFactory.GetUnsavedIdentifierValue(System.String,NHibernate.Property.IGetter,NHibernate.Type.IType,System.Reflection.ConstructorInfo)">
            <summary>
            Return an IdentifierValue for the specified unsaved-value. If none is specified,
            guess the unsaved value by instantiating a test instance of the class and
            reading it's id property, or if that is not possible, using the java default
            value for the type
            </summary>
        </member>
        <member name="T:NHibernate.Engine.ValueInclusion">
            <summary>
            An enum of the different ways a value might be "included".
            </summary>
            <remarks>
            This is really an expanded true/false notion with Partial being the
            expansion. Partial deals with components in the cases where
            parts of the referenced component might define inclusion, but the
            component overall does not.
            </remarks>
        </member>
        <member name="T:NHibernate.Engine.Versioning">
            <summary>
            Utility methods for managing versions and timestamps
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Versioning.Increment(System.Object,NHibernate.Type.IVersionType,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Increment the given version number
            </summary>
            <param name="version">The value of the current version.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <param name="session">The current <see cref="T:NHibernate.ISession"/>.</param>
            <returns>Returns the next value for the version.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.Seed(NHibernate.Type.IVersionType,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create an initial version number
            </summary>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <param name="session">The current <see cref="T:NHibernate.ISession"/>.</param>
            <returns>A seed value to initialize the versioned property with.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.SeedVersion(System.Object[],System.Int32,NHibernate.Type.IVersionType,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Seed the given instance state snapshot with an initial version number
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="versionProperty">The index of the version property in the <c>fields</c> parameter.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <param name="force">Force the version to initialize</param>
            <param name="session">The current session, if any.</param>
            <returns><see langword="true"/> if the version property needs to be seeded with an initial value.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.GetVersion(System.Object[],System.Int32,NHibernate.Type.IVersionType)">
            <summary>
            Gets the value of the version.
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="versionProperty">The index of the version property in the <c>fields</c> parameter.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <returns>The value of the version.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.SetVersion(System.Object[],System.Object,System.Int32,NHibernate.Type.IVersionType)">
            <summary>
            Sets the value of the version.
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="version">The value the version should be set to in the <c>fields</c> parameter.</param>
            <param name="versionProperty">The index of the version property in the <c>fields</c> parameter.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
        </member>
        <member name="M:NHibernate.Engine.Versioning.SetVersion(System.Object[],System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Set the version number of the given instance state snapshot
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="version">The value the version should be set to in the <c>fields</c> parameter.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for persisting the values of the <c>fields</c> parameter.</param>
        </member>
        <member name="M:NHibernate.Engine.Versioning.GetVersion(System.Object[],NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Get the version number of the given instance state snapshot
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for persisting the values of the <c>fields</c> parameter.</param>
            <returns>
            The value of the version contained in the <c>fields</c> parameter or null if the
            Entity is not versioned.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.IsVersionIncrementRequired(System.Int32[],System.Boolean,System.Boolean[])">
            <summary>
            Do we need to increment the version number, given the dirty properties?
            </summary>
        </member>
        <member name="M:NHibernate.Exceptions.ADOExceptionHelper.Convert(System.Exception,System.String)">
            <summary>
            Converts the given SQLException into NHibernate's ADOException hierarchy, as well as performing
            appropriate logging.
            </summary>
            <!--<param name="converter">The converter to use.</param>-->
            <param name="sqlException">The exception to convert.</param>
            <param name="message">An optional error message.</param>
            <returns>The converted ADOException.</returns>
        </member>
        <member name="T:NHibernate.Expression.AbstractCriterion">
            <summary>
            Base class for <see cref="T:NHibernate.Expression.ICriterion"/> implementations.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.ICriterion">
            <summary>
            An object-oriented representation of a query criterion that may be used as a constraint
            in a <see cref="T:NHibernate.ICriteria"/> query.
            </summary>
            <remarks>
            Built-in criterion types are provided by the <c>Expression</c> factory class.
            This interface might be implemented by application classes but, more commonly, application 
            criterion types would extend <c>AbstractCriterion</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.ICriterion.ToSqlString(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery,System.Collections.IDictionary)">
            <summary>
            Render a SqlString fragment for the expression.
            </summary>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="M:NHibernate.Expression.ICriterion.GetTypedValues(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery)">
            <summary>
            Return typed values for all parameters in the rendered SQL fragment
            </summary>
            <returns>An array of TypedValues for the Expression.</returns>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.ToString">
            <summary>
            Gets a string representation of the <see cref="T:NHibernate.Expression.AbstractCriterion"/>.  
            </summary>
            <returns>
            A String that shows the contents of the <see cref="T:NHibernate.Expression.AbstractCriterion"/>.
            </returns>
            <remarks>
            This is not a well formed Sql fragment.  It is useful for logging what the <see cref="T:NHibernate.Expression.AbstractCriterion"/>
            looks like.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.ToSqlString(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery,System.Collections.IDictionary)">
            <summary>
            Render a SqlString for the expression.
            </summary>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.GetTypedValues(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery)">
            <summary>
            Return typed values for all parameters in the rendered SQL fragment
            </summary>
            <returns>An array of TypedValues for the Expression.</returns>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.op_False(NHibernate.Expression.AbstractCriterion)">
            <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.op_True(NHibernate.Expression.AbstractCriterion)">
            <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
        </member>
        <member name="M:NHibernate.Expression.AbstractEmptinessExpression.op_False(NHibernate.Expression.AbstractEmptinessExpression)">
            <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
        </member>
        <member name="M:NHibernate.Expression.AbstractEmptinessExpression.op_True(NHibernate.Expression.AbstractEmptinessExpression)">
            <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
        </member>
        <member name="T:NHibernate.Expression.AggregateProjection">
            <summary>
            An Aggregation
            </summary>
        </member>
        <member name="T:NHibernate.Expression.SimpleProjection">
            <summary>
            A single-column projection that may be aliased
            </summary>
        </member>
        <member name="M:NHibernate.Expression.IProjection.ToSqlString(NHibernate.ICriteria,System.Int32,NHibernate.Expression.ICriteriaQuery)">
            <summary>
            Render the SQL Fragment.
            </summary>
            <param name="criteria"></param>
            <param name="position"></param>
            <param name="criteriaQuery"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.IProjection.ToGroupSqlString(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery)">
            <summary>
            Render the SQL Fragment to be used in the Group By Clause.
            </summary>
            <param name="criteria"></param>
            <param name="criteriaQuery"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.IProjection.GetTypes(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery)">
            <summary>
            Return types for a particular user-visible alias
            </summary>
            <param name="criteria"></param>
            <param name="criteriaQuery"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.IProjection.GetTypes(System.String,NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="criteria"></param>
            <param name="criteriaQuery"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.IProjection.GetColumnAliases(System.Int32)">
            <summary>
            Get the SQL select clause column aliases for a particular user-visible alias
            </summary>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.IProjection.GetColumnAliases(System.String,System.Int32)">
            <summary>
            Get the SQL select clause column aliases for a particular user-visible alias
            </summary>
            <param name="alias"></param>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Expression.IProjection.Aliases">
            <summary>
            Get the user-visible aliases for this projection (ie. the ones that will be passed to the ResultTransformer)
            </summary>
        </member>
        <member name="P:NHibernate.Expression.IProjection.IsGrouped">
            <summary>
            Does this projection specify grouping attributes?
            </summary>
        </member>
        <member name="T:NHibernate.Expression.AndExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.LogicalExpression"/> that combines two <see cref="T:NHibernate.Expression.ICriterion"/>s 
            with an <c>and</c> between them.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.LogicalExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that combines two <see cref="T:NHibernate.Expression.ICriterion"/>s 
            with a operator (either "<c>and</c>" or "<c>or</c>") between them.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LogicalExpression.#ctor(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.LogicalExpression"/> class that
            combines two other <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use in the Left Hand Side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use in the Right Hand Side.</param>
        </member>
        <member name="M:NHibernate.Expression.LogicalExpression.GetTypedValues(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery)">
            <summary>
            Combines the <see cref="T:NHibernate.Engine.TypedValue"/> for the Left Hand Side and the 
            Right Hand Side of the Expression into one array.
            </summary>
            <returns>An arry of <see cref="T:NHibernate.Engine.TypedValue"/>s.</returns>
        </member>
        <member name="M:NHibernate.Expression.LogicalExpression.ToSqlString(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery,System.Collections.IDictionary)">
            <summary>
            Converts the LogicalExpression to a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <returns>A well formed SqlString for the Where clause.</returns>
            <remarks>The SqlString will be enclosed by <c>(</c> and <c>)</c>.</remarks>
        </member>
        <member name="M:NHibernate.Expression.LogicalExpression.ToString">
            <summary>
            Gets a string representation of the LogicalExpression.  
            </summary>
            <returns>
            The String contains the LeftHandSide.ToString() and the RightHandSide.ToString()
            joined by the Op.
            </returns>
            <remarks>
            This is not a well formed Sql fragment.  It is useful for logging what Expressions
            are being combined.
            </remarks>
        </member>
        <member name="P:NHibernate.Expression.LogicalExpression.LeftHandSide">
            <summary>
            Gets the <see cref="T:NHibernate.Expression.ICriterion"/> that will be on the Left Hand Side of the Op.
            </summary>
        </member>
        <member name="P:NHibernate.Expression.LogicalExpression.RightHandSide">
            <summary>
            Gets the <see cref="T:NHibernate.Expression.ICriterion"/> that will be on the Right Hand Side of the Op.
            </summary>
        </member>
        <member name="P:NHibernate.Expression.LogicalExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Expression.Expression"/>s.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.AndExpression.#ctor(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.AndExpression"/> class
            that combines two <see cref="T:NHibernate.Expression.ICriterion"/>.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use as the left hand side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.AndExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <value>The string "<c>and</c>"</value>
        </member>
        <member name="T:NHibernate.Expression.BetweenExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents a "between" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.BetweenExpression.#ctor(System.String,System.Object,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.BetweenExpression"/> class for
            the named Property.
            </summary>
            <param name="propertyName">The name of the Property of the Class.</param>
            <param name="lo">The low value for the BetweenExpression.</param>
            <param name="hi">The high value for the BetweenExpression.</param>
        </member>
        <member name="M:NHibernate.Expression.BetweenExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.Conjunction">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that Junctions together multiple 
            <see cref="T:NHibernate.Expression.ICriterion"/>s with an <c>and</c>
            </summary>
        </member>
        <member name="T:NHibernate.Expression.Junction">
            <summary>
            A sequence of logical <see cref="T:NHibernate.Expression.ICriterion"/>s combined by some associative
            logical operator.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Junction.Add(NHibernate.Expression.ICriterion)">
            <summary>
            Adds an <see cref="T:NHibernate.Expression.ICriterion"/> to the list of <see cref="T:NHibernate.Expression.ICriterion"/>s
            to junction together.
            </summary>
            <param name="criterion">The <see cref="T:NHibernate.Expression.ICriterion"/> to add.</param>
            <returns>
            This <see cref="T:NHibernate.Expression.Junction"/> instance.
            </returns>
        </member>
        <member name="P:NHibernate.Expression.Junction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
        </member>
        <member name="P:NHibernate.Expression.Junction.EmptyExpression">
            <summary>
            The <see cref="T:NHibernate.SqlCommand.SqlString"/> corresponding to an instance with no added
            subcriteria.
            </summary>
        </member>
        <member name="P:NHibernate.Expression.Conjunction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <value>The string "<c> and </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.CountProjection">
            <summary>
            A Count
            </summary>
        </member>
        <member name="T:NHibernate.Expression.DetachedCriteria">
            <summary>
            Some applications need to create criteria queries in "detached
            mode", where the Hibernate session is not available. This class
            may be instantiated anywhere, and then a <c>ICriteria</c>
            may be obtained by passing a session to 
            <c>GetExecutableCriteria()</c>. All methods have the
            same semantics and behavior as the corresponding methods of the
            <c>ICriteria</c> interface.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.DetachedCriteria.GetExecutableCriteria(NHibernate.ISession)">
            <summary>
            Get an executable instance of <c>Criteria</c>,
            to actually run the query.</summary>
        </member>
        <member name="T:NHibernate.Expression.Disjunction">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that Junctions together multiple 
            <see cref="T:NHibernate.Expression.ICriterion"/>s with an <c>or</c>
            </summary>
        </member>
        <member name="P:NHibernate.Expression.Disjunction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <value>The string "<c> or </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.EqExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "equal" constraint.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.SimpleExpression">
            <summary>
            The base class for an <see cref="T:NHibernate.Expression.ICriterion"/> that compares a single Property
            to a value.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.SimpleExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.SimpleExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Expression.SimpleExpression.ToSqlString(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery,System.Collections.IDictionary)">
            <summary>
            Converts the SimpleExpression to a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="M:NHibernate.Expression.SimpleExpression.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Expression.SimpleExpression.PropertyName">
            <summary>
            Gets the named Property for the Expression.
            </summary>
            <value>A string that is the name of the Property.</value>
        </member>
        <member name="P:NHibernate.Expression.SimpleExpression.Value">
            <summary>
            Gets the Value for the Expression.
            </summary>
            <value>An object that is the value for the Expression.</value>
        </member>
        <member name="P:NHibernate.Expression.SimpleExpression.Op">
            <summary>
            Get the Sql operator to use for the specific 
            subclass of <see cref="T:NHibernate.Expression.SimpleExpression"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.EqExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.EqExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <param name="ignoreCase">Use case-insensitive comparison</param>
        </member>
        <member name="M:NHibernate.Expression.EqExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.EqExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.EqExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.EqExpression"/>.
            </summary>
            <value>The string "<c> = </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.EqPropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "equal" constraint 
            between two properties.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.PropertyExpression">
            <summary>
            Superclass for an <see cref="T:NHibernate.Expression.ICriterion"/> that represents a
            constraint between two properties (with SQL binary operators).
            </summary>
        </member>
        <member name="M:NHibernate.Expression.PropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.PropertyExpression"/> class 
            that compares two mapped properties.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="M:NHibernate.Expression.PropertyExpression.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Expression.PropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the property expression.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.EqPropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.EqPropertyExpression"/> class
            that compares two mapped properties using an "equal" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.EqPropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.EqPropertyExpression"/>.
            </summary>
            <value>The string "<c> = </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.Example">
            <summary>
            Support for <c>Query By Example</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Example.SetPropertySelector(NHibernate.Expression.Example.IPropertySelector)">
            <summary>
            Set the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Expression.Example"/>.
            </summary>
            <param name="selector">The <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> to determine which properties to include.</param>
            <returns>This <see cref="T:NHibernate.Expression.Example"/> instance.</returns>
            <remarks>
            This should be used when a custom <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> has
            been implemented.  Otherwise use the methods <see cref="M:NHibernate.Expression.Example.ExcludeNulls"/> 
            or <see cref="M:NHibernate.Expression.Example.ExcludeNone"/> to set the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/>
            to the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/>s built into NHibernate.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.Example.ExcludeZeroes">
            <summary>
            Set the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Expression.Example"/>
            to exclude zero-valued properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Example.ExcludeNone">
            <summary>
            Set the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Expression.Example"/>
            to exclude no properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Example.EnableLike(NHibernate.Expression.MatchMode)">
            <summary>
            Use the "like" operator for all string-valued properties with
            the specified <see cref="T:NHibernate.Expression.MatchMode"/>.
            </summary>
            <param name="matchMode">
            The <see cref="T:NHibernate.Expression.MatchMode"/> to convert the string to the pattern
            for the <c>like</c> comparison.
            </param>
        </member>
        <member name="M:NHibernate.Expression.Example.EnableLike">
            <summary>
            Use the "like" operator for all string-valued properties.
            </summary>
            <remarks>
            The default <see cref="T:NHibernate.Expression.MatchMode"/> is <see cref="F:NHibernate.Expression.MatchMode.Exact">MatchMode.Exact</see>.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.Example.ExcludeProperty(System.String)">
            <summary>
            Exclude a particular named property
            </summary>
            <param name="name">The name of the property to exclude.</param>
        </member>
        <member name="M:NHibernate.Expression.Example.Create(System.Object)">
            <summary>
            Create a new instance, which includes all non-null properties 
            by default
            </summary>
            <param name="entity"></param>
            <returns>A new instance of <see cref="T:NHibernate.Expression.Example"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Example.#ctor(System.Object,NHibernate.Expression.Example.IPropertySelector)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.Example"/> class for a particular
            entity.
            </summary>
            <param name="entity">The <see cref="T:System.Object"/> that the Example is being built from.</param>
            <param name="selector">The <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> the Example should use.</param>
        </member>
        <member name="M:NHibernate.Expression.Example.IsPropertyIncluded(System.Object,System.String,NHibernate.Type.IType)">
            <summary>
            Determines if the property should be included in the Query.
            </summary>
            <param name="value">The value of the property.</param>
            <param name="name">The name of the property.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the property.</param>
            <returns>
            <see langword="true"/> if the Property should be included, <see langword="false"/> if
            the Property should not be a part of the Query.
            </returns>
        </member>
        <member name="M:NHibernate.Expression.Example.AddPropertyTypedValue(System.Object,NHibernate.Type.IType,System.Collections.IList)">
            <summary>
            Adds a <see cref="T:NHibernate.Engine.TypedValue"/> based on the <c>value</c> 
            and <c>type</c> parameters to the <see cref="T:System.Collections.IList"/> in the
            <c>list</c> parameter.
            </summary>
            <param name="value">The value of the Property.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the Property.</param>
            <param name="list">The <see cref="T:System.Collections.IList"/> to add the <see cref="T:NHibernate.Engine.TypedValue"/> to.</param>
            <remarks>
            This method will add <see cref="T:NHibernate.Engine.TypedValue"/> objects to the <c>list</c> parameter.
            </remarks>
        </member>
        <member name="T:NHibernate.Expression.Example.IPropertySelector">
            <summary>
            A strategy for choosing property values for inclusion in the query criteria
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Example.IPropertySelector.Include(System.Object,System.String,NHibernate.Type.IType)">
            <summary>
            Determine if the Property should be included.
            </summary>
            <param name="propertyValue">The value of the property that is being checked for inclusion.</param>
            <param name="propertyName">The name of the property that is being checked for inclusion.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the property.</param>
            <returns>
            <see langword="true"/> if the Property should be included in the Query, 
            <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="T:NHibernate.Expression.Example.AllPropertySelector">
            <summary>
            Implementation of <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> that includes all
            properties regardless of value.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.Example.NotNullOrEmptyStringPropertySelector">
            <summary>
            Implementation of <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> that includes the
            properties that are not <see langword="null"/> and do not have an <see cref="F:System.String.Empty"/>
            returned by <c>propertyValue.ToString()</c>.
            </summary>
            <remarks>
            This selector is not present in H2.1. It may be useful if nullable types
            are used for some properties.
            </remarks>
        </member>
        <member name="T:NHibernate.Expression.Expression">
            <summary>
            The <c>Expression</c> namespace may be used by applications as a framework for building 
            new kinds of <see cref="T:NHibernate.Expression.ICriterion"/>. However, it is intended that most applications will 
            simply use the built-in criterion types via the static factory methods of this class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Expression.IdEq(System.Object)">
            <summary>
            Apply an "equal" constraint to the identifier property
            </summary>
            <param name="value"></param>
            <returns>ICriterion</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Eq(System.String,System.Object)">
            <summary>
            Apply an "equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>An <see cref="T:NHibernate.Expression.EqExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Like(System.String,System.Object)">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.LikeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.InsensitiveLike(System.String,System.Object)">
            <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>An <see cref="T:NHibernate.Expression.InsensitiveLikeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Gt(System.String,System.Object)">
            <summary>
            Apply a "greater than" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.GtExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Lt(System.String,System.Object)">
            <summary>
            Apply a "less than" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.LtExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Le(System.String,System.Object)">
            <summary>
            Apply a "less than or equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.LeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Ge(System.String,System.Object)">
            <summary>
            Apply a "greater than or equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.GtExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Between(System.String,System.Object,System.Object)">
            <summary>
            Apply a "between" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="lo">The low value for the Property.</param>
            <param name="hi">The high value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.BetweenExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.In(System.String,System.Object[])">
            <summary>
            Apply an "in" constraint to the named property 
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="values">An array of values.</param>
            <returns>An <see cref="T:NHibernate.Expression.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.In(System.String,System.Collections.ICollection)">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="values">An ICollection of values.</param>
            <returns>An <see cref="T:NHibernate.Expression.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.InG``1(System.String,System.Collections.Generic.ICollection{``0})">
            <summary>
            Apply an "in" constraint to the named property. This is the generic equivalent
            of <see cref="M:NHibernate.Expression.Expression.In(System.String,System.Collections.ICollection)"/>, renamed to avoid ambiguity.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="values">An <see cref="T:System.Collections.Generic.ICollection`1"/>
            of values.</param>
            <returns>An <see cref="T:NHibernate.Expression.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.IsNull(System.String)">
            <summary>
            Apply an "is null" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Expression.NullExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.EqProperty(System.String,System.String)">
            <summary>
            Apply an "equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.NotEqProperty(System.String,System.String)">
            <summary>
            Apply an "not equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.GtProperty(System.String,System.String)">
            <summary>
            Apply a "greater than" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.GeProperty(System.String,System.String)">
            <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.LtProperty(System.String,System.String)">
            <summary>
            Apply a "less than" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.LeProperty(System.String,System.String)">
            <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.IsNotNull(System.String)">
            <summary>
            Apply an "is not null" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Expression.NotNullExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.IsNotEmpty(System.String)">
            <summary>
            Apply an "is not empty" constraint to the named property 
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Expression.IsNotEmptyExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.IsEmpty(System.String)">
            <summary>
            Apply an "is not empty" constraint to the named property 
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Expression.IsEmptyExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.And(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Return the conjuction of two expressions
            </summary>
            <param name="lhs">The Expression to use as the Left Hand Side.</param>
            <param name="rhs">The Expression to use as the Right Hand Side.</param>
            <returns>An <see cref="T:NHibernate.Expression.AndExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Or(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Return the disjuction of two expressions
            </summary>
            <param name="lhs">The Expression to use as the Left Hand Side.</param>
            <param name="rhs">The Expression to use as the Right Hand Side.</param>
            <returns>An <see cref="T:NHibernate.Expression.OrExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Not(NHibernate.Expression.ICriterion)">
            <summary>
            Return the negation of an expression
            </summary>
            <param name="expression">The Expression to negate.</param>
            <returns>A <see cref="T:NHibernate.Expression.NotExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(NHibernate.SqlCommand.SqlString,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Apply a constraint expressed in SQL, with the given SQL parameters
            </summary>
            <param name="sql"></param>
            <param name="values"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(NHibernate.SqlCommand.SqlString,System.Object,NHibernate.Type.IType)">
            <summary>
            Apply a constraint expressed in SQL, with the given SQL parameter
            </summary>
            <param name="sql"></param>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Apply a constraint expressed in SQL, with the given SQL parameter
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(NHibernate.SqlCommand.SqlString)">
            <summary>
            Apply a constraint expressed in SQL
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(System.String)">
            <summary>
            Apply a constraint expressed in SQL
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Conjunction">
            <summary>
            Group expressions together in a single conjunction (A and B and C...)
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Expression.Disjunction">
            <summary>
            Group expressions together in a single disjunction (A or B or C...)
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Expression.AllEq(System.Collections.IDictionary)">
            <summary>
            Apply an "equals" constraint to each property in the key set of a IDictionary
            </summary>
            <param name="propertyNameValues">a dictionary from property names to values</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Expression.GeExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "greater than or equal" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.GeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.GeExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.GeExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.GeExpression"/>.
            </summary>
            <value>The string "<c> &gt;= </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.GePropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "greater than or equal" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.GePropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.GePropertyExpression"/> class
            that compares two mapped properties using an "greater than or equal" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.GePropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LtPropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.GtExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "greater than" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.GtExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.GtExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.GtExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.GtExpression"/>.
            </summary>
            <value>The string "<c> &gt; </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.GtPropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "greater than" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.GtPropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.GtPropertyExpression"/> class
            that compares two mapped properties using an "greater than" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.GtPropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LtPropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.IdentifierEqExpression">
            <summary>
            An identifier constraint
            </summary>
        </member>
        <member name="T:NHibernate.Expression.InExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that constrains the property 
            to a specified list of values.
            </summary>
            <remarks>
            InExpression - should only be used with a Single Value column - no multicolumn properties...
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.InExpression.#ctor(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Expression.InExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.InsensitiveLikeExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "like" constraint
            that is <b>not</b> case sensitive.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.InsensitiveLikeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.InsensitiveLikeExpression"/> 
            class for a named Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Expression.InsensitiveLikeExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.IsEmptyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents empty association constraint.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.IsNotEmptyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents non-empty association constraint.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.LeExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "less than or equal" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.LeExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.LeExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LeExpression"/>.
            </summary>
            <value>The string "<c> &lt;= </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.LePropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "less than or equal" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LePropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.LePropertyExpression"/> class
            that compares two mapped properties using an "less than or equal" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.LePropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LePropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt;= </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.LikeExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "like" constraint.
            </summary>
            <remarks>
            The case sensitivity depends on the database settings for string 
            comparisons.  Use <see cref="T:NHibernate.Expression.InsensitiveLikeExpression"/> if the
            string comparison should not be case sensitive.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.LikeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.LikeExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.LikeExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LikeExpression"/>.
            </summary>
            <value>The string "<c> like </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.LtExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "less than" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LtExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.LtExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.LtExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LtExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.LtPropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "less than" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LtPropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.LtPropertyExpression"/> class
            that compares two mapped properties using an "less than" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.LtPropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LtPropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.MatchMode">
            <summary>
            Represents an strategy for matching strings using "like".
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.#ctor(System.Int32,System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode"/> class.
            </summary>
            <param name="intCode">The code that identifies the match mode.</param>
            <param name="name">The friendly name of the match mode.</param>
            <remarks>
            The parameter <c>intCode</c> is used as the key of <see cref="T:System.Collections.IDictionary"/>
            to store instances and to ensure only instance of a particular <see cref="T:NHibernate.Expression.MatchMode"/>
            is created.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.ToString">
            <summary>
            The string representation of the <see cref="T:NHibernate.Expression.MatchMode"/>.
            </summary>
            <returns>The friendly name used to describe the <see cref="T:NHibernate.Expression.MatchMode"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.ToMatchString(System.String)">
            <summary>
            Convert the pattern, by appending/prepending "%"
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>
            A <see cref="T:System.String"/> that contains a "%" in the appropriate place
            for the Match Strategy.
            </returns>
        </member>
        <member name="F:NHibernate.Expression.MatchMode.Exact">
            <summary>
            Match the entire string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Expression.MatchMode.Start">
            <summary>
            Match the start of the string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Expression.MatchMode.End">
            <summary>
            Match the end of the string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Expression.MatchMode.Anywhere">
            <summary>
            Match the pattern anywhere in the string
            </summary>
        </member>
        <member name="T:NHibernate.Expression.MatchMode.ExactMatchMode">
            <summary>
            The <see cref="T:NHibernate.Expression.MatchMode"/> that matches the entire string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.ExactMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode.ExactMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.ExactMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Exact MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> exactly the same as it was passed in.</returns>
        </member>
        <member name="T:NHibernate.Expression.MatchMode.StartMatchMode">
            <summary>
            The <see cref="T:NHibernate.Expression.MatchMode"/> that matches the start of the string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.StartMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode.StartMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.StartMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Start MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the end.</returns>
        </member>
        <member name="T:NHibernate.Expression.MatchMode.EndMatchMode">
            <summary>
            The <see cref="T:NHibernate.Expression.MatchMode"/> that matches the end of the string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.EndMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode.EndMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.EndMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the End MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the beginning.</returns>
        </member>
        <member name="T:NHibernate.Expression.MatchMode.AnywhereMatchMode">
            <summary>
            The <see cref="T:NHibernate.Expression.MatchMode"/> that exactly matches the string
            by appending "<c>%</c>" to the beginning and end.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.AnywhereMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode.AnywhereMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.AnywhereMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Exact MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the beginning and the end.</returns>
        </member>
        <member name="T:NHibernate.Expression.NotExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that negates another <see cref="T:NHibernate.Expression.ICriterion"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.NotExpression.#ctor(NHibernate.Expression.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.NotExpression"/> class for an
            <see cref="T:NHibernate.Expression.ICriterion"/>
            </summary>
            <param name="criterion">The <see cref="T:NHibernate.Expression.ICriterion"/> to negate.</param>
        </member>
        <member name="T:NHibernate.Expression.NotNullExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents "not null" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.NotNullExpression.#ctor(System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.NotNullExpression"/> class for a named
            Property that should not be null.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
        </member>
        <member name="T:NHibernate.Expression.NullExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents "null" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.NullExpression.#ctor(System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.NotNullExpression"/> class for a named
            Property that should be null.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
        </member>
        <member name="M:NHibernate.Expression.NullExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.Order">
            <summary>
            Represents an order imposed upon a <see cref="T:NHibernate.ICriteria"/>
            result set.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Order.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor for Order.
            </summary>
            <param name="propertyName"></param>
            <param name="ascending"></param>
        </member>
        <member name="M:NHibernate.Expression.Order.ToSqlString(NHibernate.ICriteria,NHibernate.Expression.ICriteriaQuery)">
            <summary>
            Render the SQL fragment
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Order.Asc(System.String)">
            <summary>
            Ascending order
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Order.Desc(System.String)">
            <summary>
            Descending order
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Expression.OrExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that combines two <see cref="T:NHibernate.Expression.ICriterion"/>s with an 
            <c>"or"</c> between them.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.OrExpression.#ctor(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.OrExpression"/> class for 
            two <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use as the left hand side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.OrExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Expression.Expression"/>s.
            </summary>
            <value>Returns "<c>or</c>"</value>
        </member>
        <member name="T:NHibernate.Expression.Projections">
            <summary>
            The <tt>criterion</tt> package may be used by applications as a framework for building
            new kinds of <tt>Projection</tt>. However, it is intended that most applications will
            simply use the built-in projection types via the static factory methods of this class.<br/>
            <br/>
            The factory methods that take an alias allow the projected value to be referred to by 
            criterion and order instances.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Projections.Distinct(NHibernate.Expression.IProjection)">
            <summary>
            Create a distinct projection from a projection
            </summary>
            <param name="proj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.ProjectionList">
            <summary>
            Create a new projection list
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.RowCount">
            <summary>
            The query row count, ie. <tt>count(*)</tt>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.Count(System.String)">
            <summary>
            A property value count
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.CountDistinct(System.String)">
            <summary>
            A distinct property value count
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.Max(System.String)">
            <summary>
            A property maximum value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.Min(System.String)">
            <summary>
            A property minimum value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.Avg(System.String)">
            <summary>
            A property average value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.Sum(System.String)">
            <summary>
            A property value sum
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.SqlProjection(System.String,System.String[],NHibernate.Type.IType[])">
            <summary>
            A SQL projection, a typed select clause fragment
            </summary>
            <param name="sql"></param>
            <param name="columnAliases"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.SqlGroupProjection(System.String,System.String,System.String[],NHibernate.Type.IType[])">
            <summary>
            A grouping SQL projection, specifying both select clause and group by clause fragments
            </summary>
            <param name="sql"></param>
            <param name="groupBy"></param>
            <param name="columnAliases"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.GroupProperty(System.String)">
            <summary>
            A grouping property value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.Property(System.String)">
            <summary>
            A projected property value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.Id">
            <summary>
            A projected identifier value
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Projections.Alias(NHibernate.Expression.IProjection,System.String)">
            <summary>
            Assign an alias to a projection, by wrapping it
            </summary>
            <param name="projection"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Expression.Property">
            <summary>
            A factory for property-specific  AbstractCriterion  and projection instances
            </summary>
        </member>
        <member name="T:NHibernate.Expression.PropertyProjection">
            <summary>
            A property value, or grouped property value
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Property.GetProperty(System.String)">
            <summary>
            Get a component attribute of this property
            </summary>
        </member>
        <member name="T:NHibernate.Expression.PropertySubqueryExpression">
            <summary>
            A comparison between a property value in the outer query and the
             result of a subquery
            </summary>
        </member>
        <member name="T:NHibernate.Expression.SimpleSubqueryExpression">
            <summary>
            A comparison between a constant value and the the result of a subquery
            </summary>
        </member>
        <member name="T:NHibernate.Expression.SQLCriterion">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that creates a SQLExpression.
            The string {alias} will be replaced by the alias of the root entity.
            </summary>
            <remarks>
            This allows for database specific Expressions at the cost of needing to 
            write a correct <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.SQLCriterion.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.SQLProjection">
            <summary>
            A SQL fragment. The string {alias} will be replaced by the alias of the root entity.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.Subqueries">
            <summary>
            Factory class for AbstractCriterion instances that represent 
            involving subqueries.
            <c>Expression</c>
            <c>Projection</c>
            <c>AbstractCriterion</c>
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.ClassicQueryTranslatorFactory">
            <summary>
            Generates translators which uses the older hand-written parser to perform the translation.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.IQueryTranslatorFactory">
            <summary>
            Facade for generation of <see cref="T:NHibernate.Hql.IQueryTranslator"/> 
            and <see cref="T:NHibernate.Hql.IFilterTranslator"/> instances.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslatorFactory.CreateQueryTranslator(System.String,System.Collections.IDictionary,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Construct a <see cref="T:NHibernate.Hql.IQueryTranslator"/> instance 
            capable of translating an HQL query string.
            </summary>
            <param name="queryString">The query string to be translated</param>
            <param name="filters">Currently enabled filters</param>
            <param name="factory">The session factory</param>
            <returns>An appropriate translator.</returns>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslatorFactory.CreateFilterTranslator(System.String,System.Collections.IDictionary,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Construct a <see cref="T:NHibernate.Hql.IFilterTranslator"/> instance capable of 
            translating an HQL filter string.
            </summary>
            <param name="queryString">The query string to be translated</param>
            <param name="filters">Currently enabled filters</param>
            <param name="factory">The session factory</param>
            <returns>An appropriate translator.</returns>
        </member>
        <member name="T:NHibernate.Hql.Classic.ClauseParser">
            <summary> 
            Parses the hibernate query into its constituent clauses.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.IParser">
            <summary> 
            A parser is a state machine that accepts a string of tokens,
            bounded by start() and end() and modifies a QueryTranslator. Parsers
            are NOT intended to be threadsafe. They SHOULD be reuseable
            for more than one token stream.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.IParser.Token(System.String,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.IParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.IParser.End(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="T:NHibernate.Hql.Classic.FromParser">
            <summary> 
            Parses the from clause of a hibernate query, looking for tables and
            aliases for the SQL query.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.FromParser.#cctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.FromPathExpressionParser">
            <summary>
            FromPathExpressionParser
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.PathExpressionParser">
            <summary> 
            Parses an expression of the form foo.bar.baz and builds up an expression
            involving two less table joins than there are path components.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.DereferenceEntity(System.String,NHibernate.Type.EntityType,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <param name="propertyType"></param>
            <param name="q"></param>
            <remarks>NOTE: we avoid joining to the next table if the named property is just the foreign key value</remarks>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.CurrentColumns">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.End(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.LastCollectionElement">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.SetLastCollectionElementIndexValue(NHibernate.SqlCommand.SqlString)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.SetExpectingCollectionIndex">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.GetCollectionSubquery(System.Collections.IDictionary)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.AddAssociation(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.AddFromAssociation(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.AddFromCollection(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.Classic.PathExpressionParser.Fetch(NHibernate.Hql.Classic.QueryTranslator,System.String)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="entityName"></param>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.PropertyType">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.IsExpectingCollectionIndex">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.WhereColumn">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.WhereColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.WhereColumnType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.IsCollectionValued">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CollectionName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CollectionRole">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CollectionOwnerName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CurrentName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CurrentProperty">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.PathExpressionParser.CollectionElement">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.Classic.PathExpressionParser.CollectionElement.Type">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.Classic.PathExpressionParser.CollectionElement.IsOneToMany">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.Classic.PathExpressionParser.CollectionElement.Alias">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.Classic.PathExpressionParser.CollectionElement.ElementColumns">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.Classic.PathExpressionParser.CollectionElement.JoinSequence">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.Classic.PathExpressionParser.CollectionElement.IndexValue">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.FromPathExpressionParser.End(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.FromPathExpressionParser.SetExpectingCollectionIndex">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.GroupByParser">
            <summary> 
            Parses the GROUP BY clause of an aggregate query
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.GroupByParser.#ctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.HavingParser">
            <summary> 
            Parses the having clause of a hibernate query and translates it to an
            SQL having clause.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.WhereParser">
            <summary> Parses the where clause of a hibernate query and translates it to an
            SQL where clause.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.WhereParser.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.WhereParser.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.WhereParser.Token(System.String,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.WhereParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.WhereParser.End(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.WhereParser.AppendToken(NHibernate.Hql.Classic.QueryTranslator,System.String)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="token"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.WhereParser.AppendToken(NHibernate.Hql.Classic.QueryTranslator,NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="token"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.HavingParser.AppendToken(NHibernate.Hql.Classic.QueryTranslator,System.String)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="token"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.HavingParser.AppendToken(NHibernate.Hql.Classic.QueryTranslator,NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="token"></param>
        </member>
        <member name="T:NHibernate.Hql.Classic.OrderByParser">
            <summary> 
            Parses the ORDER BY clause of a query
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.OrderByParser.Token(System.String,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="T:NHibernate.Hql.Classic.ParserHelper">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.PreprocessingParser">
            <summary>HQL lexical analyzer (not really a parser)</summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.PreprocessingParser.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.PreprocessingParser.#ctor(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="replacements"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.PreprocessingParser.Token(System.String,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.PreprocessingParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.PreprocessingParser.End(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="T:NHibernate.Hql.Classic.QueryTranslator">
            <summary> 
            An instance of <c>QueryTranslator</c> translates a Hibernate query string to SQL.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Loader">
            <summary>
            Abstract superclass of object loading (and querying) strategies.
            </summary>
            <remarks>
            <p>
            This class implements useful common functionality that concrete loaders would delegate to.
            It is not intended that this functionality would be directly accessed by client code (Hence,
            all methods of this class are declared <c>protected</c> or <c>private</c>.) This class relies heavily upon the
            <see cref="T:NHibernate.Persister.Entity.ILoadable"/> interface, which is the contract between this class and 
            <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/>s that may be loaded by it.
            </p>
            <p>
            The present implementation is able to load any number of columns of entities and at most 
            one collection role per query.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetLockModes(System.Collections.IDictionary)">
            <summary>
            What lock mode does this load entities with?
            </summary>
            <param name="lockModes">A Collection of lock modes specified dynamically via the Query Interface</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.ApplyLocks(NHibernate.SqlCommand.SqlString,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Append <c>FOR UPDATE OF</c> clause, if necessary. This
            empty superclass implementation merely returns its first
            argument.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.UpgradeLocks">
            <summary>
            Does this query return objects that might be already cached by 
            the session, whose lock mode may need upgrading.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.PreprocessSQL(NHibernate.SqlCommand.SqlString,NHibernate.Engine.QueryParameters,NHibernate.Dialect.Dialect)">
            <summary>
            Modify the SQL, adding lock hints and comments, if necessary
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.DoQueryAndInitializeNonLazyCollections(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,System.Boolean)">
            <summary>
            Execute an SQL query and attempt to instantiate instances of the class mapped by the given
            persister from each row of the <c>DataReader</c>. If an object is supplied, will attempt to
            initialize that object. If a collection is supplied, attempt to initialize that collection.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadSingleRow(System.Data.IDataReader,NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,System.Boolean)">
            <summary>
            Loads a single row from the result set.  This is the processing used from the
            ScrollableResults where no collection fetches were encountered.
            </summary>
            <param name="resultSet">The result set from which to do the load.</param>
            <param name="session">The session from which the request originated.</param>
            <param name="queryParameters">The query parameters specified by the user.</param>
            <param name="returnProxies">Should proxies be generated</param>
            <returns>The loaded "row".</returns>
            <exception cref="T:NHibernate.HibernateException"/>
        </member>
        <member name="M:NHibernate.Loader.Loader.ReadCollectionElements(System.Object[],System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read any collection elements contained in a single row of the result set
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetResultColumnOrRow(System.Object[],NHibernate.Transform.IResultTransformer,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the actual object that is returned in the user-visible result list.
            </summary>
            <remarks>
            This empty implementation merely returns its first argument. This is
            overridden by some subclasses.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.RegisterNonExists(NHibernate.Engine.EntityKey[],NHibernate.Persister.Entity.ILoadable[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            For missing objects associated by one-to-one with another object in the
            result set, register the fact that the the object is missing with the
            session.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.ReadCollectionElement(System.Object,System.Object,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read one collection element from the current row of the ADO.NET result set
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.HandleEmptyCollections(System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            If this is a collection initializer, we need to tell the session that a collection
            is being initilized, to account for the possibility of the collection having
            no elements (hence no rows in the result set).
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetKeyFromResultSet(System.Int32,NHibernate.Persister.Entity.ILoadable,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read a row of <c>EntityKey</c>s from the <c>IDataReader</c> into the given array.
            </summary>
            <remarks>
            Warning: this method is side-effecty. If an <c>id</c> is given, don't bother going
            to the <c>IDataReader</c>
            </remarks>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="rs"></param>
            <param name="session"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.CheckVersion(System.Int32,NHibernate.Persister.Entity.ILoadable,System.Object,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Check the version of the object in the <c>IDataReader</c> against
            the object version in the session cache, throwing an exception
            if the vesrion numbers are different.
            </summary>
            <param name="i"></param>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="version"></param>
            <param name="rs"></param>
            <param name="session"></param>
            <exception cref="T:NHibernate.StaleObjectStateException"></exception>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetRow(System.Data.IDataReader,NHibernate.Persister.Entity.ILoadable[],NHibernate.Engine.EntityKey[],System.Object,NHibernate.Engine.EntityKey,NHibernate.LockMode[],System.Collections.IList,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Resolve any ids for currently loaded objects, duplications within the <c>IDataReader</c>,
            etc. Instanciate empty objects to be initialized from the <c>IDataReader</c>. Return an
            array of objects (a row of results) and an array of booleans (by side-effect) that determine
            wheter the corresponding object should be initialized
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.InstanceAlreadyLoaded(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.ILoadable,NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            The entity instance is already in the session cache
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.InstanceNotYetLoaded(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.ILoadable,NHibernate.Engine.EntityKey,NHibernate.LockMode,NHibernate.Engine.EntityKey,System.Object,System.Collections.IList,NHibernate.Engine.ISessionImplementor)">
            <summary>
            The entity instance is not in the session cache
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadFromResultSet(System.Data.IDataReader,System.Int32,System.Object,System.Type,NHibernate.Engine.EntityKey,NHibernate.LockMode,NHibernate.Persister.Entity.ILoadable,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Hydrate the state of an object from the SQL <c>IDataReader</c>, into
            an array of "hydrated" values (do not resolve associations yet),
            and pass the hydrated state to the session.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetInstanceClass(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.ILoadable,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine the concrete class of an instance for the <c>IDataReader</c>
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.Hydrate(System.Data.IDataReader,System.Object,System.Object,NHibernate.Persister.Entity.ILoadable,NHibernate.Engine.ISessionImplementor,System.String[][])">
            <summary>
            Unmarshall the fields of a persistent instance from a result set,
            without resolving associations or collections
            </summary>
            <param name="rs"></param>
            <param name="id"></param>
            <param name="obj"></param>
            <param name="persister"></param>
            <param name="session"></param>
            <param name="suffixedPropertyColumns"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.Advance(System.Data.IDataReader,NHibernate.Engine.RowSelection)">
            <summary>
            Advance the cursor to the first required row of the <c>IDataReader</c>
            </summary>
            <param name="rs"></param>
            <param name="selection"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.UseLimit(NHibernate.Engine.RowSelection,NHibernate.Dialect.Dialect)">
            <summary>
            Should we pre-process the SQL string, adding a dialect-specific
            LIMIT clause.
            </summary>
            <param name="selection"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.BindPositionalParameters(System.Data.IDbCommand,NHibernate.Engine.QueryParameters,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind positional parameter values to the <c>IDbCommand</c>
            (these are parameters specified by ?).
            </summary>
            <param name="st"></param>
            <param name="queryParameters"></param>
            <param name="start"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.PrepareQueryCommand(NHibernate.Engine.QueryParameters,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Obtain an <c>IDbCommand</c> with all parameters pre-bound. Bind positional parameters,
            named parameters, and limit parameters.
            </summary>
            <remarks>
            Creates an IDbCommand object and populates it with the values necessary to execute it against the 
            database to Load an Entity.
            </remarks>
            <param name="parameters">The <see cref="T:NHibernate.Engine.QueryParameters"/> to use for the IDbCommand.</param>
            <param name="scroll">TODO: find out where this is used...</param>
            <param name="session">The SessionImpl this Command is being prepared in.</param>
            <returns>A CommandWrapper wrapping an IDbCommand that is ready to be executed.</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetMaxOrLimit(NHibernate.Dialect.Dialect,NHibernate.Engine.RowSelection)">
            <summary>
            Some dialect-specific LIMIT clauses require the maximum last row number,
            others require the maximum returned row count.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.BindLimitParameters(System.Data.IDbCommand,System.Int32,NHibernate.Engine.RowSelection,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind parameters needed by the dialect-specific LIMIT clause
            </summary>
            <returns>The number of parameters bound</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.SetMaxRows(System.Data.IDbCommand,NHibernate.Engine.RowSelection)">
            <summary>
            Limits the number of rows returned by the Sql query if necessary.
            </summary>
            <param name="st">The IDbCommand to limit.</param>
            <param name="selection">The RowSelection that contains the MaxResults info.</param>
            <remarks>TODO: This does not apply to ADO.NET at all</remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetResultSet(System.Data.IDbCommand,NHibernate.Engine.RowSelection,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Fetch a <c>IDbCommand</c>, call <c>SetMaxRows</c> and then execute it,
            advance to the first result and return an SQL <c>IDataReader</c>
            </summary>
            <param name="st">The <see cref="T:System.Data.IDbCommand"/> to execute.</param>
            <param name="selection">The <see cref="T:NHibernate.Engine.RowSelection"/> to apply to the <see cref="T:System.Data.IDbCommand"/> and <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="session">The <see cref="T:NHibernate.ISession"/> to load in.</param>
            <returns>An IDataReader advanced to the first record in RowSelection.</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.BindNamedParameters(System.Data.IDbCommand,System.Collections.IDictionary,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind named parameters to the <c>IDbCommand</c>
            </summary>
            <param name="st">The <see cref="T:System.Data.IDbCommand"/> that contains the parameters.</param>
            <param name="namedParams">The named parameters (key) and the values to set.</param>
            <param name="session">The <see cref="T:NHibernate.ISession"/> this Loader is using.</param>
            <param name="start"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadEntity(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType,System.Object,System.Type,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Called by subclasses that load entities
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadEntityBatch(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType,System.Object,System.Type,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Called by subclasses that batch load entities
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollection(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType)">
            <summary>
            Called by subclasses that load collections
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollectionBatch(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType)">
            <summary>
            Called by wrappers that batch initialize collections
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollectionSubselect(NHibernate.Engine.ISessionImplementor,System.Object[],System.Object[],NHibernate.Type.IType[],System.Collections.IDictionary,NHibernate.Type.IType)">
            <summary>
            Called by subclasses that batch initialize collections
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.List(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,Iesi.Collections.ISet,NHibernate.Type.IType[])">
            <summary>
            Return the query results, using the query cache, called
            by subclasses that implement cacheable queries
            </summary>
            <param name="session"></param>
            <param name="queryParameters"></param>
            <param name="querySpaces"></param>
            <param name="resultTypes"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.DoList(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters)">
            <summary>
            Actually execute a query, ignoring the query cache
            </summary>
            <param name="session"></param>
            <param name="queryParameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.PostInstantiate">
            <summary>
            Calculate and cache select-clause suffixes. Must be
            called by subclasses after instantiation.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetParameterTypes(NHibernate.Engine.QueryParameters,System.Boolean,System.Boolean)">
            <returns><see cref="T:System.Collections.IList"/> of <see cref="T:NHibernate.Type.IType"/></returns>
        </member>
        <member name="P:NHibernate.Loader.Loader.SqlString">
            <summary>
            The SqlString to be called; implemented by all subclasses
            </summary>
            <remarks>
            <para>
            The <c>setter</c> was added so that class inheriting from Loader could write a 
            value using the Property instead of directly to the field.
            </para>
            <para>
            The scope is <c>protected internal</c> because the <see cref="T:NHibernate.Hql.Classic.WhereParser"/> needs to
            be able to <c>get</c> the SqlString of the <see cref="T:NHibernate.Hql.Classic.QueryTranslator"/> when
            it is parsing a subquery.
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Loader.Loader.EntityPersisters">
            <summary>
            An array of persisters of entity classes contained in each row of results;
            implemented by all subclasses
            </summary>
            <remarks>
            The <c>setter</c> was added so that classes inheriting from Loader could write a 
            value using the Property instead of directly to the field.
            </remarks>
        </member>
        <member name="P:NHibernate.Loader.Loader.Owners">
            <summary>
            An array of indexes of the entity that owns a one-to-one association
            to the entity at the given index (-1 if there is no "owner")
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.CollectionPersisters">
            <summary>
            An (optional) persister for a collection to be initialized; only collection loaders
            return a non-null value
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.CollectionOwners">
            <summary>
            Get the index of the entity that owns the collection, or -1
            if there is no owner in the query results (i.e. in the case of a 
            collection initializer) or no collection.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.IsSingleRowLoader">
            <summary>
            Return false is this loader is a batch entity loader
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.Aliases">
            <summary>
            Get the SQL table aliases of entities whose
            associations are subselect-loadable, returning
            null if this loader does not support subselect
            loading
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.EntityAliases">
            <summary>
            Get the result set descriptor
            </summary>
        </member>
        <member name="M:NHibernate.Loader.BasicLoader.GenerateSuffixes(System.Int32)">
            <summary>
            Utility method that generates 0_, 1_ suffixes. Subclasses don't
            necessarily need to use this algorithm, but it is intended that
            they will in most cases.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.IFilterTranslator">
            <summary> 
            Specialized interface for filters.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.IQueryTranslator">
            <summary>
            Defines the constract of an HQL->SQL translator.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.Compile(System.Collections.IDictionary,System.Boolean)">
            <summary>
            Compile a "normal" query. This method may be called multiple times. Subsequent invocations are no-ops.
            </summary>
            <param name="replacements">Defined query substitutions.</param>
            <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
            <exception cref="T:NHibernate.QueryException">There was a problem parsing the query string.</exception>
            <exception cref="T:NHibernate.MappingException">There was a problem querying defined mappings.</exception>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.List(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters)">
            <summary>
            Perform a list operation given the underlying query definition.
            </summary>
            <param name="session">The session owning this query.</param>
            <param name="queryParameters">The query bind parameters.</param>
            <returns>The query list results.</returns>
            <exception cref="T:NHibernate.HibernateException"></exception>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.ExecuteUpdate(NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform a bulk update/delete operation given the underlying query defintion.
            </summary>
            <param name="queryParameters">The query bind parameters.</param>
            <param name="session">The session owning this query.</param>
            <returns>The number of entities updated or deleted.</returns>
            <exception cref="T:NHibernate.HibernateException"></exception>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.GetColumnNames">
            <summary>
            Returns the column names in the generated SQL.
            </summary>
            <returns>the column names in the generated SQL.</returns>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.GetParameterTranslations">
            <summary>
            Information about any parameters encountered during translation.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.QuerySpaces">
            <summary>
            The set of query spaces (table names) that the query referrs to.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.SQLString">
            <summary>
            The SQL string generated by the translator.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.QueryString">
            <summary>
            The HQL string processed by the translator.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.EnabledFilters">
            <summary>
            Returns the filters enabled for this query translator.
            </summary>
            <returns>Filters enabled for this query execution.</returns>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.ReturnTypes">
            <summary>
            Returns an array of Types represented in the query result.
            </summary>
            <returns>Query return types.</returns>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.ReturnAliases">
            <summary>
            Returns an array of HQL aliases
            </summary>
            <returns>Returns an array of HQL aliases</returns>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.ContainsCollectionFetches">
            <summary>
            Does the translated query contain collection fetches?
            </summary>
            <returns>True if the query does contain collection fetched; false otherwise.</returns>
        </member>
        <member name="M:NHibernate.Hql.IFilterTranslator.Compile(System.String,System.Collections.IDictionary,System.Boolean)">
            <summary> 
            Compile a filter. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
            <param name="collectionRole">the role name of the collection used as the basis for the filter.</param>
            <param name="replacements">Defined query substitutions.</param>
            <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
        </member>
        <member name="M:NHibernate.Hql.Classic.QueryTranslator.#ctor(NHibernate.Engine.ISessionFactoryImplementor,System.String,System.Collections.IDictionary)">
            <summary> 
            Construct a query translator
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.QueryTranslator.Compile(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            Compile a subquery
            </summary>
            <param name="superquery"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.QueryTranslator.Compile(System.Collections.IDictionary,System.Boolean)">
            <summary>
            Compile a "normal" query. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.QueryTranslator.Compile(System.String,System.Collections.IDictionary,System.Boolean)">
            <summary>
            Compile a filter. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.QueryTranslator.Compile">
            <summary> 
            Compile the query (generate the SQL).
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.QueryTranslator.RenderScalarSelect">
            <summary> 
            WARNING: side-effecty
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.QueryTranslator.AddFromAssociation(System.String,System.String)">
            <remarks>Used for collection filters</remarks>
        </member>
        <member name="M:NHibernate.Hql.Classic.QueryTranslator.#cctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.QueryTranslator.EntityPersisters">
            <summary>
            Persisters for the return values of a <c>Find</c> style query
            </summary>
            <remarks>
            The <c>Persisters</c> stored by QueryTranslator have to be <see cref="T:NHibernate.Persister.Entity.IQueryable"/>.  The
            <c>setter</c> will attempt to cast the <c>ILoadable</c> array passed in into an 
            <c>IQueryable</c> array.
            </remarks>
        </member>
        <member name="P:NHibernate.Hql.Classic.QueryTranslator.ReturnTypes">
             <summary>
            Types of the return values of an <c>Enumerate()</c> style query.
            Return an array of <see cref="T:NHibernate.Type.IType"/>s.
             </summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.QueryTranslator.SqlString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.QueryTranslator.IsShallowQuery">
            <summary>
            Is this query called by Scroll() or Iterate()?
            </summary>
            <value>true if it is, false if it is called by find() or list()</value>
        </member>
        <member name="P:NHibernate.Hql.Classic.QueryTranslator.IsSubquery">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.QueryTranslator.Owners">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.Classic.SelectParser">
            <summary>
            Parsers the select clause of a hibernate query, looking
            for a table (well, really class) alias.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectParser.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectParser.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectParser.Token(System.String,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectParser.AggregateHasArgs(System.String,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="funcToken"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectParser.AggregateFuncNoArgsHasParenthesis(System.String,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="funcToken"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectParser.AggregateType(System.Collections.ArrayList,NHibernate.Type.IType,NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="funcTokenList"></param>
            <param name="type"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectParser.End(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="T:NHibernate.Hql.Classic.SelectPathExpressionParser">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectPathExpressionParser.End(NHibernate.Hql.Classic.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.Classic.SelectPathExpressionParser.SetExpectingCollectionIndex">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.Classic.SelectPathExpressionParser.SelectName">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.Util.SessionFactoryHelper">
            <summary>
            Wraps SessionFactoryImpl, adding more lookup behaviors and encapsulating some of the error handling.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.NameGenerator">
            <summary>
            Provides utility methods for generating HQL / SQL names.
            Shared by both the 'classic' and 'new' query translators.
            </summary>
        </member>
        <member name="T:NHibernate.QueryException">
            <summary>
            A problem occurred translating a Hibernate query to SQL due to invalid query syntax, etc.
            </summary>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="queryString">The query that contains the error.</param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.QueryException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.QueryException.QueryString">
            <summary>
            Gets or sets the <see cref="T:System.String"/> of HQL that caused the Exception.
            </summary>
        </member>
        <member name="P:NHibernate.QueryException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.QueryException"/>.
            </summary>
            <value>The error message that explains the reason for this exception including the HQL.</value>
        </member>
        <member name="M:NHibernate.Hql.QuerySplitter.ConcreteQueries(System.String,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Handle Hibernate "implicit" polymorphism, by translating the query string into 
            several "concrete" queries against mapped classes.
            </summary>
            <param name="query"></param>
            <param name="factory"></param>
            <returns></returns>
            <exception cref="T:NHibernate.MappingException"/>
        </member>
        <member name="T:NHibernate.Id.Assigned">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns the current identifier
            assigned to an instance.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="assigned" /&gt;</code>
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IIdentifierGenerator">
            <summary>
            The general contract between a class that generates unique
            identifiers and the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <remarks>
            <para>
            It is not intended that this interface ever be exposed to the 
            application.  It <b>is</b> intended that users implement this interface
            to provide custom identifier generation strategies.
            </para>
            <para>
            Implementors should provide a public default constructor.
            </para>
            <para>
            Implementations that accept configuration parameters should also
            implement <see cref="T:NHibernate.Id.IConfigurable"/>.
            </para>
            <para>
            Implementors <b>must</b> be threadsafe.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IIdentifierGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new identifier
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier</returns>
        </member>
        <member name="F:NHibernate.Id.Assigned.Instance">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Id.Assigned.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generates a new identifier by getting the value of the identifier
            for the <c>obj</c> parameter.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The value that was assigned to the mapped <c>id</c>'s property.</returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            Thrown when a <see cref="T:NHibernate.Collection.IPersistentCollection"/> is passed in as the <c>obj</c> or
            if the identifier of <c>obj</c> is null.
            </exception>
        </member>
        <member name="T:NHibernate.Id.CounterGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a <c>Int64</c> constructed from the system
            time and a counter value. Not safe for use in a clustser!
            </summary>
        </member>
        <member name="T:NHibernate.Id.ForeignGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that uses the value of 
            the id property of an associated object
            </summary>
            <remarks>
            <para>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="foreign"&gt;
            	&lt;param name="property"&gt;AssociatedObject&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </para>
            The mapping parameter <c>property</c> is required.
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IConfigurable">
            <summary>
            An <c>IdentiferGenerator</c> that supports "configuration".
            </summary>
        </member>
        <member name="M:NHibernate.Id.IConfigurable.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configure this instance, given the values of parameters
            specified by the user as <c>&lt;param&gt;</c> elements.
            This method is called just once, followed by instantiation.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.ForeignGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generates an identifer from the value of a Property. 
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>
            The identifier value from the associated object or  
            <see cref="F:NHibernate.Id.IdentifierGeneratorFactory.ShortCircuitIndicator"/> if the <c>session</c>
            already contains <c>obj</c>.
            </returns>
        </member>
        <member name="M:NHibernate.Id.ForeignGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the ForeignGenerator by reading the value of <c>property</c> 
            from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
            <exception cref="T:NHibernate.MappingException">
            Thrown if the key <c>property</c> is not found in the <c>parms</c> parameter.
            </exception>
        </member>
        <member name="T:NHibernate.Id.GuidCombGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <see cref="T:System.Guid"/> values 
            using a strategy suggested Jimmy Nilsson's 
            <a href="http://www.informit.com/articles/article.asp?p=25862">article</a>
            on <a href="http://www.informit.com">informit.com</a>. 
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="guid.comb" /&gt;</code>
            </p>
            <p>
            The <c>comb</c> algorithm is designed to make the use of GUIDs as Primary Keys, Foreign Keys, 
            and Indexes nearly as efficient as ints.
            </p>
            <p>
            This code was contributed by Donald Mull.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.GuidCombGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.Guid"/> using the comb algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Guid"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.GuidCombGenerator.GenerateComb">
            <summary>
            Generate a new <see cref="T:System.Guid"/> using the comb algorithm.
            </summary>
        </member>
        <member name="T:NHibernate.Id.GuidGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <see cref="T:System.Guid"/> values 
            using <see cref="M:System.Guid.NewGuid">Guid.NewGuid()</see>. 
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="guid" /&gt;</code>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.GuidGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.Guid"/> for the identifier.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Guid"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.IdentifierGenerationException">
            <summary>
            Thrown by <see cref="T:NHibernate.Id.IIdentifierGenerator"/> implementation class when ID generation fails
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="e">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Id.IdentifierGeneratorFactory">
            <summary>
            Factory methods for <c>IdentifierGenerator</c> framework.
            </summary>
            <remarks>
            <p>The built in strategies for identifier generation in NHibernate are:</p>
            <list type="table">
            	<listheader>
            		<term>strategy</term>
            		<description>Implementation of strategy</description>
            	</listheader>
            	<item>
            		<term>assigned</term>
            		<description><see cref="T:NHibernate.Id.Assigned"/></description>
            	</item>
            	<item>
            		<term>counter</term>
            		<description><see cref="T:NHibernate.Id.CounterGenerator"/></description>
            	</item>
            	<item>
            		<term>foreign</term>
            		<description><see cref="T:NHibernate.Id.ForeignGenerator"/></description>
            	</item>
            	<item>
            		<term>guid</term>
            		<description><see cref="T:NHibernate.Id.GuidGenerator"/></description>
            	</item>
            	<item>
            		<term>guid.comb</term>
            		<description><see cref="T:NHibernate.Id.GuidCombGenerator"/></description>
            	</item>
            	<item>
            		<term>hilo</term>
            		<description><see cref="T:NHibernate.Id.TableHiLoGenerator"/></description>
            	</item>
            	<item>
            		<term>identity</term>
            		<description><see cref="T:NHibernate.Id.IdentityGenerator"/></description>
            	</item>
            	<item>
            		<term>native</term>
            		<description>
            			Chooses between <see cref="T:NHibernate.Id.IdentityGenerator"/>, <see cref="T:NHibernate.Id.SequenceGenerator"/>
            			, and <see cref="T:NHibernate.Id.TableHiLoGenerator"/> based on the 
            			<see cref="T:NHibernate.Dialect.Dialect"/>'s capabilities.
            		</description>
            	</item>
            	<item>
            		<term>seqhilo</term>
            		<description><see cref="T:NHibernate.Id.SequenceHiLoGenerator"/></description>
            	</item>
            	<item>
            		<term>sequence</term>
            		<description><see cref="T:NHibernate.Id.SequenceGenerator"/></description>
            	</item>
            	<item>
            		<term>uuid.hex</term>
            		<description><see cref="T:NHibernate.Id.UUIDHexGenerator"/></description>
            	</item>
            	<item>
            		<term>uuid.string</term>
            		<description><see cref="T:NHibernate.Id.UUIDStringGenerator"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.Get(System.Data.IDataReader,NHibernate.Type.IType,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Gets the value of the identifier from the <see cref="T:System.Data.IDataReader"/> and
            ensures it is the correct <see cref="T:System.Type"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> to read the identifier value from.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IIdentifierType"/> the value should be converted to.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the value is retrieved in.</param>
            <returns>
            The value for the identifier.
            </returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            Thrown if there is any problem getting the value from the <see cref="T:System.Data.IDataReader"/>
            or with converting it to the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.idgenerators">
            <summary>
            An <see cref="T:System.Collections.Hashtable"/> where the <c>key</c> is the strategy and 
            the <c>value</c> is the <see cref="T:System.Type"/> for the strategy.
            </summary>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.ShortCircuitIndicator">
            <summary>
            When this is returned by <c>Generate()</c> it indicates that the object
            has already been saved.
            </summary>
            <value>
            <see cref="F:System.String.Empty">String.Empty</see>
            </value>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.IdentityColumnIndicator">
            <summary>
            When this is return
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.#cctor">
            <summary>
            Initializes the static fields in <see cref="T:NHibernate.Id.IdentifierGeneratorFactory"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.Create(System.String,NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Creates an <see cref="T:NHibernate.Id.IIdentifierGenerator"/> from the named strategy.
            </summary>
            <param name="strategy">
            The name of the generator to create.  This can be one of the NHibernate abbreviations (ie - <c>native</c>, 
            <c>sequence</c>, <c>guid.comb</c>, etc...), a full class name if the Type is in the NHibernate assembly, or
            a full type name if the strategy is in an external assembly.
            </param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> that the retured identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of <c>&lt;param&gt;</c> values from the mapping.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
            <returns>
            An instantiated and configured <see cref="T:NHibernate.Id.IIdentifierGenerator"/>.
            </returns>
            <exception cref="T:NHibernate.MappingException">
            Thrown if there are any exceptions while creating the <see cref="T:NHibernate.Id.IIdentifierGenerator"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.CreateNumber(System.Int64,System.Type)">
            <summary>
            Create the correct boxed <see cref="T:System.Type"/> for the identifier.
            </summary>
            <param name="value">The value of the new identifier.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <returns>
            The identifier value converted to the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            The <c>type</c> parameter must be an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>,
            or <see cref="T:System.Int64"/>.
            </exception>
        </member>
        <member name="T:NHibernate.Id.IdentityGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that indicates to the <see cref="T:NHibernate.ISession"/> that identity
            (ie. identity/autoincrement column) key generation should be used.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="identity" /&gt;</code> 
            or if the database natively supports identity columns 
            <code>&lt;generator class="native" /&gt;</code>
            </p>
            <p>
            This indicates to NHibernate that the database generates the id when
            the entity is inserted.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IdentityGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            The IdentityGenerator for autoincrement/identity key generation.
            
            </summary>
            <param name="s">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity the id is being generated for.</param>
            <returns>
            <c>IdentityColumnIndicator</c> Indicates to the Session that identity (i.e. identity/autoincrement column)
            key generation should be used.
            </returns>
        </member>
        <member name="T:NHibernate.Id.IncrementGenerator">
            <summary>
            An <c>IIdentifierGenerator</c> that returns a <c>Int64</c>, constructed by
            counting from the maximum primary key value at startup. Not safe for use in a
            cluster!
            </summary>
            <remarks>
            <para>
            java author Gavin King, .NET port Mark Holden
            </para>
            <para>
            Mapping parameters supported, but not usually needed: table, column.
            </para>
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IPersistentIdentifierGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that requires creation of database objects
            All <see cref="T:NHibernate.Id.IPersistentIdentifierGenerator"/>s that also implement 
            An <see cref="T:NHibernate.Id.IConfigurable"/>  have access to a special mapping parameter: schema
            </summary>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the underlying database objects
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the sql to create the 
            necessary database objects.
            </returns>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects.
            </returns>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects.
            </summary>
            <returns>
            A key unique to the underlying database objects.
            </returns>
            <remarks>
            Prevents us from trying to create/remove them multiple times
            </remarks>
        </member>
        <member name="F:NHibernate.Id.IncrementGenerator.Column">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Id.IncrementGenerator.Table">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Id.IncrementGenerator.Schema">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
             <summary>
            
             </summary>
             <param name="type"></param>
             <param name="parms"></param>
             <param name="d"></param>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
             <summary>
            
             </summary>
             <param name="session"></param>
             <param name="obj"></param>
             <returns></returns>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
             <summary>
            
             </summary>
             <param name="dialect"></param>
             <returns></returns>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
             <summary>
            
             </summary>
             <param name="dialect"></param>
             <returns></returns>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.GeneratorKey">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Id.SequenceGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <c>Int64</c> values using an 
            oracle-style sequence. A higher performance algorithm is 
            <see cref="T:NHibernate.Id.SequenceHiLoGenerator"/>.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="sequence"&gt;
            	&lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>sequence</c> parameter is required while the <c>schema</c> is optional.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.SequenceGenerator.Sequence">
            <summary>
            The name of the sequence parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.SequenceGenerator.Schema">
            <summary>
            The name of the schema parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the SequenceGenerator by reading the value of <c>sequence</c> and
            <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by using a database sequence.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the database objects for a SequenceGenerator.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the Dialect specific sql to 
            create the necessary database objects for the SequenceGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects for a SequenceGenerator.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects for the SequenceGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects for a SequenceGenerator.
            </summary>
            <returns>
            The configured sequence name.
            </returns>
        </member>
        <member name="T:NHibernate.Id.SequenceHiLoGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that combines a hi/lo algorithm with an underlying
            oracle-style sequence that generates hi values.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="seqhilo"&gt;
            	&lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
            	&lt;param name="max_lo"&gt;max_lo_value&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>sequence</c> parameter is required, the <c>max_lo</c> and <c>schema</c> are optional.
            </p>
            <p>
            The user may specify a <c>max_lo</c> value to determine how often new hi values are
            fetched. If sequences are not avaliable, <c>TableHiLoGenerator</c> might be an
            alternative.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.SequenceHiLoGenerator.MaxLo">
            <summary>
            The name of the maximum low value parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.SequenceHiLoGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the SequenceHiLoGenerator by reading the value of <c>sequence</c>, <c>max_lo</c>, 
            and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.SequenceHiLoGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by using a database sequence.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.TableGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that uses a database table to store the last
            generated value.
            </summary>
            <remarks>
            <p>
            It is not intended that applications use this strategy directly. However,
            it may be used to build other (efficient) strategies. The return type is
            <c>System.Int32</c>
            </p>
            <p>
            The hi value MUST be fetched in a seperate transaction to the <c>ISession</c>
            transaction so the generator must be able to obtain a new connection and commit it.
            Hence this implementation may not be used when the user is supplying connections.
            </p>
            <p>
            The mapping parameters <c>table</c> and <c>column</c> are required.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.Column">
            <summary>
            The name of the column parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.Table">
            <summary>
            The name of the table parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.Schema">
            <summary>
            The name of the schema parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the TableGenerator by reading the value of <c>table</c>, 
            <c>column</c>, and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by selecting and updating a value in a table.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the database objects for a TableGenerator.
            </summary>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the Dialect specific sql to 
            create the necessary database objects and to create the first value as <c>1</c> 
            for the TableGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects for a TableGenerator.
            </summary>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects for the TableGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects for a TableGenerator.
            </summary>
            <returns>
            The configured table name.
            </returns>
        </member>
        <member name="T:NHibernate.Id.TableHiLoGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns an <c>Int64</c>, constructed using
            a hi/lo algorithm.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="hilo"&gt;
            	&lt;param name="table"&gt;table&lt;/param&gt;
            	&lt;param name="column"&gt;id_column&lt;/param&gt;
            	&lt;param name="max_lo"&gt;max_lo_value&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>table</c> and <c>column</c> parameters are required, the <c>max_lo</c> and 
            <c>schema</c> are optional.
            </p>
            <p>
            The hi value MUST be fecthed in a seperate transaction to the <c>ISession</c>
            transaction so the generator must be able to obtain a new connection and 
            commit it. Hence this implementation may not be used when the user is supplying
            connections.  In that case a <see cref="T:NHibernate.Id.SequenceHiLoGenerator"/> would be a 
            better choice (where supported).
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.TableHiLoGenerator.MaxLo">
            <summary>
            The name of the max lo parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.TableHiLoGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the TableHiLoGenerator by reading the value of <c>table</c>, 
            <c>column</c>, <c>max_lo</c>, and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.TableHiLoGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by selecting and updating a value in a table.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.UUIDHexGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a string of length
            32, 36, or 38 depending on the configuration.  
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="uuid.hex"&gt;
            	&lt;param name="format"&gt;format_string&lt;/param&gt;
            	&lt;param name="seperator"&gt;seperator_string&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>format</c> and <c>seperator</c> parameters are optional.
            </p>
            <p>
            The identifier string will consist of only hex digits.  Optionally, the identifier string
            may be generated with enclosing characters and seperators between each component 
            of the UUID.  If there are seperators then the string length will be 36.  If a format
            that has enclosing brackets is used, then the string length will be 38.
            </p>
            <p>
            <c>format</c> is either 
            "N" (<c>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</c>), 
            "D" (<c>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</c>), 
            "B" (<c>{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</c>), 
            or "P" (<c>(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</c>).  These formats are described in
            the <see cref="M:System.Guid.ToString(System.String)">Guid.ToString(String)</see> method.
            If no <c>format</c> is specified the default is "N".
            </p>
            <p>
            <c>seperator</c> is the char that will replace the "-" if specified.  If no value is
            configured then the default seperator for the format will be used.  If the format "D", "B", or
            "P" is specified, then the seperator will replace the "-".  If the format is "N" then this
            parameter will be ignored.
            </p>
            <p>
            This class is based on <see cref="T:System.Guid"/>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.UUIDHexGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.String"/> for the identifier using the "uuid.hex" algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.UUIDHexGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the UUIDHexGenerator by reading the value of <c>format</c> and
            <c>seperator</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="T:NHibernate.Id.UUIDStringGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a string of length
            16.  
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="uuid.string" /&gt;</code>
            </p>
            <para>
            The identifier string will NOT consist of only alphanumeric characters.  Use
            this only if you don't mind unreadable identifiers.
            </para>
            <para>
            This impelementation was known to be incompatible with Postgres.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.UUIDStringGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.String"/> for the identifier using the "uuid.string" algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.String"/>.</returns>
        </member>
        <member name="T:NHibernate.Impl.AbstractQueryImpl">
            <summary>
            Abstract implementation of the IQuery interface.
            </summary>
        </member>
        <member name="T:NHibernate.IQuery">
            <summary>
            An object-oriented representation of a NHibernate query.
            </summary>
            <remarks>
            An <c>IQuery</c> instance is obtained by calling <c>ISession.CreateQuery()</c>. This interface
            exposes some extra functionality beyond that provided by <c>ISession.Iterate()</c> and
            <c>ISession.Find()</c>;
            <list>
            	<item>
            		A particulare page of the result set may be selected by calling 
            		<c>SetMaxResults()</c>, <c>SetFirstResult()</c>.  The generated sql
            		depends on the capabilities of the <see cref="T:NHibernate.Dialect.Dialect"/>.  Some
            		Dialects are for databases that have built in paging (LIMIT) and those capabilities
            		will be used to limit the number of records returned by the sql statement. 
            		If the database does not support LIMITs then all of the records will be returned,
            		but the objects created will be limited to the specific results requested.
            	</item>
            	<item>Named query parameters may be used</item>
            </list>
            <para>
            Named query parameters are tokens of the form <c>:name</c> in the query string. A value is bound
            to the <c>Int32</c> parameter <c>:foo</c> by calling
            <code>
            	SetParameter("foo", foo, NHibernateUtil.Int32);
            </code>
            for example. A name may appear multiple times in the query string.
            </para>
            <para>
            Unnamed parameters <c>?</c> are also supported. To bind a value to an unnamed
            parameter use a Set method that accepts an <c>Int32</c> positional argument - numbered from
            zero.
            </para>
            <para>
            You may not mix and match unnamed parameters and named parameters in the same query.
            </para>
            <para>
            Queries are executed by calling <c>List()</c> or <c>Iterate()</c>. A query
            may be re-executed by subsequent invocations. Its lifespan is, however, bounded by the lifespan
            of the <c>ISession</c> that created it.
            </para>
            <para>
            Implementors are not intended to be threadsafe.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.Enumerable">
            <summary>
            Return the query results as an <see cref="T:System.Collections.IEnumerable"/>. If the query contains multiple results
            per row, the results are returned in an instance of <c>object[]</c>.
            </summary>
            <remarks>
            <p>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only.  
            </p>
            <p>
            This is a good strategy to use if you expect a high number of the objects
            returned to be already loaded in the <see cref="T:NHibernate.ISession"/> or in the 2nd level cache.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.Enumerable``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.Enumerable"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IQuery.List">
            <summary>
            Return the query results as an <see cref="T:System.Collections.IList"/>. If the query contains multiple results per row,
            the results are returned in an instance of <c>object[]</c>.
            </summary>
            <returns>The <see cref="T:System.Collections.IList"/> filled with the results.</returns>
            <remarks>
            This is a good strategy to use if you expect few of the objects being returned are already loaded
            or if you want to fill the 2nd level cache.
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.List(System.Collections.IList)">
            <summary>
            Return the query results an place them into the <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="results">The <see cref="T:System.Collections.IList"/> to place the results in.</param>
        </member>
        <member name="M:NHibernate.IQuery.List``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.List"/>.
            </summary>
        </member>
        <member name="M:NHibernate.IQuery.UniqueResult">
            <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
            <returns>the single result or <see langword="null"/></returns>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when there is more than one matching result.
            </exception>
        </member>
        <member name="M:NHibernate.IQuery.UniqueResult``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.UniqueResult"/>.
            </summary>
        </member>
        <member name="M:NHibernate.IQuery.SetMaxResults(System.Int32)">
            <summary>
            Set the maximum number of rows to retrieve.
            </summary>
            <param name="maxResults">The maximum number of rows to retreive.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetFirstResult(System.Int32)">
            <summary>
            Sets the first row to retrieve.
            </summary>
            <param name="firstResult">The first row to retreive.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set.
            </summary>
            <param name="cacheable">Should the query results be cacheable?</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="cacheRegion">The name of a query cache region, or <see langword="null" />
            for the default query cache</param>
        </member>
        <member name="M:NHibernate.IQuery.SetForceCacheRefresh(System.Boolean)">
            Should the query force a refresh of the specified query cache region?
            This is particularly useful in cases where underlying data may have been
            updated via a seperate process (i.e., not modified through Hibernate) and
            allows the application to selectively refresh the query cache regions
            based on its knowledge of those events.
            <param name="forceCacheRefresh">Should the query result in a forceable refresh of
            the query cache?</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimeout(System.Int32)">
            <summary>
            The timeout for the underlying ADO query
            </summary>
            <param name="timeout"></param>
        </member>
        <member name="M:NHibernate.IQuery.SetLockMode(System.String,NHibernate.LockMode)">
            <summary>
            Set the lockmode for the objects idententified by the
            given alias that appears in the <c>FROM</c> clause.
            </summary>
            <param name="alias">alias a query alias, or <c>this</c> for a collection filter</param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.Int32,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to an indexed parameter.
            </summary>
            <param name="position">Postion of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The Hibernate type</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to a named query parameter
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.Int32,System.Object)">
            <summary>
            Bind a value to an indexed parameter, guessing the Hibernate type from
            the class of the given object.
            </summary>
            <param name="position">The position of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.String,System.Object)">
            <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType"/>
            from the class of the given object.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Collections.IEnumerable,NHibernate.Type.IType)">
            <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
            <param name="type">The Hibernate type of the values</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Collections.IEnumerable)">
            <summary>
            Bind multiple values to a named query parameter, guessing the Hibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
        </member>
        <member name="M:NHibernate.IQuery.SetProperties(System.Object)">
            <summary>
            Bind the property values of the given object to named parameters of the query,
            matching property names with parameter names and mapping property types to
            Hibernate types using heuristics.
            </summary>
            <param name="obj">Any PONO</param>
        </member>
        <member name="M:NHibernate.IQuery.SetAnsiString(System.Int32,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetAnsiString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBinary(System.Int32,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBinary(System.String,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBoolean(System.Int32,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBoolean(System.String,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetByte(System.Int32,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetByte(System.String,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCharacter(System.Int32,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCharacter(System.String,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDateTime(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDateTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
            <param name="name">The name of the parameter</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDecimal(System.Int32,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDecimal(System.String,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDouble(System.Int32,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDouble(System.String,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEntity(System.Int32,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to an indexed parameter.
            </summary>
            <param name="position">Position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEntity(System.String,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEnum(System.Int32,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEnum(System.String,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt16(System.Int32,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt16(System.String,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt32(System.Int32,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt32(System.String,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt64(System.Int32,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt64(System.String,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetSingle(System.Int32,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetSingle(System.String,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetString(System.Int32,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTime(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimestamp(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimestamp(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetGuid(System.Int32,System.Guid)">
            <summary>
            Bind an instance of a <see cref="T:System.Guid"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">An instance of a <see cref="T:System.Guid"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetGuid(System.String,System.Guid)">
            <summary>
            Bind an instance of a <see cref="T:System.Guid"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">An instance of a <see cref="T:System.Guid"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetFlushMode(NHibernate.FlushMode)">
            <summary>
            Override the current session flush mode, just for this query.
            </summary>
        </member>
        <member name="M:NHibernate.IQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Set a strategy for handling the query results. This can be used to change
            "shape" of the query result.
            </summary>
        </member>
        <member name="P:NHibernate.IQuery.QueryString">
            <summary>
            The query string
            </summary>
        </member>
        <member name="P:NHibernate.IQuery.ReturnTypes">
            <summary>
            The Hibernate types of the query result set.
            </summary>
        </member>
        <member name="P:NHibernate.IQuery.NamedParameters">
            <summary>
            The names of all named parameters of the query
            </summary>
            <value>The parameter names, in no particular order</value>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.GuessType(System.Object)">
            <summary>
            Guesses the <see cref="T:NHibernate.Type.IType"/> from the <c>param</c>'s value.
            </summary>
            <param name="param">The object to guess the <see cref="T:NHibernate.Type.IType"/> of.</param>
            <returns>An <see cref="T:NHibernate.Type.IType"/> for the object.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <c>param</c> is null because the <see cref="T:NHibernate.Type.IType"/>
            can't be guess from a null value.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.GuessType(System.Type)">
            <summary>
            Guesses the <see cref="T:NHibernate.Type.IType"/> from the <see cref="T:System.Type"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to guess the <see cref="T:NHibernate.Type.IType"/> of.</param>
            <returns>An <see cref="T:NHibernate.Type.IType"/> for the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <c>clazz</c> is null because the <see cref="T:NHibernate.Type.IType"/>
            can't be guess from a null type.
            </exception>
        </member>
        <member name="T:NHibernate.Impl.AbstractVisitor">
            <summary>
            Abstract superclass of algorithms that walk a tree of property values
            of an entity, and perform specific functionality for collections,
            components and associated entities.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.ProcessValues(System.Object[],NHibernate.Type.IType[])">
            <summary>
            Dispatch each property value to <see cref="M:NHibernate.Impl.AbstractVisitor.ProcessValue(System.Object,NHibernate.Type.IType)"/>.
            </summary>
            <param name="values"></param>
            <param name="types"></param>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.ProcessValue(System.Object,NHibernate.Type.IType)">
            <summary>
            Visit a property value. Dispatch to the correct handler
            for the property type.
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.Process(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Walk the tree starting from the given entity.
            </summary>
            <param name="obj"></param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.ProcessCollection(System.Object,NHibernate.Type.CollectionType)">
            <summary>
            Visit a collection. Default superclass implementation is a no-op.
            </summary>
            <param name="collection"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.ProcessEntity(System.Object,NHibernate.Type.EntityType)">
            <summary>
            Visit a many-to-one or one-to-one associated entity. Default
            superclass implementation is a no-op.
            </summary>
            <param name="value"></param>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Impl.BatcherImpl">
            <summary>
            Manages prepared statements and batching. Class exists to enforce separation of concerns
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.#ctor(NHibernate.Impl.ConnectionManager)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Impl.BatcherImpl"/> class.
            </summary>
            <param name="connectionManager">The <see cref="P:NHibernate.Impl.BatcherImpl.ConnectionManager"/> owning this batcher.</param>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Prepare(System.Data.IDbCommand)">
            <summary>
            Prepares the <see cref="T:System.Data.IDbCommand"/> for execution in the database.
            </summary>
            <remarks>
            This takes care of hooking the <see cref="T:System.Data.IDbCommand"/> up to an <see cref="T:System.Data.IDbConnection"/>
            and <see cref="T:System.Data.IDbTransaction"/> if one exists.  It will call <c>Prepare</c> if the Driver
            supports preparing commands.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.CheckReaders">
            <summary>
            Ensures that the Driver's rules for Multiple Open DataReaders are being followed.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.ExecuteBatch">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.DoExecuteBatch(System.Data.IDbCommand)">
            <summary>
            
            </summary>
            <param name="ps"></param>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.AddToBatch(NHibernate.AdoNet.IExpectation)">
            <summary>
            Adds the expected row count into the batch.
            </summary>
            <param name="expectation">The number of rows expected to be affected by the query.</param>
            <remarks>
            If Batching is not supported, then this is when the Command should be executed.  If Batching
            is supported then it should hold of on executing the batch until explicitly told to.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.BatcherImpl._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this BatcherImpl is being Disposed of or Finalized.</param>
            <remarks>
            If this BatcherImpl is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this BatcherImpl back to life.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.BatcherImpl.CurrentCommand">
            <summary>
            Gets the current <see cref="T:System.Data.IDbCommand"/> that is contained for this Batch
            </summary>
            <value>The current <see cref="T:System.Data.IDbCommand"/>.</value>
        </member>
        <member name="P:NHibernate.Impl.BatcherImpl.Factory">
            <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> the Batcher was
            created in.
            </summary>
            <value>
            The <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> the Batcher was
            created in.
            </value>
        </member>
        <member name="P:NHibernate.Impl.BatcherImpl.ConnectionManager">
            <summary>
            Gets the <see cref="P:NHibernate.Impl.BatcherImpl.ConnectionManager"/> for this batcher.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.CacheEntry">
            <summary>
            A cached instance of a persistent class
            </summary>
        </member>
        <member name="M:NHibernate.Impl.CacheEntry.#ctor(System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="persister"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Impl.CacheEntry.Disassemble(System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="persister"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Impl.CacheEntry.Subclass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.CollectionEntry">
            <summary>
            We need an entry to tell us all about the current state
            of a collection with respect to its persistent state
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.reached">
            <summary>
            Indicates that the Collection can still be reached by an Entity
            that exist in the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <remarks>
            It is also used to ensure that the Collection is not shared between
            two Entities.  
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.processed">
            <summary>
            Indicates that the Collection has been processed and is ready
            to have its state synchronized with the database.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.doupdate">
            <summary>
            Indicates that a Collection needs to be updated.
            </summary>
            <remarks>
            A Collection needs to be updated whenever the contents of the Collection
            have been changed. 
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.doremove">
            <summary>
            Indicates that a Collection has old elements that need to be removed.
            </summary>
            <remarks>
            A Collection needs to have removals performed whenever its role changes or
            the key changes and it has a loadedPersister - ie - it was loaded by NHibernate.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.dorecreate">
            <summary>
            Indicates that a Collection needs to be recreated.
            </summary>
            <remarks>
            A Collection needs to be recreated whenever its role changes
            or the owner changes.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.ignore">
            <summary>
            If we instantiate a collection during the <see cref="M:NHibernate.ISession.Flush"/>
            process, we must ignore it for the rest of the flush.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.currentPersister">
            <summary>
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is currently responsible
            for the Collection.
            </summary>
            <remarks>
            This is set when NHibernate is updating a reachable or an
            unreachable collection.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.loadedPersister">
            <summary>
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> when the Collection was loaded.
            </summary>
            <remarks>
            This can be <see langword="null"/> if the Collection was not loaded by NHibernate and 
            was passed in along with a transient object.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.loadedKey">
            <summary>
            The identifier of the Entity that is the owner of this Collection 
            during the load or post flush.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.snapshot">
            <summary>session-start/post-flush persistent state</summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.role">
            <summary>allow the snapshot to be serialized</summary>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.#ctor(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.CollectionEntry"/>.
            </summary>
            <remarks> 
            The CollectionEntry is for a Collection that is not dirty and 
            has already been initialized.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.#ctor(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.CollectionEntry"/> for collections just loaded from the database.
            </summary>
            <param name="loadedPersister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that persists this Collection type.</param>
            <param name="loadedID">The identifier of the Entity that is the owner of this Collection.</param>
            <param name="ignore">A boolean indicating whether to ignore the collection during current (or next) flush.</param>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.#ctor(NHibernate.Engine.ICollectionSnapshot,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.CollectionEntry"/> for initialized detached collections.
            </summary>
            <param name="cs">The <see cref="T:NHibernate.Engine.ICollectionSnapshot"/> from another <see cref="T:NHibernate.ISession"/>.</param>
            <param name="factory">The <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> that created this <see cref="T:NHibernate.ISession"/>.</param>
            <remarks>
            This takes an <see cref="T:NHibernate.Engine.ICollectionSnapshot"/> from another <see cref="T:NHibernate.ISession"/> and 
            creates an entry for it in this <see cref="T:NHibernate.ISession"/> by copying the values from the 
            <c>cs</c> parameter.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.PreFlush(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Prepares this CollectionEntry for the Flush process.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection"/> that this CollectionEntry will be responsible for flushing.</param>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.PostInitialize(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Updates the CollectionEntry to reflect that the <see cref="T:NHibernate.Collection.IPersistentCollection"/>
            has been initialized.
            </summary>
            <param name="collection">The initialized <see cref="T:NHibernate.Collection.AbstractPersistentCollection"/> that this Entry is for.</param>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.PostFlush(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Updates the CollectionEntry to reflect that it is has been successfully flushed to the database.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection"/> that was flushed.</param>
            <remarks>
            Called after a <em>successful</em> flush.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.SetLoadedPersister(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Sets the information in this CollectionEntry that is specific to the
            <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/>.
            </summary>
            <param name="persister">
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is 
            responsible for the Collection.
            </param>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.Key">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.Role">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.Snapshot">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ConnectionManager">
            <summary>
            Manages the database connection and transaction for an <see cref="T:NHibernate.ISession"/>.
            </summary>
            <remarks>
            This class corresponds to ConnectionManager and JDBCContext in Hibernate,
            combined.
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.CriteriaImpl">
            <summary>
            Implementation of the <see cref="T:NHibernate.ICriteria"/> interface
            </summary>
        </member>
        <member name="T:NHibernate.ICriteria">
            <summary>
            Criteria is a simplified API for retrieving entities by composing
            <see cref="N:NHibernate.Expression"/> objects.
            </summary>
            <remarks>
            <para>
            Using criteria is a very convenient approach for functionality like "search" screens
            where there is a variable number of conditions to be placed upon the result set.
            </para>
            <para>
            The Session is a factory for ICriteria. Expression instances are usually obtained via 
            the factory methods on <see cref="N:NHibernate.Expression"/>. eg:
            </para>
            <code>
            IList cats = session.CreateCriteria(typeof(Cat)) 
                .Add( Expression.Like("name", "Iz%") ) 
                .Add( Expression.Gt( "weight", minWeight ) ) 
                .AddOrder( Order.Asc("age") ) 
                .List(); 
            </code>
            You may navigate associations using <see cref="M:NHibernate.ICriteria.CreateAlias(System.String,System.String)"/> or <see cref="M:NHibernate.ICriteria.CreateCriteria(System.String)"/>.
            <code>
            IList cats = session.CreateCriteria(typeof(Cat))
            	.CreateCriteria("kittens")
            		.Add( Expression.like("name", "Iz%") )
            		.List();
            </code>
            <para>
            Hibernate's query language is much more general and should be used for non-simple cases.
            </para>
            <note>
            This is an experimental API.
            </note>
            </remarks>
        </member>
        <member name="M:NHibernate.ICriteria.SetMaxResults(System.Int32)">
            <summary>
            Set a limit upon the number of objects to be retrieved
            </summary>
            <param name="maxResults"></param>
        </member>
        <member name="M:NHibernate.ICriteria.SetFirstResult(System.Int32)">
            <summary>
            Set the first result to be retrieved
            </summary>
            <param name="firstResult"></param>
        </member>
        <member name="M:NHibernate.ICriteria.SetTimeout(System.Int32)">
            <summary>
            Set a timeout for the underlying ADO.NET query
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.Add(NHibernate.Expression.ICriterion)">
            <summary>
            Add an Expression to constrain the results to be retrieved.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.AddOrder(NHibernate.Expression.Order)">
            <summary>
            An an Order to the result set 
            </summary>
            <param name="order"></param>
        </member>
        <member name="M:NHibernate.ICriteria.List">
            <summary>
            Get the results
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.List(System.Collections.IList)">
            <summary>
            Get the results and fill the <see cref="T:System.Collections.IList"/>
            </summary>
            <param name="results">The list to fill with the results.</param>
        </member>
        <member name="M:NHibernate.ICriteria.List``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.ICriteria.List"/>.
            </summary>
        </member>
        <member name="M:NHibernate.ICriteria.UniqueResult``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.ICriteria.UniqueResult"/>.
            </summary>
        </member>
        <member name="M:NHibernate.ICriteria.UniqueResult">
            <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
            <returns>the single result or <see langword="null"/></returns>
            <exception cref="T:NHibernate.HibernateException">
            If there is more than one matching result
            </exception>
        </member>
        <member name="M:NHibernate.ICriteria.SetFetchMode(System.String,NHibernate.FetchMode)">
            <summary>
            Specify an association fetching strategy.  Currently, only
            one-to-many and one-to-one associations are supported.
            </summary>
            <param name="associationPath">A dot seperated property path.</param>
            <param name="mode">The Fetch mode.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateAlias(System.String,System.String)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateAlias(System.String,System.String,NHibernate.SqlCommand.JoinType)">
            <summary>
            Join an association using the specified join-type, assigning an alias to the joined
            association
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <param name="joinType">The type of join to use.</param>
            <returns>this (for method chaining)</returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity
            </summary>
            <param name="associationPath"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity,
            assigning the given alias
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,System.String,NHibernate.SqlCommand.JoinType)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity,
            assigning the given alias and using the specified join type.
            </summary>
            <param name="associationPath">A dot-separated property path</param>
            <param name="alias">The alias to assign to the joined association (for later reference).</param>
            <param name="joinType">The type of join to use.</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,NHibernate.SqlCommand.JoinType)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity, 
            using the specified join type.
            </summary>
            <param name="associationPath">A dot-seperated property path</param>
            <param name="joinType">The type of join to use</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Set a strategy for handling the query results. This determines the
            "shape" of the query result set.
            <seealso cref="F:NHibernate.CriteriaUtil.RootEntity"/>
            <seealso cref="F:NHibernate.CriteriaUtil.DistinctRootEntity"/>
            <seealso cref="F:NHibernate.CriteriaUtil.AliasToEntityMap"/>
            </summary>
            <param name="resultTransformer"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetLockMode(NHibernate.LockMode)">
            <summary>
            Set the lock mode of the current entity
            </summary>
            <param name="lockMode">the lock mode</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetLockMode(System.String,NHibernate.LockMode)">
            <summary>
            Set the lock mode of the aliased entity
            </summary>
            <param name="alias">an alias</param>
            <param name="lockMode">the lock mode</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set
            </summary>
            <param name="cacheable"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetCacheRegion(System.String)">
            <summary>
            Set the name of the cache region.
            </summary>
            <param name="cacheRegion">the name of a query cache region, or <see langword="null" />
            for the default query cache</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetProjection(NHibernate.Expression.IProjection)">
            <summary>
            Used to specify that the query results will be a projection (scalar in
            nature).  Implicitly specifies the projection result transformer.
            </summary>
            <param name="projection">The projection representing the overall "shape" of the
            query results.</param>
            <returns>This instance (for method chaining)</returns>
            <remarks>
            <para>
            The individual components contained within the given <see cref="T:NHibernate.Expression.IProjection"/>
            determines the overall "shape" of the query result.
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.ICriteria.Alias">
            <summary>
            Get the alias of the entity encapsulated by this criteria instance.
            </summary>
            <value>The alias for the encapsulated entity.</value>
        </member>
        <member name="T:NHibernate.Impl.DirtyCollectionSearchVisitor">
            <summary>
            A Visitor that determines if a dirty collection was found.
            </summary>
            <remarks>
            <list type="number">
            	<listheader>
            		<description>Reason for dirty collection</description>
            	</listheader>
            	<item>
            		<description>
            		If it is a new application-instantiated collection, return true (does not occur anymore!)
            		</description>
            	</item>
            	<item>
            		<description>
            		If it is a component, recurse.
            		</description>
            	</item>
            	<item>
            		<description>
            		If it is a wrapped collection, ask the collection entry.
            		</description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.DirtyCollectionSearchVisitor.WasDirtyCollectionFound">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if a dirty collection was found.
            </summary>
            <value><see langword="true"/> if a dirty collection was found.</value>
        </member>
        <member name="T:NHibernate.Impl.EntityEntry">
            <summary>
            We need an entry to tell us all about the current state
            of an object with respect to its persistent state
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EntityEntry.#ctor(NHibernate.Impl.Status,System.Object[],System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean)">
            <summary>
            Initializes a new instance of EntityEntry.
            </summary>
            <param name="status">The current <see cref="P:NHibernate.Impl.EntityEntry.Status"/> of the Entity.</param>
            <param name="loadedState">The snapshot of the Entity's state when it was loaded.</param>
            <param name="id">The identifier of the Entity in the database.</param>
            <param name="version">The version of the Entity.</param>
            <param name="lockMode">The <see cref="P:NHibernate.Impl.EntityEntry.LockMode"/> for the Entity.</param>
            <param name="existsInDatabase">A boolean indicating if the Entity exists in the database.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for this Entity.</param>
            <param name="disableVersionIncrement"></param>
        </member>
        <member name="M:NHibernate.Impl.EntityEntry.PostUpdate(System.Object,System.Object[],System.Object)">
            <summary>After actually updating the database, update the snapshot information,
            and escalate the lock mode.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.LockMode">
            <summary>
            Gets or sets the current <see cref="P:NHibernate.Impl.EntityEntry.LockMode"/> of the Entity.
            </summary>
            <value>The <see cref="P:NHibernate.Impl.EntityEntry.LockMode"/> of the Entity.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.Status">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Impl.EntityEntry.Status"/> of this Entity with respect to its 
            persistence in the database.
            </summary>
            <value>The <see cref="P:NHibernate.Impl.EntityEntry.Status"/> of this Entity.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.Id">
            <summary>
            Gets or sets the identifier of the Entity in the database.
            </summary>
            <value>The identifier of the Entity in the database if one has been assigned.</value>
            <remarks>This might be <see langword="null"/> when the <see cref="P:NHibernate.Impl.EntityEntry.Status"/> is 
            <see cref="F:NHibernate.Impl.Status.Saving"/> and the database generates the id.</remarks>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.LoadedState">
            <summary>
            Gets or sets the snapshot of the Entity when it was loaded from the database.
            </summary>
            <value>The snapshot of the Entity.</value>
            <remarks>
            There will only be a value when the Entity was loaded in the current Session.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.DeletedState">
            <summary>
            Gets or sets the snapshot of the Entity when it was marked as being ready for deletion.
            </summary>
            <value>The snapshot of the Entity.</value>
            <remarks>This will be <see langword="null" /> if the Entity is not being deleted.</remarks>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.ExistsInDatabase">
            <summary>
            Gets or sets a <see cref="T:System.Boolean"/> indicating if this Entity exists in the database.
            </summary>
            <value><see langword="true"/> if it is already in the database.</value>
            <remarks>
            It can also be <see langword="true"/> if it does not exists in the database yet and the 
            <see cref="P:NHibernate.Persister.Entity.IEntityPersister.IsIdentifierAssignedByInsert"/> is <see langword="true"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.Version">
            <summary>
            Gets or sets the version of the Entity.
            </summary>
            <value>The version of the Entity.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.Persister">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for this Entity.
            </summary>
            <value>The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is reponsible for this Entity.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.ClassName">
            <summary>
            Gets the Fully Qualified Name of the class this Entity is an instance of.
            </summary>
            <value>The Fully Qualified Name of the class this Entity is an instance of.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.IsBeingReplicated">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Impl.EnumerableImpl">
            <summary>
            Provides an <see cref="T:System.Collections.IEnumerable"/> wrapper over the results of an <see cref="T:NHibernate.IQuery"/>.
            </summary>
            <remarks>
            This is the IteratorImpl in H2.0.3
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.#ctor(System.Data.IDataReader,System.Data.IDbCommand,NHibernate.Engine.ISessionImplementor,NHibernate.Type.IType[],System.String[][],NHibernate.Engine.RowSelection,NHibernate.Hql.HolderInstantiator)">
            <summary>
            Create an <see cref="T:System.Collections.IEnumerable"/> wrapper over an <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to enumerate over.</param>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> used to create the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="sess">The <see cref="T:NHibernate.ISession"/> to use to load objects.</param>
            <param name="types">The <see cref="T:NHibernate.Type.IType"/>s contained in the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="columnNames">The names of the columns in the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="selection">The <see cref="T:NHibernate.Engine.RowSelection"/> that should be applied to the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="holderInstantiator">Instantiator of the result holder (used for "select new SomeClass(...)" queries).</param>
            <remarks>
            The <see cref="T:System.Data.IDataReader"/> should already be positioned on the first record in <see cref="T:NHibernate.Engine.RowSelection"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the query results.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the query results.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.MoveNext">
             <summary>
             Advances the enumerator to the next element of the query results.
             </summary>
             <returns>
             <see langword="true" /> if the enumerator was successfully advanced to the next query results
             ; <see langword="false" /> if the enumerator has passed the end of the query results.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Reset">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Impl.EnumerableImpl._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this EnumerableImpl is being Disposed of or Finalized.</param>
            <remarks>
            The command is closed and the reader is disposed.  This allows other ADO.NET
            related actions to occur without needing to move all the way through the
            EnumerableImpl.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.EnumerableImpl.Current">
            <summary>
            Gets the current element in the query results.
            </summary>
            <value>
            The current element in the query results which is either an object or 
            an object array.
            </value>
            <remarks>
            If the <see cref="T:NHibernate.IQuery"/> only returns one type of Entity then an object will
            be returned.  If this is a multi-column resultset then an object array will be
            returned.
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.EvictVisitor">
            <summary>
            Evict any collections referenced by the object from the ISession cache.
            </summary>
            <remarks>
            This will <b>NOT</b> pick up any collections that were dereferenced, so
            they will be deleted (suboptimal but not exactly incorrect).
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.FilterImpl">
            <summary>
            </summary>
        </member>
        <member name="T:NHibernate.IFilter">
            <summary>
            Type definition of Filter.  Filter defines the user's view into enabled dynamic filters,
            allowing them to set filter parameter values.
            </summary>
        </member>
        <member name="M:NHibernate.IFilter.SetParameter(System.String,System.Object)">
            <summary>
            Set the named parameter's value list for this filter. 
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="value">The values to be applied.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.IFilter.SetParameterList(System.String,System.Collections.ICollection)">
            <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="values">The values to be expanded into an SQL IN list.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.IFilter.SetParameterList(System.String,System.Object[])">
            <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="values">The values to be expanded into an SQL IN list.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.IFilter.Validate">
            <summary>
            Perform validation of the filter state.  This is used to verify the
            state of the filter after its enablement and before its use.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.IFilter.Name">
            <summary>
            Get the name of this filter. 
            </summary>
            <returns>This filter's name.</returns>
        </member>
        <member name="P:NHibernate.IFilter.FilterDefinition">
            <summary>
            Get the filter definition containing additional information about the
            filter (such as default-condition and expected parameter names/types).
            </summary>
            <returns>The filter definition</returns>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.SetParameter(System.String,System.Object)">
            <summary>
            Set the named parameter's value for this filter.
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="value">The value to be applied.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.SetParameterList(System.String,System.Collections.ICollection)">
            <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="values">The values to be expanded into an SQL IN list.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.SetParameterList(System.String,System.Object[])">
            <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="values">The values to be expanded into an SQL IN list.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.Validate">
            <summary>
            Perform validation of the filter state.  This is used to verify the
            state of the filter after its enablement and before its use.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Impl.FilterImpl.Name">
            <summary>
            Get the name of this filter.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.IExecutable">
            <summary>
            An action that <see cref="T:NHibernate.ISession"/> can Execute during a
            <c>Flush</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.IExecutable.BeforeExecutions">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Impl.IExecutable.Execute">
            <summary>
            Execute the action required to write changes to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.IExecutable.AfterTransactionCompletion(System.Boolean)">
            <summary>
            Called after the Transaction has been completed.
            </summary>
            <param name="success"></param>
            <remarks>
            Actions should make sure that the Cache is notified about
            what just happened.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.IExecutable.HasAfterTransactionCompletion">
            <summary>
            Does the executable have an AfterTransactionCompletion process
            </summary>
        </member>
        <member name="P:NHibernate.Impl.IExecutable.PropertySpaces">
            <summary>
            The spaces (tables) that are affectd by this Executable action.
            </summary>
            <remarks>
            This is used to determine if the ISession needs to be flushed before
            a query is executed so stale data is not returned.
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.MessageHelper">
            <summary>
            Helper methods for rendering log messages and exception messages
            </summary>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(System.Type,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to create the string from.</param>
            <param name="id">The identifier of the object.</param>
            <returns>A descriptive <see cref="T:System.String"/> in the format of <c>[classname#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class in question.</param>
            <param name="id">The identifier of the object.</param>
            <param name="factory">The <see cref="T:NHibernate.ISessionFactory"/>.</param>
            <returns>A descriptive <see cref="T:System.String"/> in the format of <c>[classname#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.Type.IType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class in question.</param>
            <param name="id">The identifier of the object.</param>
            <param name="factory">The <see cref="T:NHibernate.ISessionFactory"/>.</param>
            <param name="identifierType">The NHibernate type of the identifier.</param>
            <returns>A descriptive <see cref="T:System.String"/> in the format of <c>[classname#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class in question</param>
            <param name="id">The id</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[FooBar#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class in question</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[FooBar]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for the class in question</param>
            <param name="id">The id</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[collectionrole#id]</c></returns>
        </member>
        <member name="T:NHibernate.IMultiQuery">
            <summary>
            Combines sevaral queries into a single database call
            </summary>
        </member>
        <member name="M:NHibernate.IMultiQuery.List">
            <summary>
            Get all the 
            </summary>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add(NHibernate.IQuery)">
            <summary>
            Add the specified HQL query to the multi query
            </summary>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add(System.String)">
            <summary>
            Add the specified HQL query to the multi query
            </summary>
        </member>
        <member name="M:NHibernate.IMultiQuery.AddNamedQuery(System.String)">
            <summary>
            Add a named query to the multi query
            </summary>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set.
            </summary>
            <param name="cacheable">Should the query results be cacheable?</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="cacheRegion">The name of a query cache region, or <see langword="null" />
            for the default query cache</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetForceCacheRefresh(System.Boolean)">
            Should the query force a refresh of the specified query cache region?
            This is particularly useful in cases where underlying data may have been
            updated via a seperate process (i.e., not modified through Hibernate) and
            allows the application to selectively refresh the query cache regions
            based on its knowledge of those events.
            <param name="forceCacheRefresh">Should the query result in a forceable refresh of
            the query cache?</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetTimeout(System.Int32)">
            <summary>
            The timeout for the underlying ADO query
            </summary>
            <param name="timeout"></param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to a named query parameter
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetParameter(System.String,System.Object)">
            <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType"/>
            from the class of the given object.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetParameterList(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
            <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
            <param name="type">The Hibernate type of the values</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetParameterList(System.String,System.Collections.ICollection)">
            <summary>
            Bind multiple values to a named query parameter, guessing the Hibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetAnsiString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetBinary(System.String,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetBoolean(System.String,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetByte(System.String,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetCharacter(System.String,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetDateTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
            <param name="name">The name of the parameter</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetDecimal(System.String,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetDouble(System.String,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetEntity(System.String,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetEnum(System.String,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetInt16(System.String,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetInt32(System.String,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetInt64(System.String,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetSingle(System.String,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetTimestamp(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetFlushMode(NHibernate.FlushMode)">
            <summary>
            Override the current session flush mode, just for this query.
            </summary>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Set a strategy for handling the query results. This can be used to change
            "shape" of the query result.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.MultiQueryImpl.List">
            <summary>
            Return the query results of all the queries
            </summary>
        </member>
        <member name="M:NHibernate.Type.ICacheAssembler.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, disassembles the object into a cacheable representation.
		</summary><param name="value">The value to disassemble.</param><param name="session">The sesion</param><returns>The disassembled, deep cloned state of the object</returns> 
        </member>
        <member name="M:NHibernate.Type.ICacheAssembler.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, reconstructs the object from its 
		cached "disassembled" state.
		</summary><param name="cached">The disassembled state from the cache</param><param name="session">The session</param><param name="owner">tThe parent Entity object</param><returns>The assembled object.</returns> 
        </member>
        <member name="T:NHibernate.Impl.NonBatchingBatcher">
            <summary>
            An implementation of the <see cref="T:NHibernate.Engine.IBatcher"/> 
            interface that does no batching.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.NonBatchingBatcher.#ctor(NHibernate.Impl.ConnectionManager)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Impl.NonBatchingBatcher"/> class.
            </summary>
            <param name="connectionManager">The <see cref="T:NHibernate.Impl.ConnectionManager"/> for this batcher.</param>
        </member>
        <member name="M:NHibernate.Impl.NonBatchingBatcher.AddToBatch(NHibernate.AdoNet.IExpectation)">
            <summary>
            Executes the current <see cref="T:System.Data.IDbCommand"/> and compares the row Count
            to the <c>expectedRowCount</c>.
            </summary>
            <param name="expectation">
            The expected number of rows affected by the query.  A value of less than <c>0</c>
            indicates that the number of rows to expect is unknown or should not be a factor.
            </param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when there is an expected number of rows to be affected and the
            actual number of rows is different.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.NonBatchingBatcher.DoExecuteBatch(System.Data.IDbCommand)">
            <summary>
            This Batcher implementation does not support batching so this is a no-op call.  The
            actual execution of the <see cref="T:System.Data.IDbCommand"/> is run in the <c>AddToBatch</c> 
            method.
            </summary>
            <param name="ps"></param>
        </member>
        <member name="T:NHibernate.Impl.OnLockVisitor">
            <summary>
            When a transient entity is passed to <see cref="M:NHibernate.ISession.Lock(System.Object,NHibernate.LockMode)"/>, we must inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the
               existing snapshot
            3. throw an exception for each "new" collection
            </summary>
        </member>
        <member name="T:NHibernate.Impl.ReattachVisitor">
            <summary>
            Abstract superclass of visitors that reattach collections
            </summary>
        </member>
        <member name="T:NHibernate.Impl.ProxyVisitor">
            <summary>
            Reassociates uninitialized Proxies with the Session.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.OnReplicateVisitor">
            <summary>
            When an entity is passed to Update(), we must inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the existing snapshot
            3. execute a collection removal (SQL DELETE) for each null collection property or "new" collection
            </summary>
        </member>
        <member name="T:NHibernate.Impl.OnUpdateVisitor">
            <summary>
            When an entity is passed to <c>Update()</c>, all its collections must be
            inspected and:
            <list type="number">
            	<item>
            		<description>
            		Associate any uninitialized PersistentCollections with this Session.
            		</description>
            	</item>
            	<item>
            		<description>
            		Associate any initialized PersistentCollections with this Session, using the
            		existing snapshot.
            		</description>
            	</item>
            	<item>
            		<description>
            		Execute a collection removal (SQL DELETE) for each null collection property
            		or "new" collection.
            		</description>
            	</item>
            </list>
            </summary>
        </member>
        <member name="M:NHibernate.Impl.Printer.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="entity">an actual entity object, not a proxy!</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Impl.QueryFilterImpl">
            <summary>
            Implementation of the <see cref="T:NHibernate.IQuery"/> interface for collection filters.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.QueryFilterImpl.#ctor(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="queryString"></param>
            <param name="collection"></param>
            <param name="session"></param>
        </member>
        <member name="T:NHibernate.Impl.ScheduledCollectionAction">
            <summary>
            The base class for a scheduled action to perform on a Collection during a
            flush.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionAction.#ctor(NHibernate.Persister.Collection.ICollectionPersister,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledCollectionAction"/>.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="id">The identifier of the Collection owner.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionAction.AfterTransactionCompletion(System.Boolean)">
            <summary></summary>
            <param name="success"></param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionAction.BeforeExecutions">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionAction.Evict">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledCollectionAction.Persister">
            <summary>
            Gets the <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is responsible for persisting the Collection.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledCollectionAction.Id">
            <summary>
            Gets the identifier of the Collection owner.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledCollectionAction.Session">
            <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionImplementor"/> the action is executing in.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledCollectionAction.PropertySpaces">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledCollectionRecreate">
            <summary>
            A scheduled recreation of the Collection in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionRecreate.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledCollectionRecreate"/>.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection"/> to recreate.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="id">The identifier of the Collection owner.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionRecreate.Execute">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledCollectionRemove">
            <summary>
            A scheduled removal of the Collection from the database.
            </summary>
            <remarks>
            This Collection is not represented in the database anymore.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionRemove.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledCollectionRemove"/>.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection"/> that is being removed.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="id">The identifier of the Collection owner.</param>
            <param name="emptySnapshot">Indicates if the Collection was empty when it was loaded.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionRemove.Execute">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledCollectionUpdate">
            <summary>
            A scheduled update of the Collection in the database.
            </summary>
            <remarks>
            Entities in the Collection or the contents of the Collection have been modified
            and the database should be updated accordingly.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionUpdate.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledCollectionUpdate"/>.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection"/> to update.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="id">The identifier of the Collection owner.</param>
            <param name="emptySnapshot">Indicates if the Collection was empty when it was loaded.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionUpdate.Execute">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledDeletion">
            <summary>
            A scheduled deletion of an object.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledEntityAction">
            <summary>
            The base class for a scheduled action to perform on an entity during a
            flush.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledEntityAction.#ctor(NHibernate.Engine.ISessionImplementor,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledEntityAction"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
            <param name="id">The identifier of the object.</param>
            <param name="instance">The actual object instance.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for the persisting the object.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledEntityAction.BeforeExecutions">
            <summary>
            
            </summary>
            <remarks>Not supported for a non-collection entity</remarks>
        </member>
        <member name="M:NHibernate.Impl.ScheduledEntityAction.AfterTransactionCompletion(System.Boolean)">
            <summary>
            Called when the Transaction this action occurred in has completed.
            </summary>
            <param name="success"></param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledEntityAction.Execute">
            <summary>
            Execute the action using the <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/>.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.Session">
            <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionImplementor"/> the action is executing in.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.Id">
            <summary>
            Gets the identifier of the object.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.Persister">
            <summary>
            Gets the <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for persisting the object.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.Instance">
            <summary>
            Gets the object that is having the scheduled action performed against it.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.HasAfterTransactionCompletion">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.PropertySpaces">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledDeletion.#ctor(System.Object,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledDeletion"/>.
            </summary>
            <param name="id">The identifier of the object.</param>
            <param name="version">The version of the object being deleted.</param>
            <param name="instance">The actual object instance.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for the persisting the object.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledDeletion.Execute">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledDeletion.AfterTransactionCompletion(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledIdentityInsertion">
            <summary>
            Summary description for ScheduledIdentityInsertion.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledIdentityInsertion.#ctor(System.Object[],System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="state"></param>
            <param name="instance"></param>
            <param name="persister"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledIdentityInsertion.AfterTransactionCompletion(System.Boolean)">
            <summary>
            
            </summary>
            <param name="sucess"></param>
        </member>
        <member name="P:NHibernate.Impl.ScheduledIdentityInsertion.HasAfterTransactionCompletion">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledInsertion">
            <summary>
            A scheduled insertion of an object.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledInsertion.#ctor(System.Object,System.Object[],System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledInsertion"/>.
            </summary>
            <param name="id">The identifier of the object.</param>
            <param name="state">An object array that contains the state of the object being inserted.</param>
            <param name="instance">The actual object instance.</param>
            <param name="version">The version of the object instance.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for the persisting the object.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledInsertion.Execute">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledInsertion.AfterTransactionCompletion(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledUpdate">
            <summary>
            A scheduled update of an object.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledUpdate.#ctor(System.Object,System.Object[],System.Int32[],System.Boolean,System.Object[],System.Object,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledUpdate"/>.
            </summary>
            <param name="id">The identifier of the object.</param>
            <param name="state">An array of objects that contains the value of each Property.</param>
            <param name="dirtyProperties">An array that contains the indexes of the dirty Properties.</param>
            <param name="hasDirtyCollection">Whether the object contains a dirty collection.</param>
            <param name="previousState"></param>
            <param name="lastVersion">The current version of the object.</param>
            <param name="nextVersion">The version the object should be after update.</param>
            <param name="instance">The actual object instance.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for the persisting the object.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledUpdate.Execute">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledUpdate.AfterTransactionCompletion(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryImpl">
            <summary>
             Concrete implementation of a SessionFactory.
            </summary>
            <remarks>
            Has the following responsibilities:
            <list type="">
            <item>
            Caches configuration settings (immutably)</item>
            <item>
            Caches "compiled" mappings - ie. <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> 
            and <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/>
            </item>
            <item>
            Caches "compiled" queries (memory sensitive cache)
            </item>
            <item>
            Manages <c>PreparedStatements/IDbCommands</c> - how true in NH?
            </item>
            <item>
            Delegates <c>IDbConnection</c> management to the <see cref="T:NHibernate.Connection.IConnectionProvider"/>
            </item>
            <item>
            Factory for instances of <see cref="T:NHibernate.ISession"/>
            </item>
            </list>
            <para>
            This class must appear immutable to clients, even if it does all kinds of caching
            and pooling under the covers.  It is crucial that the class is not only thread safe
            , but also highly concurrent.  Synchronization must be used extremely sparingly.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetEntityPersister(System.Type)">
            <summary>
            
            </summary>
            <param name="theClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenDatabinder">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetNamedQuery(System.String)">
            <summary>
            Gets the <c>hql</c> query identified by the <c>name</c>.
            </summary>
            <param name="name">The name of that identifies the query.</param>
            <returns>
            A <c>hql</c> query or <see langword="null" /> if the named
            query does not exist.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetNamedSQLQuery(System.String)">
            <summary>
            
            </summary>
            <param name="queryName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetIdentifierType(System.Type)">
            <summary>
            
            </summary>
            <param name="objectClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetIdentifierPropertyName(System.Type)">
            <summary>
            
            </summary>
            <param name="objectClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetImplementors(System.Type)">
            <summary>
            Return the names of all persistent (mapped) classes that extend or implement the
            given class or interface, accounting for implicit/explicit polymorphism settings
            and excluding mapped subclasses/joined-subclasses of other classes in the result.
            </summary>
            <param name="clazz"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetImplementorClasses(System.Type)">
            <summary>
            Added to solve a problem with SessionImpl.Find( CriteriaImpl ),
            see the comment there for an explanation.
            </summary>
            <param name="clazz"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetAllClassMetadata">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetAllCollectionMetadata">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.Close">
            <summary>
            Closes the session factory, releasing all held resources.
            <list>
            <item>cleans up used cache regions and "stops" the cache provider.</item>
            <item>close the ADO.NET connection</item>
            </list>
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenConnection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.Dialect">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.TransactionFactory">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsBatchUpdateEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.BatchSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsScrollableResultSetsEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsGetGeneratedKeysEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsOuterJoinedFetchEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.DefaultSchema">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.MaximumFetchDepth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsShowSqlEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.FetchSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.ConnectionProvider">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.Isolation">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryImpl.QueryCacheKey">
            <summary>
            A class that can be used as a Key in a Hashtable for 
            a Query Cache.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryImpl.FilterCacheKey">
            <summary>
            A class that can be used as a Key in a Hashtable for 
            a Query Cache.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryObjectFactory">
            <summary>
            Resolves <see cref="T:NHibernate.ISessionFactory"/> lookups and deserialization.
            </summary>
            <remarks>
            <para>
            This is used heavily be Deserialization.  Currently a SessionFactory is not really serialized. 
            All that is serialized is it's name and uid.  During Deserializaiton the serialized SessionFactory
            is converted to the one contained in this object.  So if you are serializing across AppDomains
            you should make sure that "name" is specified for the SessionFactory in the hbm.xml file and that the
            other AppDomain has a configured SessionFactory with the same name.  If
            you are serializing in the same AppDomain then there will be no problem because the uid will
            be in this object.
            </para>
            <para>
            TODO: verify that the AppDomain statements are correct.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.AddInstance(System.String,System.String,NHibernate.ISessionFactory,System.Collections.IDictionary)">
            <summary>
            Adds an Instance of the SessionFactory to the local "cache".
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <param name="name">The name of the ISessionFactory.</param>
            <param name="instance">The ISessionFactory.</param>
            <param name="properties">The configured properties for the ISessionFactory.</param>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.RemoveInstance(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            Removes the Instance of the SessionFactory from the local "cache".
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <param name="name">The name of the ISessionFactory.</param>
            <param name="properties">The configured properties for the ISessionFactory.</param>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.GetNamedInstance(System.String)">
            <summary>
            Returns a Named Instance of the SessionFactory from the local "cache" identified by name.
            </summary>
            <param name="name">The name of the ISessionFactory.</param>
            <returns>An instantiated ISessionFactory.</returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.GetInstance(System.String)">
            <summary>
            Returns an Instance of the SessionFactory from the local "cache" identified by UUID.
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <returns>An instantiated ISessionFactory.</returns>
        </member>
        <member name="T:NHibernate.Impl.SessionImpl">
            <summary>
            Concrete implementation of a Session, also the central, organizing component
            of Hibernate's internal implementation.
            </summary>
            <remarks>
            Exposes two interfaces: ISession itself, to the application and ISessionImplementor
            to other components of hibernate. This is where the hard stuff is...
            NOT THREADSAFE
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.closed">
            <summary>
            Indicates if the Session has been closed.
            </summary>
            <value>
            <see langword="false" /> (by default) if the Session is Open and can be used, 
            <see langword="true" /> if the Session has had the methods <c>Close()</c> or
            <c>Dispose()</c> invoked.</value>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.entitiesByKey">
            <summary>
            An <see cref="T:System.Collections.IDictionary"/> with the <see cref="T:NHibernate.Engine.EntityKey"/> as the key
            and an <see cref="T:System.Object"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.proxiesByKey">
            <summary>
            An <see cref="T:System.Collections.IDictionary"/> with the <see cref="T:NHibernate.Engine.EntityKey"/> as the key
            and an <see cref="T:NHibernate.Proxy.INHibernateProxy"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.entityEntries">
            <summary>
            An <see cref="T:NHibernate.Util.IdentityMap"/> with the <see cref="T:System.Object"/> as the key
            and an <see cref="T:NHibernate.Impl.EntityEntry"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.arrayHolders">
            <summary>
            An <see cref="T:NHibernate.Util.IdentityMap"/> with the <see cref="T:System.Array"/> as the key
            and an <see cref="T:NHibernate.Collection.PersistentArrayHolder"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.collectionEntries">
            <summary>
            An <see cref="T:NHibernate.Util.IdentityMap"/> with the <see cref="T:NHibernate.Collection.IPersistentCollection"/> as the key
            and an <see cref="T:NHibernate.Impl.CollectionEntry"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.collectionsByKey">
            <summary>
            An <see cref="T:NHibernate.Util.IdentityMap"/> with the <see cref="T:NHibernate.Impl.CollectionKey"/> as the key
            and an <see cref="T:NHibernate.Collection.IPersistentCollection"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.nullifiables">
            <summary>
            An <see cref="T:Iesi.Collections.ISet"/> of <see cref="T:NHibernate.Engine.EntityKey"/> objects of the deleted entities.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to recreate the Session during the deserialization.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
            <remarks>
            This is needed because we have to do some checking before the serialization process
            begins.  I don't know how to add logic in ISerializable.GetObjectData and have .net
            write all of the serializable fields out.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Verify the ISession can be serialized and write the fields to the Serializer.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
            <remarks>
            The fields are marked with [NonSerializable] as just a point of reference.  This method
            has complete control and what is serialized and those attributes are ignored.  However, 
            this method should be in synch with the attributes for easy readability.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)">
            <summary>
            Once the entire object graph has been deserialized then we can hook the
            collections, proxies, and entities back up to the ISession.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Close">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AfterTransactionCompletion(System.Boolean,NHibernate.ITransaction)">
            <summary>
            Ensure that the locks are downgraded to <see cref="F:NHibernate.LockMode.None"/>
            and that all of the softlocks in the <see cref="N:NHibernate.Cache"/> have
            been released.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Cleanup">
            <summary>
            Mark the Session as being closed and Clear out the HashTables of
            entities and proxies along with the Identity Maps for entries, array
            holders, collections, and nullifiables.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetEntity(NHibernate.Engine.EntityKey)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.SetLockMode(System.Object,NHibernate.LockMode)">
            <summary>
            
            </summary>
            <param name="entity"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Save(System.Object)">
            <summary>
            Save a transient object. An id is generated, assigned to the object and returned
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Save(System.Object,System.Object)">
            <summary>
            Save a transient object with a manually assigned ID
            </summary>
            <param name="obj"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ReassociateIfUninitializedProxy(System.Object)">
            <summary>
            If the parameter <c>value</c> is an unitialized proxy then it will be reassociated
            with the session. 
            </summary>
            <param name="value">A persistable object, proxy, persistent collection or null</param>
            <returns>
            <see langword="true" /> when an uninitialized proxy was passed into this method, <see langword="false" /> otherwise.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ReassociateProxy(NHibernate.Proxy.LazyInitializer,NHibernate.Proxy.INHibernateProxy)">
            <summary>
            associate a proxy that was instantiated by another session with this session
            </summary>
            <param name="li"></param>
            <param name="proxy"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.NullifyTransientReferences(System.Object,NHibernate.Type.IType,System.Boolean,System.Object)">
            <summary>
            Return null if the argument is an "unsaved" entity (ie. one with no existing database row), 
            or the input argument otherwise. This is how Hibernate avoids foreign key constraint violations.
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <param name="earlyInsert"></param>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.IsUnsaved(System.Object,System.Boolean,System.Object)">
            <summary>
            determine if the object already exists in the database, using a "best guess"
            </summary>
            <param name="obj"></param>
            <param name="earlyInsert"></param>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Delete(System.Object)">
            <summary>
            Delete a persistent object
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CheckNullability(System.Object[],NHibernate.Persister.Entity.IEntityPersister,System.Boolean)">
            <summary>
            Checks to see if there are any Properties that should not be null 
            are references to null or to a transient object.
            </summary>
            <param name="values">An object array of values that should be validated.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that describes which values can be null.</param>
            <param name="isUpdate">A <see cref="T:System.Boolean"/> indicating if this is an Update operation.</param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when a non-nullable property contains a value that would
            persist the value of null to the database.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ReattachCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Engine.ICollectionSnapshot)">
            <summary>
            Reattach a detached (disassociated) initialized or uninitialized collection wrapper
            </summary>
            <param name="collection"></param>
            <param name="snapshot"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoReplicate(System.Object,System.Object,System.Object,NHibernate.ReplicationMode,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Used only by Replicate
            </summary>
            <param name="obj"></param>
            <param name="id"></param>
            <param name="version"></param>
            <param name="replicationMode"></param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Find(System.String)">
            <summary>
            Retrieve a list of persistent objects using a Hibernate query
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateFilter(System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <param name="queryString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateQuery(System.String)">
            <summary>
            
            </summary>
            <param name="queryString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetNamedQuery(System.String)">
            <summary>
            Obtain an instance of <see cref="T:NHibernate.IQuery"/> for a named query string defined in the
            mapping file.
            </summary>
            <param name="queryName">The name of a query defined externally.</param>
            <returns>An <see cref="T:NHibernate.IQuery"/> fro a named query string.</returns>
            <remarks>
            The query can be either in <c>hql</c> or <c>sql</c> format.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Instantiate(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
            <summary>
            Give the interceptor an opportunity to override the default instantiation
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AutoFlushIfRequired(Iesi.Collections.ISet)">
            <summary>
            detect in-memory changes, determine if the changes are to tables
            named in the query and, if so, complete execution the flush
            </summary>
            <param name="querySpaces"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.NarrowProxy(System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            If the existing proxy is insufficiently "narrow" (derived), instantiate a 
            new proxy and overwrite the registration of the old one. This breaks == and 
            occurs only for "class" proxies rather than "interface" proxies.
            </summary>
            <param name="proxy"></param>
            <param name="persister"></param>
            <param name="key"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ProxyFor(NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            Grab the existing proxy for an instance, if one exists.
            (otherwise return the instance)
            </summary>
            <param name="persister"></param>
            <param name="key"></param>
            <param name="impl"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddUninitializedEntity(NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode)">
            <summary>
            Create a "temporary" entry for a newly instantiated entity. The entity is 
            uninitialized, but we need the mapping from id to instance in order to guarantee 
            uniqueness.
            </summary>
            <param name="key"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PostHydrate(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object[],System.Object,NHibernate.LockMode)">
            <summary>
            Add the "hydrated state" (an array) of an uninitialized entity to the session. 
            We don't try to resolve any associations yet, because there might be other entities 
            waiting to be read from the ADO datareader we are currently processing
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="values"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ImmediateLoad(System.Type,System.Object)">
            <summary> 
             Load the data for the object with the specified id into a newly created object.
             Do NOT return a proxy.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InternalLoad(System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Return the object with the specified id or throw exception if no row with that id exists. Defer the load,
            return a new proxy or return an existing proxy if possible. Do not check if the object was deleted.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoLoadByObject(System.Object,System.Object,NHibernate.LockMode)">
            <summary>
            Load the data for the object with the specified id into the supplied
            instance. A new key will be assigned to the object. If there is an
            existing uninitialized proxy, this will break identity equals as far
            as the application is concerned.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoLoadByClass(System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Load the data for the object with the specified id into a newly created
            object. A new key will be assigned to the object. If the class supports
            lazy initialization, return a proxy instead, leaving the real work for
            later. This should return an existing proxy where appropriate.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> of the object to load.</param>
            <param name="id">The identifier of the object in the database.</param>
            <param name="checkDeleted">
            A boolean indicating if NHiberate should check if the object has or has not been deleted.
            </param>
            <param name="allowProxyCreation">A boolean indicating if it is allowed to return a Proxy instead of an instance of the <see cref="T:System.Type"/>.</param>
            <returns>
            An loaded instance of the object or a proxy of the object is proxies are allowed.
            </returns>
            <remarks>
            If the parameter <c>checkDeleted</c> is <see langword="false"/> it is possible to return an object that has 
            been deleted by the user in this <see cref="T:NHibernate.ISession"/>.  If the parameter <c>checkDeleted</c> is
            <see langword="true"/> and the object has been deleted then an <see cref="T:NHibernate.ObjectDeletedException"/> will be
            thrown.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoLoad(System.Type,System.Object,NHibernate.LockMode,System.Boolean)">
            <summary>
            Load the data for the object with the specified id into a newly created object
            using "for update", if supported. A new key will be assigned to the object.
            This method always hits the db, and does not create proxies. It should return
            an existing proxy where appropriate.
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <param name="lockMode"></param>
            <param name="allowNull"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Load(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Load the data for the object with the specified id into a newly created object
            using "for update", if supported. A new key will be assigned to the object.
            This should return an existing proxy where appropriate.
            
            If the object does not exist in the database, an exception is thrown.
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <param name="lockMode"></param>
            <returns></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">
            Thrown when the object with the specified id does not exist in the database.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Get(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Load the data for the object with the specified id into a newly created object
            using "for update", if supported. A new key will be assigned to the object.
            This should return an existing proxy where appropriate.
            
            If the object does not exist in the database, null is returned.
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <param name="lockMode"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoLoad(System.Type,System.Object,System.Object,NHibernate.LockMode,System.Boolean)">
            <summary>
            Actually do all the hard work of loading up an object
            </summary>
            <param name="theClass"></param>
            <param name="id"></param>
            <param name="optionalObject"></param>
            <param name="lockMode"></param>
            <param name="checkDeleted"></param>
            <returns></returns>
            <remarks>
            1. see if it is already loaded
            2. see if it is cached
            3. actually go to the database
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InitializeEntity(System.Object)">
            <summary>
            After processing a JDBC result set, we "resolve" all the associations
            between the entities which were instantiated and had their state
            "hydrated" into an array
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Flush">
            <summary>
            
            </summary>
            <remarks>
            This can be called from commit() or at the start of a Find() method.
            <para>
            Perform all the necessary SQL statements in a sensible order, to allow
            users to repect foreign key constraints:
            <list type="">
            	<item>Inserts, in the order they were performed</item>
            	<item>Updates</item>
            	<item>Deletion of collection elements</item>
            	<item>Insertion of collection elements</item>
            	<item>Deletes, in the order they were performed</item>
            </list>
            </para>
            <para>
            Go through all the persistent objects and look for collections they might be
            holding. If they had a nonpersistable collection, substitute a persistable one
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Execute">
            Execute all SQL and second-level cache updates, in a
            special order so that foreign-key constraints cannot
            be violated:
            <ol>
            <li> Inserts, in the order they were performed </li>
            <li> Updates</li>
            <li> Deletion of collection elements</li>
            <li> Insertion of collection elements</li>
            <li> Deletes, in the order they were performed</li>
            </ol>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.FlushEntities">
            <summary>
            1. detect any dirty entities
            2. schedule any entity updates
            3. search out any reachable collections
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PreFlushEntities">
            <summary>
            Process cascade save/update at the start of a flush to discover
            any newly referenced entity that must be passed to
            <see cref="M:NHibernate.Impl.SessionImpl.SaveOrUpdate(System.Object)"/> and also apply orphan delete
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetIdentifier(System.Object)">
            <summary>
            Not for internal use
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetEntityIdentifier(System.Object)">
            <summary>
            Get the id value for an object that is actually associated with the session.
            This is a bit stricter than GetEntityIdentifierIfNotUnsaved().
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.IsSaved(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetEntityIdentifierIfNotUnsaved(System.Object)">
            <summary>
            Used by OneToOneType and ManyToOneType to determine what id value
            should be used for an object that may or may not be associated with
            the session. This does a "best guess" using any/all info available
            to use (not just the EntityEntry).
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.FlushCollections">
            <summary>
            process any unreferenced collections and then inspect all known collections,
            scheduling creates/removes/updates
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PostFlush">
            <summary>
            1. Recreate the collection key -> collection map
            2. rebuild the collection entries
            3. call Interceptor.postFlush()
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PreFlushCollections">
            <summary>
            Initialize the flags of the CollectionEntry, including the
            dirty check.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.UpdateReachableCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Type.IType,System.Object)">
            <summary>
            Initialize the role of the collection.
            The CollectionEntry.reached stuff is just to detect any silly users who set up
            circular or shared references between/to collections.
            </summary>
            <param name="coll"></param>
            <param name="type"></param>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.UpdateUnreachableCollection(NHibernate.Collection.IPersistentCollection)">
            <summary>
            record the fact that this collection was dereferenced
            </summary>
            <param name="coll"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PrepareCollectionForUpdate(NHibernate.Collection.IPersistentCollection,NHibernate.Impl.CollectionEntry)">
            <summary>
            1. record the collection role that this collection is referenced by
            2. decide if the collection needs deleting/creating/updating (but
               don't actually schedule the action yet)
            </summary>
            <param name="coll"></param>
            <param name="entry"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddUninitializedCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            add a collection we just loaded up (still needs initializing)
            </summary>
            <param name="collection"></param>
            <param name="persister"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddInitializedCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            add a collection we just pulled out of the cache (does not need initializing)
            </summary>
            <param name="collection"></param>
            <param name="persister"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddNewCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Add a new collection (i.e. a newly created one, just instantiated by
            the application, with no database state or snapshot)
            </summary>
            <param name="collection"></param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddInitializedDetachedCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Engine.ICollectionSnapshot)">
            <summary>
            Add an (initialized) collection that was created by another session and passed
            into update() (i.e. one with a snapshot and existing state on the database)
            </summary>
            <param name="collection"></param>
            <param name="cs"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetArrayHolder(System.Object)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddArrayHolder(NHibernate.Collection.PersistentArrayHolder)">
            <summary>
            associate a holder with an array - called after loading an array
            </summary>
            <param name="holder"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InitializeCollection(NHibernate.Collection.IPersistentCollection,System.Boolean)">
            <summary>
            called by a collection that wants to initialize itself
            </summary>
            <param name="collection"></param>
            <param name="writing"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Disconnect">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Dispose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Dispose">
            <summary>
            Just in case the user forgot to Commit() or Close()
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this Session is being Disposed of or Finalized.</param>
            <remarks>
            If this Session is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this Session back to life.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetFilterTranslator(System.Object,System.String,NHibernate.Engine.QueryParameters,System.Boolean)">
            <summary>
            1. determine the collection role of the given collection (this may require a flush, if the collection is recorded as unreferenced)
            2. obtain a compiled filter query
            3. autoflush if necessary
            </summary>
            <param name="collection"></param>
            <param name="filter"></param>
            <param name="parameters"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetCollectionEntryOrNull(System.Object)">
            <summary>
            Get the collection entry for a collection passed to filter,
            which might be a collection wrapper, an array, or an unwrapped
            collection. Return <see langword="null" /> if there is no entry.
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Evict(System.Object)">
            <summary>
            remove any hard references to the entity that are held by the infrastructure
            (references held by application or other persistant instances are okay)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.EvictCachedCollections(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
            <summary>
            Evict collections from the factory-level cache
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetCollectionBatch(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="collectionPersister"></param>
            <param name="id"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.LoadByUniqueKey(System.Type,System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="clazz"></param>
            <param name="uniqueKeyPropertyName"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetCollection(System.String,System.Object,System.Object)">
            <summary>
            Instantiate a collection wrapper (called when loading an object)
            </summary>
            <param name="role"></param>
            <param name="id"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InitializeCollectionFromCache(System.Object,System.Object,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
            <summary>
            Try to initialize a Collection from the cache.
            </summary>
            <param name="id"></param>
            <param name="owner"></param>
            <param name="persister"></param>
            <param name="collection"></param>
            <returns><see langword="true" /> if the collection was initialized from the cache, otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.SaveOrUpdateCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Batcher">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Factory">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Timestamp">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.FlushMode">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.IsConnected">
            <summary>
            Gets if the ISession is connected.
            </summary>
            <value>
            <see langword="true"/> if the ISession is connected.
            </value>
            <remarks>
            An ISession is considered connected if there is an <see cref="T:System.Data.IDbConnection"/> (regardless
            of its state) or if it the field <c>connect</c> is true.  Meaning that it will connect
            at the next operation that requires a connection.
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.SqlClientBatchingBatcher">
            <summary>
            Summary description for SqlClientBatchingBatcher.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.SqlClientSqlCommandSet">
            <summary>
            Expose the batch functionality in ADO.Net 2.0
            Microsoft in its wisdom decided to make my life hard and mark it internal.
            Through the use of Reflection and some delegates magic, I opened up the functionality.
            
            Observable performance benefits are 50%+ when used, so it is really worth it.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SqlClientSqlCommandSet.Append(System.Data.SqlClient.SqlCommand)">
            <summary>
            Append a command to the batch
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:NHibernate.Impl.SqlClientSqlCommandSet.AssertHasParameters(System.Data.SqlClient.SqlCommand)">
            <summary>
            This is required because SqlClient.SqlCommandSet will throw if 
            the command has no parameters.
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:NHibernate.Impl.SqlClientSqlCommandSet.ExecuteNonQuery">
            <summary>
            Executes the batch
            </summary>
            <returns>
            This seems to be returning the total number of affected rows in all queries
            </returns>
        </member>
        <member name="M:NHibernate.Impl.SqlClientSqlCommandSet.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:NHibernate.Impl.SqlClientSqlCommandSet.BatchCommand">
            <summary>
            Return the batch command to be executed
            </summary>
        </member>
        <member name="P:NHibernate.Impl.SqlClientSqlCommandSet.CountOfCommands">
            <summary>
            The number of commands batched in this instance
            </summary>
        </member>
        <member name="T:NHibernate.Impl.SqlQueryImpl">
            <summary>
            Implements SQL query passthrough
            </summary>
            <example>
            An example mapping is:
            <code>
            &lt;sql-query-name name="mySqlQuery"&gt;
            &lt;return alias="person" class="eg.Person" /&gt;
            	SELECT {person}.NAME AS {person.name}, {person}.AGE AS {person.age}, {person}.SEX AS {person.sex}
            	FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
            &lt;/sql-query-name&gt;
            </code>
            </example>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String)">
            <summary>
            Declare a "root" entity, without specifying an alias
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.String)">
            <summary>
            Declare a "root" entity
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.String,NHibernate.LockMode)">
            <summary>
            Declare a "root" entity, specifying a lock mode
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.Type)">
            <summary>
            Declare a "root" entity, without specifying an alias
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.Type)">
            <summary>
            Declare a "root" entity
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.Type,NHibernate.LockMode)">
            <summary>
            Declare a "root" entity, specifying a lock mode
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddJoin(System.String,System.String)">
            <summary>
            Declare a "joined" entity
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddJoin(System.String,System.String,NHibernate.LockMode)">
            <summary>
            Declare a "joined" entity, specifying a lock mode
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddScalar(System.String,NHibernate.Type.IType)">
            <summary>
            Declare a scalar query result
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.SetResultSetMapping(System.String)">
            <summary>
            Use a predefined named ResultSetMapping
            </summary>
        </member>
        <member name="T:NHibernate.Impl.Status">
            <summary>
            Represents the status of an entity with respect to 
            this session. These statuses are for internal 
            book-keeping only and are not intended to represent 
            any notion that is visible to the <b>application</b>. 
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Loaded">
            <summary>
            The Entity is snapshotted in the Session with the same state as the database
            (called Managed in H3).
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Deleted">
            <summary>
            The Entity is in the Session and has been marked for deletion but not
            deleted from the database yet.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Gone">
            <summary>
            The Entity has been deleted from database.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Loading">
            <summary>
            The Entity is in the process of being loaded.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Saving">
            <summary>
            The Entity is in the process of being saved.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.WrapVisitor">
            <summary>
            Wrap collections in a NHibernate collection wrapper.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.BasicCollectionJoinWalker">
            <summary>
            Walker for collections of values and many-to-many associations
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.CollectionJoinWalker">
            <summary>
            Superclass of walkers for collection initializers
            <seealso cref="T:NHibernate.Loader.Collection.CollectionLoader"/>
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyJoinWalker"/>
            <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionJoinWalker"/>
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.AddAssociationToJoinTreeIfNecessary(NHibernate.Type.IAssociationType,System.String[],System.String,System.String,System.Int32,NHibernate.SqlCommand.JoinType)">
            <summary>
            Add on association (one-to-one, many-to-one, or a collection) to a list
            of associations to be fetched by outerjoin (if necessary)
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.AddAssociationToJoinTree(NHibernate.Type.IAssociationType,System.String[],System.String,System.String,System.Int32,NHibernate.SqlCommand.JoinType)">
            <summary>
            Add on association (one-to-one, many-to-one, or a collection) to a list
            of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkEntityTree(NHibernate.Persister.Entity.IOuterJoinLoadable,System.String)">
            <summary>
            For an entity class, return a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkCollectionTree(NHibernate.Persister.Collection.IQueryableCollection,System.String)">
            <summary>
            For a collection role, return a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkCollectionTree(NHibernate.Persister.Collection.IQueryableCollection,System.String,System.String,System.Int32)">
            <summary>
            For a collection role, return a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkEntityTree(NHibernate.Persister.Entity.IOuterJoinLoadable,System.String,System.String,System.Int32)">
            <summary>
            For an entity class, add to a list of associations to be fetched
            by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkComponentTree(NHibernate.Type.IAbstractComponentType,System.Int32,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,System.String,System.String,System.Int32)">
            <summary>
            For a component, add to a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkCompositeElementTree(NHibernate.Type.IAbstractComponentType,System.String[],NHibernate.Persister.Collection.IQueryableCollection,System.String,System.String,System.Int32)">
            <summary>
            For a composite element, add to a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.SubPath(System.String,System.String)">
            <summary>
            Extend the path by the given property name
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.GetJoinType(NHibernate.Type.IAssociationType,NHibernate.FetchMode,System.String,System.String,System.String[],System.Boolean,System.Int32,NHibernate.Engine.Cascades.CascadeStyle)">
            <summary>
            Get the join type (inner, outer, etc) or -1 if the
            association should not be joined. Override on
            subclasses.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.GetJoinType(System.Boolean,System.Int32)">
            <summary>
            Use an inner join if it is a non-null association and this
            is the "first" join in a series
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsJoinedFetchEnabledInMapping(NHibernate.FetchMode,NHibernate.Type.IAssociationType)">
            <summary>
            Does the mapping, and Hibernate default semantics, specify that
            this association should be fetched by outer joining
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.Cascades.CascadeStyle)">
            <summary>
            Override on subclasses to enable or suppress joining
            of certain association types
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsDuplicateAssociation(System.String,System.String[])">
            <summary>
            Used to detect circularities in the joined graph, note that
            this method is side-effecty
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsDuplicateAssociation(System.String,System.String[],NHibernate.Type.IAssociationType)">
            <summary>
            Used to detect circularities in the joined graph, note that
            this method is side-effecty
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsJoinable(NHibernate.SqlCommand.JoinType,Iesi.Collections.ISet,System.String,System.String[],NHibernate.Type.IAssociationType,System.Int32)">
            <summary>
            Should we join this association?
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.MergeOuterJoins(System.Collections.IList)">
            <summary>
            Generate a sequence of <c>LEFT OUTER JOIN</c> clauses for the given associations.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.CountEntityPersisters(System.Collections.IList)">
            <summary>
            Count the number of instances of IJoinable which are actually
            also instances of ILoadable, or are one-to-many associations
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.CountCollectionPersisters(System.Collections.IList)">
            <summary>
            Count the number of instances of <see cref="T:NHibernate.Persister.Entity.IJoinable"/> which
            are actually also instances of <see cref="T:NHibernate.Collection.IPersistentCollection"/>
            which are being fetched by outer join
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.OrderBy(System.Collections.IList)">
            <summary>
            Get the order by string required for collection fetching
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WhereString(System.String,System.String[],NHibernate.Type.IType,System.Int32)">
            <summary>
            Render the where condition for a (batch) load by identifier / collection key
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.SelectString(System.Collections.IList)">
            <summary>
            Generate a select list of columns containing all properties of the entity classes
            </summary>
        </member>
        <member name="T:NHibernate.Loader.JoinWalker.AssociationKey">
            <summary>
            Uniquely identifier a foreign key, so that we don't
            join it more than once, and create circularities
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Collection.BasicCollectionJoinWalker.GetJoinType(NHibernate.Type.IAssociationType,NHibernate.FetchMode,System.String,Iesi.Collections.ISet,System.String,System.String[],System.Boolean,System.Int32,NHibernate.Engine.Cascades.CascadeStyle)">
            <summary>
            We can use an inner join for first many-to-many association
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.CollectionLoader">
            <summary>
            Superclass for loaders that initialize collections
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
            <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader"/>
            </summary>
        </member>
        <member name="T:NHibernate.Loader.OuterJoinLoader">
            <summary>
            Implements logic for walking a tree of associated classes.
            </summary>
            <remarks>
            Generates an SQL select string containing all properties of those classes.
            Tablse are joined using an ANSI-style left outer join.
            </remarks>
        </member>
        <member name="T:NHibernate.Loader.Collection.ICollectionInitializer">
            <summary>
            An interface for collection loaders
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Collection.ICollectionInitializer.Initialize(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initialize the given collection
            </summary>
            <param name="id"></param>
            <param name="session"></param>
        </member>
        <member name="T:NHibernate.Loader.Collection.BatchingCollectionInitializer">
            <summary>
            "Batch" loads collections, using multiple foreign key values in the SQL Where clause
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.OneToManyJoinWalker">
            <summary>
            Walker for one-to-many associations
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.OneToManyLoader">
            <summary>
            Loads one-to-many associations
            </summary>
            <remarks>
            The collection persister must implement <see cref="T:NHibernate.Persister.Collection.IQueryableCollection"/>.
            For other collections, create a customized subclass of <see cref="T:NHibernate.Loader.Loader"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.Loader.Collection.SubselectOneToManyLoader">
            <summary>
            Implements subselect fetching for a one to many association
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Criteria.CriteriaJoinWalker">
            <summary>
            A <see cref="T:NHibernate.Loader.JoinWalker"/> for <see cref="T:NHibernate.ICriteria"/> queries.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.AbstractEntityJoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.Cascades.CascadeStyle)">
            <summary>
            The superclass deliberately excludes collections
            </summary>
        </member>
        <member name="P:NHibernate.Loader.AbstractEntityJoinWalker.WhereFragment">
            <summary>
            Don't bother with the discriminator, unless overridden by subclass
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Criteria.CriteriaJoinWalker.WhereFragment">
            <summary>
            Use the discriminator, to narrow the select to instances
            of the queried subclass, also applying any filters.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Criteria.CriteriaLoader">
            <summary>
            A <c>Loader</c> for <see cref="T:NHibernate.ICriteria"/> queries. 
            </summary>
            <remarks>
            Note that criteria
            queries are more like multi-object <c>Load()</c>s than like HQL queries.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumnsUsingProjection(NHibernate.ICriteria,System.String)">
            <summary>
            Get the names of the columns constrained
            by this criterion.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetTypedValue(NHibernate.ICriteria,System.String,System.Object)">
            <summary>
            Get the a typed value for the given property value.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.ColumnCollectionAliases">
            <summary>
            <see cref="T:NHibernate.Loader.ICollectionAliases"/> that uses columnnames instead of generated aliases.
            Aliases can still be overwritten via <c>&lt;return-property&gt;</c>
            </summary>
        </member>
        <member name="T:NHibernate.Loader.ICollectionAliases">
            <summary>
            Type definition of CollectionAliases.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedKeyAliases">
            <summary>
            Returns the suffixed result-set column-aliases for columns making
            up the key for this collection (i.e., its FK to its owner).
            </summary>
            <value>The key result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedIndexAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the collumns
            making up the collection's index (map or list).
            </summary>
            <value>The index result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedElementAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns
            making up the collection's elements.
            </summary>
            <value>The element result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedIdentifierAlias">
            <summary>
            Returns the suffixed result-set column-aliases for the column
            defining the collection's identifier (if any).
            </summary>
            <value>The identifier result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.Suffix">
            <summary>
            Returns the suffix used to unique the column aliases for this
            particular alias set.
            </summary>
            <value>The uniqued column alias suffix.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedKeyAliases">
            <summary>
            Returns the suffixed result-set column-aliases for columns making up the key for this collection (i.e., its FK to
            its owner).
            </summary>
            <value>The key result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedIndexAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the collumns making up the collection's index (map or list).
            </summary>
            <value>The index result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedElementAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's elements.
            </summary>
            <value>The element result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedIdentifierAlias">
            <summary>
            Returns the suffixed result-set column-aliases for the column defining the collection's identifier (if any).
            </summary>
            <value>The identifier result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.Suffix">
            <summary>
            Returns the suffix used to unique the column aliases for this particular alias set.
            </summary>
            <value>The uniqued column alias suffix.</value>
        </member>
        <member name="T:NHibernate.Loader.Custom.ColumnEntityAliases">
            <summary>
            <see cref="T:NHibernate.Loader.IEntityAliases"/> that chooses the column names over the alias names.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.DefaultEntityAliases">
            <summary>
            EntityAliases which handles the logic of selecting user provided aliases (via return-property),
            before using the default aliases.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.IEntityAliases">
            <summary>
            Metadata describing the SQL result set column aliases
            for a particular entity
            </summary>
        </member>
        <member name="M:NHibernate.Loader.IEntityAliases.GetSuffixedPropertyAliases(NHibernate.Persister.Entity.ILoadable)">
            <summary>
            The result set column aliases for the property columns of a subclass
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.SuffixedKeyAliases">
            <summary>
            The result set column aliases for the primary key columns
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.SuffixedDiscriminatorAlias">
            <summary>
            The result set column aliases for the discriminator columns
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.SuffixedVersionAliases">
            <summary>
            The result set column aliases for the version columns
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.SuffixedPropertyAliases">
            <summary>
            The result set column aliases for the property columns
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.RowIdAlias">
            <summary>
            The result set column alias for the Oracle row id
            </summary>
        </member>
        <member name="M:NHibernate.Loader.DefaultEntityAliases.#ctor(System.Collections.IDictionary,NHibernate.Persister.Entity.ILoadable,System.String)">
            <summary>
            Calculate and cache select-clause suffixes.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.ICustomQuery.NamedParameterBindPoints">
            <summary>
            Optional, may return <see langword="null" />
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Custom.SQLQueryParser.substituteParams(System.String)">
             Substitues JDBC parameter placeholders (?) for all encountered
             parameter specifications.  It also tracks the positions of these
             parameter specifications within the query string.  This accounts for
             ordinal-params, named-params, and ejb3-positional-params.
            
             @param sqlString The query string.
             @return The SQL query with parameter substitution complete.
        </member>
        <member name="T:NHibernate.Loader.Custom.SQLQueryCollectionReturn">
            <summary>
            Represents a return defined as part of a native sql query which
            names a collection role in the form {classname}.{collectionrole}; it
            is used in defining a custom sql query for loading an entity's
            collection in non-fetching scenarios (i.e., loading the collection
            itself as the "root" of the result).
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.SQLQueryNonScalarReturn">
            <summary>
            Represents the base information for a return defined as part of
            a native sql query.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.SQLQueryCollectionReturn.OwnerEntityName">
            <summary>
            Returns the class owning the collection.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.SQLQueryCollectionReturn.OwnerProperty">
            <summary>
            Returns the name of the property representing the collection from the <see cref="P:NHibernate.Loader.Custom.SQLQueryCollectionReturn.OwnerEntityName"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.SQLQueryJoinReturn">
            <summary>
            Represents a return defined as part of a native sql query which
            names a fetched role.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.SQLQueryRootReturn">
            <summary>
            Represents a return defined as part of a native sql query which
            names a "root" entity.  A root entity means it is explicitly a
            "column" in the result, as opposed to a fetched relationship or role.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.AbstractEntityLoader">
            <summary>
            Abstract superclass for entity loaders that use outer joins
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.IUniqueEntityLoader">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Loader.Entity.IUniqueEntityLoader.Load(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an entity instance. If <c>OptionalObject</c> is supplied, load the entity
            state into the given (uninitialized) object
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.BatchingEntityLoader">
            <summary>
            "Batch" loads entities, using multiple primary key values in the
            SQL <c>where</c> clause.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.EntityJoinWalker">
            <summary>
            A walker for loaders that fetch entities
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Entity.EntityJoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.Cascades.CascadeStyle)">
            <summary>
            Disable outer join fetching if this loader obtains an
            upgrade lock mode
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.EntityLoader">
            <summary>
            Load an entity using outerjoin fetching to fetch associated entities.
            </summary>
            <remarks>
            The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> must implement <see cref="T:NHibernate.Persister.Entity.ILoadable"/>. For other entities,
            create a customized subclass of <see cref="T:NHibernate.Loader.Loader"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.Loader.GeneratedCollectionAliases">
            <summary>
            CollectionAliases which handles the logic of selecting user provided aliases (via return-property),
            before using the default aliases.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedKeyAliases">
            <summary>
            Returns the suffixed result-set column-aliases for columns making up the key for this collection (i.e., its FK to
            its owner).
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedIndexAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the collumns making up the collection's index (map or list).
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedElementAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's elements.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedIdentifierAlias">
            <summary>
            Returns the suffixed result-set column-aliases for the column defining the collection's identifier (if any).
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.Suffix">
            <summary>
            Returns the suffix used to unique the column aliases for this particular alias set.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinableAssociation.GetPosition(System.String,System.Collections.IList)">
            <summary>
            Get the position of the join with the given alias in the
            list of joins
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IRelationalModel">
            <summary>
            Operations to create/drop the mapping element in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IRelationalModel.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to create 
            the mapping element in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create an object.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.IRelationalModel.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to drop 
            the mapping element from the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop an object.
            </returns>
        </member>
        <member name="T:NHibernate.Mapping.Any">
            <summary>
            A NHibernate <c>any</c> type.
            </summary>
            <remarks>
            Polymorphic association to one of several tables.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.SimpleValue">
            <summary>
            Any value that maps to columns.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IKeyValue">
            <summary>
            Represents an identifying key of a table: the value for primary key
            of an entity, or a foreign key of a collection or join table or
            joined subclass table.
            </summary>
            <remarks>
            Author: Gavin King
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.IValue">
            <summary>
            A value is anything that is persisted by value, instead of
            by reference. It is essentially a Hibernate IType, together
            with zero or more columns. Values are wrapped by things with 
            higher level semantics, for example properties, collections, 
            classes.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IValue.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IValue.IsValid(NHibernate.Engine.IMapping)">
            <summary>
            Determines if the Value is part of a valid mapping.
            </summary>
            <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> to validate.</param>
            <returns>
            <see langword="true"/> if the Value is part of a valid mapping, <see langword="false"/>
            otherwise.
            </returns>
            <exception cref="T:NHibernate.MappingException"></exception>
            <remarks>
            Mainly used to make sure that Value maps to the correct number
            of columns.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.IValue.ColumnSpan">
            <summary>
            Gets the number of columns that this value spans in the table.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects
            that this value is stored in.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.Type">
            <summary>
            Gets the <see cref="T:NHibernate.Type.IType"/> to read/write the Values.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.Table">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.IValue.Table"/> this Value is stored in.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsUnique">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this Value is unique.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsNullable">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this Value can have
            null values.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsSimpleValue">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this is a SimpleValue
            that does not involve foreign keys.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Any.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.Any.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="P:NHibernate.Mapping.Any.IdentifierType">
            <summary>
            Get or set the identifier type 
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Any.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Any.MetaType">
            <summary>
            Get or set the metatype 
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Array">
            <summary>
            An array has a primary key consisting of the key columns + index column
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.List">
            <summary>
            A list has a primary key consisting of the key columns + index column
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IndexedCollection">
            <summary>
            Indexed collections include IList, IDictionary, Arrays
            and primitive Arrays.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Collection">
            <summary>
            Base class that stores the mapping information for <c>&lt;array&gt;</c>, <c>&lt;bag&gt;</c>, 
            <c>&lt;id-bag&gt;</c>, <c>&lt;list&gt;</c>, <c>&lt;map&gt;</c>, and <c>&lt;set&gt;</c>
            collections.
            </summary>
            <remarks> 
            Subclasses are responsible for the specialization required for the particular
            collection style.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.IFetchable">
            <summary>
            Any mapping with an outer-join attribute
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IFilterable">
            <summary>
            Defines mapping elements to which filters may be applied.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsGeneric">
            <summary>
            Gets or sets a <see cref="T:System.Boolean"/> indicating if this is a 
            mapping for a generic collection.
            </summary>
            <value>
            <see langword="true"/> if a collection from the System.Collections.Generic namespace
            should be used, <see langword="false"/> if a collection from the System.Collections 
            namespace should be used.
            </value>
            <remarks>
            This has no affect on any versions of the .net framework before .net-2.0.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Collection.GenericArguments">
            <summary>
            Gets or sets an array of <see cref="T:System.Type"/> that contains the arguments
            needed to construct an instance of a closed type.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.List.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.List"/> class.
            </summary>
            <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that contains this list mapping.</param>
        </member>
        <member name="P:NHibernate.Mapping.List.DefaultCollectionType">
            <summary>
            Gets the appropriate <see cref="T:NHibernate.Type.CollectionType"/> that is 
            specialized for this list mapping.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Bag">
            <summary>
            A bag permits duplicates, so it has no primary key
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Bag.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.Bag"/> class.
            </summary>
            <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that contains this bag mapping.</param>
        </member>
        <member name="M:NHibernate.Mapping.Bag.CreatePrimaryKey">
            <summary>
            
            </summary>
            <remarks>Should we create an index on the key columns?</remarks>
        </member>
        <member name="P:NHibernate.Mapping.Bag.DefaultCollectionType">
            <summary>
            Gets the appropriate <see cref="T:NHibernate.Type.CollectionType"/> that is 
            specialized for this bag mapping.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Column">
            <summary>
            Represents the mapping to a column in a database.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.Column.uniqueInteger">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetQuotedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the name of this Column in quoted form if it is necessary.
            </summary>
            <param name="d">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote
            the column name.
            </param>
            <returns>
            The column name in a form that is safe to use inside of a SQL statement.
            Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetAlias(NHibernate.Dialect.Dialect)">
            For any column name, generate an alias that is unique
            to that column name, and also 10 characters or less
            in length.
        </member>
        <member name="M:NHibernate.Mapping.Column.GetAlias(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Gets an Alias for the column name.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> that contains the rules for Aliasing.</param>
            <param name="suffix">A string to use as the suffix for the Alias.</param>
            <returns>
            A string that can be used as the alias for this Column.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.#ctor(NHibernate.Type.IType,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Column"/>.
            </summary>
            <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType"/> that reads from and writes to the column.</param>
            <param name="typeIndex">The index of the column in the <see cref="T:NHibernate.Type.IType"/>.</param>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetAutoSqlType(NHibernate.Engine.IMapping)">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.Column.SqlType"/> of the column based on the <see cref="T:NHibernate.Type.IType"/>.
            </summary>
            <param name="mapping"></param>
            <returns>
            The <see cref="P:NHibernate.Mapping.Column.SqlType"/> of the column based on the <see cref="T:NHibernate.Type.IType"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetSqlType(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping)">
            <summary>
            Gets the name of the data type for the column.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use to get the valid data types.</param>
            <param name="mapping"></param>
            <returns>
            The name of the data type for the column. 
            </returns>
            <remarks>
            If the mapping file contains a value of the attribute <c>sql-type</c> this will
            return the string contained in that attribute.  Otherwise it will use the 
            typename from the <see cref="T:NHibernate.Dialect.Dialect"/> of the <see cref="P:NHibernate.Mapping.Column.SqlType"/> object. 
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Column.Equals(System.Object)">
            <summary>
            Determines if this instance of <see cref="T:NHibernate.Mapping.Column"/> and a specified object, 
            which must be a <b>Column</b> can be considered the same.
            </summary>
            <param name="obj">An <see cref="T:System.Object"/> that should be a <see cref="T:NHibernate.Mapping.Column"/>.</param>
            <returns>
            <see langword="true"/> if the name of this Column and the other Column are the same, 
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.Equals(NHibernate.Mapping.Column)">
            <summary>
            Determines if this instance of <see cref="T:NHibernate.Mapping.Column"/> and the specified Column 
            can be considered the same.
            </summary>
            <param name="column">A <see cref="T:NHibernate.Mapping.Column"/> to compare to this Column.</param>
            <returns>
            <see langword="true"/> if the name of this Column and the other Column are the same, 
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <value>The value of Name.GetHashCode().</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Length">
            <summary>
            Gets or sets the length of the datatype in the database.
            </summary>
            <value>The length of the datatype in the database.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Type">
            <summary>
            Gets or sets the NHibernate <see cref="T:NHibernate.Type.IType"/> of the column.
            </summary>
            <value>
            The NHibernate <see cref="T:NHibernate.Type.IType"/> of the column.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Name">
            <summary>
            Gets or sets the name of the column in the database.
            </summary>
            <value>
            The name of the column in the database.  The get does 
            not return a Quoted column name.
            </value>
            <remarks>
            <p>
            If a value is passed in that is wrapped by <c>`</c> then 
            NHibernate will Quote the column whenever SQL is generated
            for it.  How the column is quoted depends on the Dialect.
            </p>
            <p>
            The value returned by the getter is not Quoted.  To get the
            column name in quoted form use <see cref="M:NHibernate.Mapping.Column.GetQuotedName(NHibernate.Dialect.Dialect)"/>.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsNullable">
            <summary>
            Gets or sets if the column can have null values in it.
            </summary>
            <value><see langword="true" /> if the column can have a null value in it.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.TypeIndex">
            <summary>
            Gets or sets the index of the column in the <see cref="T:NHibernate.Type.IType"/>.
            </summary>
            <value>
            The index of the column in the <see cref="T:NHibernate.Type.IType"/>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsUnique">
            <summary>
            Gets or sets if the column contains unique values.
            </summary>
            <value><see langword="true" /> if the column contains unique values.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.SqlType">
            <summary>
            Gets or sets the sql data type name of the column.
            </summary>
            <value>
            The sql data type name of the column. 
            </value>
            <remarks>
            This is usually read from the <c>sql-type</c> attribute.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsQuoted">
            <summary>
            Gets or sets if the column needs to be quoted in SQL statements.
            </summary>
            <value><see langword="true" /> if the column is quoted.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Unique">
            <summary>
            Gets or sets whether the column is unique.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Column.CheckConstraint">
            <summary>
            Gets or sets a check constraint on the column
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Column.HasCheckConstraint">
            <summary>
            Do we have a check constraint?
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Component">
            <summary>
            The mapping for a component, composite element, composite identifier,
            etc.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Component.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="P:NHibernate.Mapping.Component.PropertySpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.PropertyCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ColumnSpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ColumnCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.IsEmbedded">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.IsDynamic">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ComponentClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.Owner">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ParentProperty">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.Properties">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Constraint">
            <summary>
            Base class for relational constraints in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the constraint.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Constraint.</param>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String)">
            <summary>
            Generates the SQL string to create this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create this Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to create the named
            Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the named Constraint.
            </returns>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.Name">
            <summary>
            Gets or sets the Name used to identify the constraint in the database.
            </summary>
            <value>The Name used to identify the constraint in the database.</value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are part of the constraint.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are part of the constraint.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.ColumnSpan">
            <summary>
            Gets the number of columns that this Constraint contains.
            </summary>
            <value>
            The number of columns that this Constraint contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.Table">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Constraint.Table"/> this Constraint is in.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Constraint.Table"/> this Constraint is in.
            </value>
        </member>
        <member name="T:NHibernate.Mapping.ForeignKey">
            <summary>
            A Foreign Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.ForeignKey"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to create the named Foreign Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the named Foreign Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="P:NHibernate.Mapping.ForeignKey.ReferencedTable">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Table"/> that the Foreign Key is referencing.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Table"/> the Foreign Key is referencing.</value>
            <exception cref="T:NHibernate.MappingException">
            Thrown when the number of columns in this Foreign Key is not the same
            amount of columns as the Primary Key in the ReferencedTable.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.ForeignKey.ReferencedClass">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> that this Foreign Key is referencing.
            </summary>
            <value>
            The <see cref="T:System.Type"/> that this Foreign Key is referencing.
            </value>
        </member>
        <member name="T:NHibernate.Mapping.Formula">
            <summary>
            A formula is a derived column value.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Formula.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.Formula.GetTemplate(NHibernate.Dialect.Dialect,NHibernate.Dialect.Function.SQLFunctionRegistry)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Mapping.Formula.FormulaString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.IdentifierBag">
            <summary>
            An <c>PersistentIdentifierBag</c> has a primary key consistenting of just
            the identifier column.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IdentifierCollection">
            <summary>
            A collection with a synthetic "identifier" column.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.CreatePrimaryKey">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.IdentifierCollection.Identifier">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.IdentifierCollection.IsIdentified">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Index">
            <summary>
            An Index in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Index.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String)">
            <summary>
            Generates the SQL string to create this Index in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create this Index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Index.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to drop this Index in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Index.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the Index.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Index.</param>
        </member>
        <member name="P:NHibernate.Mapping.Index.Table">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Index.Table"/> this Index is in.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Index.Table"/> this Index is in.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Index.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Index.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Index.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Index.Name">
            <summary>
            Gets or sets the Name used to identify the Index in the database.
            </summary>
            <value>The Name used to identify the Index in the database.</value>
        </member>
        <member name="T:NHibernate.Mapping.IntegerValue">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.IntegerValue.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="P:NHibernate.Mapping.IntegerValue.Type">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.ManyToOne">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.ToOne">
            <summary>
            A simple-point association (ie. a reference to another entity).
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ToOne.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ToOne.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ToOne.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="P:NHibernate.Mapping.ToOne.FetchMode">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.ToOne.ReferencedPropertyName">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.ManyToOne.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.ManyToOne.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="M:NHibernate.Mapping.ManyToOne.CreateForeignKey">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Map">
            <summary>
            A map has a primary key consisting of the key columns 
            + index columns.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Map.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.Map"/> class.
            </summary>
            <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that contains this map mapping.</param>
        </member>
        <member name="P:NHibernate.Mapping.Map.DefaultCollectionType">
            <summary>
            Gets the appropriate <see cref="P:NHibernate.Mapping.Map.CollectionType"/> that is 
            specialized for this list mapping.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.MetaAttribute">
            <summary>
            A meta attribute is a named value or values.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.MetaAttribute.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.MetaAttribute.AddValue(System.String)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:NHibernate.Mapping.MetaAttribute.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.MetaAttribute.Values">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.MetaAttribute.Value">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.MetaAttribute.IsMultiValued">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.OneToMany">
            <summary>
            A mapping for a <c>one-to-many</c> association.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToMany.IsValid(NHibernate.Engine.IMapping)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToMany.CreateForeignKey">
            <summary>
            
            </summary>
            <remarks>No foreign key element for a one-to-many</remarks>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.ColumnCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.ColumnSpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.AssociatedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.Formula">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.Table">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsNullable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsSimpleValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsUnique">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.FetchMode">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.OneToOne">
            <summary>
            A mapping for a <c>one-to-one</c> association.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToOne.#ctor(NHibernate.Mapping.Table,NHibernate.Mapping.SimpleValue)">
            <summary>
            
            </summary>
            <param name="table"></param>
            <param name="identifier"></param>
        </member>
        <member name="M:NHibernate.Mapping.OneToOne.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="M:NHibernate.Mapping.OneToOne.CreateForeignKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.ConstraintColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.IsConstrained">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.ForeignKeyDirection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.Identifier">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.IsNullable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.PersistentClass">
            <summary>
            Base class for the <see cref="T:NHibernate.Mapping.RootClass"/> mapped by <c>&lt;class&gt;</c> and a 
            <see cref="T:NHibernate.Mapping.Subclass"/> that is mapped by <c>&lt;subclass&gt;</c> or 
            <c>&lt;joined-subclass&gt;</c>.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PersistentClass.NullDiscriminatorMapping">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Mapping.PersistentClass.NotNullDiscriminatorMapping">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclass(NHibernate.Mapping.Subclass)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Subclass"/> to the class hierarchy.
            </summary>
            <param name="subclass">The <see cref="T:NHibernate.Mapping.Subclass"/> to add to the hierarchy.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            Change the property definition or add a new property definition
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> to add.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclassProperty(NHibernate.Mapping.Property)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Property"/> that is implemented by a subclass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> implemented by a subclass.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclassTable(NHibernate.Mapping.Table)">
            <summary>
            Adds a <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> that a subclass is stored in.
            </summary>
            <param name="table">The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> the subclass is stored in.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.CreatePrimaryKey(NHibernate.Dialect.Dialect)">
            <summary>
            Creates the <see cref="T:NHibernate.Mapping.PrimaryKey"/> for the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/>
            this type is persisted in.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> that is used to Alias columns.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.GetProperty(System.String)">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.GetReferencedProperty(System.String)">
            <summary>
            Given a property path, locate the appropriate referenceable property reference.
            </summary>
            <remarks>
            A referenceable property is a property  which can be a target of a foreign-key
            mapping (an identifier or explicitly named in a property-ref).
            </remarks>
            <param name="propertyPath">The property path to resolve into a property reference.</param>
            <returns>The property reference (never null).</returns>
            <exception cref="T:NHibernate.MappingException">If the property could not be found.</exception>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DynamicInsert">
            <summary>
            Gets or Sets if the Insert Sql is built dynamically.
            </summary>
            <value><see langword="true" /> if the Sql is built at runtime.</value>
            <remarks>
            The value of this is set by the <c>dynamic-insert</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DynamicUpdate">
            <summary>
            Gets or Sets if the Update Sql is built dynamically.
            </summary>
            <value><see langword="true" /> if the Sql is built at runtime.</value>
            <remarks>
            The value of this is set by the <c>dynamic-update</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DiscriminatorValue">
            <summary>
            Gets or Sets the value to use as the discriminator for the Class.
            </summary>
            <value>
            A value that distinguishes this subclass in the database.
            </value>
            <remarks>
            The value of this is set by the <c>discriminator-value</c> attribute.  Each <c>&lt;subclass&gt;</c>
            in a heirarchy must define a unique <c>discriminator-value</c>.  The default value 
            is the class name if no value is supplied.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasSubclasses">
            <summary>
            Gets a boolean indicating if this PersistentClass has any subclasses.
            </summary>
            <value><see langword="true" /> if this PeristentClass has any subclasses.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassSpan">
            <summary>
            Gets the number of subclasses that inherit either directly or indirectly.
            </summary>
            <value>The number of subclasses that inherit from this PersistentClass.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassCollection">
            <summary>
            Gets the Collection of Subclasses for this PersistentClass.  
            </summary>
            <value>
            It will recursively go through Subclasses so that if a Subclass has Subclasses
            it will pick those up also.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DirectSubclasses">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Subclass"/> objects
            that directly inherit from this PersistentClass.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Subclass"/> objects
            that directly inherit from this PersistentClass.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Table">
            <summary>
            Gets or Sets the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> that this class is stored in.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> this class is stored in.</value>
            <remarks>
            The value of this is set by the <c>table</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.PropertyCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.MappedClass">
            <summary>
            Gets the <see cref="T:System.Type"/> that is being mapped.
            </summary>
            <value>The <see cref="T:System.Type"/> that is being mapped.</value>
            <remarks>
            The value of this is set by the <c>name</c> attribute on the <c>&lt;class&gt;</c> 
            element.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Name">
            <summary>
            Gets the fully qualified name of the type being persisted.
            </summary>
            <value>The fully qualified name of the type being persisted.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsMutable">
            <summary>
            When implemented by a class, gets or set a boolean indicating 
            if the mapped class has properties that can be changed.
            </summary>
            <value><see langword="true" /> if the object is mutable.</value>
            <remarks>
            The value of this is set by the <c>mutable</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasIdentifierProperty">
            <summary>
            When implemented by a class, gets a boolean indicating
            if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><see langword="true" /> if there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IdentifierProperty">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.Property"/>
            that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Identifier">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Version">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.Property"/>
            that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Discriminator">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsInherited">
            <summary>
            When implemented by a class, gets a boolean indicating if this
            mapped class is inherited from another. 
            </summary>
            <value>
            <see langword="true" /> if this class is a <c>subclass</c> or <c>joined-subclass</c>
            that inherited from another <c>class</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsPolymorphic">
            <summary>
            When implemented by a class, gets or sets if the mapped class has subclasses or is
            a subclass.
            </summary>
            <value>
            <see langword="true" /> if the mapped class has subclasses or is a subclass.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsVersioned">
            <summary>
            When implemented by a class, gets a boolean indicating if the mapped class
            has a version property.
            </summary>
            <value><see langword="true" /> if there is a <c>&lt;version&gt;</c> property.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.CacheConcurrencyStrategy">
            <summary>
            When implemented by a class, gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The CacheConcurrencyStrategy used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Superclass">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/>
            that this mapped class is extending.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsExplicitPolymorphism">
            <summary>
            When implemented by a class, gets or sets a boolean indicating if 
            explicit polymorphism should be used in Queries.
            </summary>
            <value>
            <see langword="true" /> if only classes queried on should be returned, <see langword="false" />
            if any class in the heirarchy should implicitly be returned.</value>
            <remarks>
            The value of this is set by the <c>polymorphism</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.PropertyClosureCollection">
            <summary>
            When implemented by a class, gets an <see cref="T:System.Collections.ICollection"/> 
            of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
            <remarks>
            This is all of the properties of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.TableClosureCollection">
            <summary>
            When implemented by a class, gets an <see cref="T:System.Collections.ICollection"/> 
            of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that this mapped class reads from
            and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            This is all of the tables of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassPropertyClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that
            this mapped class contains and that all of its subclasses contain.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that
            this mapped class contains and that all of its subclasses contain.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassTableClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of all of the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that the 
            subclass finds its information in.  
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects.</value>
            <remarks>It adds the TableClosureCollection and the subclassTables into the ICollection.</remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.ProxyInterface">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> to use as a Proxy.
            </summary>
            <value>The <see cref="T:System.Type"/> to use as a Proxy.</value>
            <remarks>
            The value of this is set by the <c>proxy</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsForceDiscriminator">
            <summary>
            Gets or sets a boolean indicating if only values in the discriminator column that
            are mapped will be included in the sql.
            </summary>
            <value><see langword="true" /> if the mapped discriminator values should be forced.</value>
            <remarks>
            The value of this is set by the <c>force</c> attribute on the <c>discriminator</c> element. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorValueNotNull">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorValueNull">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasEmbeddedIdentifier">
            <summary>
            When implemented by a class, gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><see langword="true" /> if the class identifies itself.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.ClassPersisterClass">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:System.Type"/> of the Persister.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.RootTable">
            <summary>
            When implemented by a class, gets the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> of the class that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.RootClazz">
            <summary>
            When implemented by a class, gets the <see cref="T:NHibernate.Mapping.RootClass"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.RootClass"/> of the class that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Key">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.BatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SelectBeforeUpdate">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Where">
            <summary>
            When implemented by a class, gets or sets the sql string that should 
            be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
            <remarks>
            The value of this is set by the <c>where</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.ReferenceablePropertyCollection">
            <summary>
            Build a collection of properties which are "referenceable".
            </summary>
            <remarks>
            See <see cref="M:NHibernate.Mapping.PersistentClass.GetReferencedProperty(System.String)"/> for a discussion of "referenceable".
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.PrimaryKey">
            <summary>
            A Primary Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to create the Primary Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the Primary Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to create the named Primary Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the named Primary Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="T:NHibernate.Mapping.PrimitiveArray">
            <summary>
            A primitive array has a primary key consisting 
            of the key columns + index column.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.PrimitiveArray.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:NHibernate.Mapping.PrimitiveArray.IsPrimitiveArray">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Property">
            <summary>
            Mapping for a property of a .NET class (entity
            or component).
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.ColumnSpan">
            <summary>
            Gets the number of columns this property uses in the db.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/>s.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.Name">
            <summary>
            Gets or Sets the name of the Property in the class.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.IsNullable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.PropertyGeneration">
            <summary>
             Indicates whether given properties are generated by the database and, if
            so, at what time(s) they are generated.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PropertyGeneration.Never">
            <summary>
            Values for this property are never generated by the database.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PropertyGeneration.Insert">
            <summary>
            Values for this property are generated by the database on insert.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PropertyGeneration.Always">
            <summary>
            Values for this property are generated by the database on both insert and update.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.RootClass">
            <summary>
            Declaration of a System.Type mapped with the <c>&lt;class&gt;</c> element that
            is the root class of a table-per-sublcass, or table-per-concrete-class 
            inheritance heirarchy.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.RootClass.DefaultIdentifierColumnName">
            <summary>
            The default name of the column for the Identifier
            </summary>
            <value><c>id</c> is the default column name for the Identifier.</value>
        </member>
        <member name="F:NHibernate.Mapping.RootClass.DefaultDiscriminatorColumnName">
            <summary>
            The default name of the column for the Discriminator
            </summary>
            <value><c>class</c> is the default column name for the Discriminator.</value>
        </member>
        <member name="M:NHibernate.Mapping.RootClass.AddSubclass(NHibernate.Mapping.Subclass)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Subclass"/> to the class hierarchy.
            </summary>
            <param name="subclass">The <see cref="T:NHibernate.Mapping.Subclass"/> to add to the hierarchy.</param>
            <remarks>
            When a <see cref="T:NHibernate.Mapping.Subclass"/> is added this mapped class has the property <see cref="P:NHibernate.Mapping.RootClass.IsPolymorphic"/>
            set to <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.RootClass.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IdentifierProperty">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Identifier">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.HasIdentifierProperty">
            <summary>
            Gets a boolean indicating if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><see langword="true" /> if there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Discriminator">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsInherited">
            <summary>
            Gets a boolean indicating if this mapped class is inherited from another. 
            </summary>
            <value>
            <see langword="false" /> because this is the root mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsPolymorphic">
            <summary>
            Gets or sets if the mapped class has subclasses.
            </summary>
            <value>
            <see langword="true" /> if the mapped class has subclasses.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.RootClazz">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.RootClass"/> of the class that is mapped in the <c>class</c> element.
            </summary>
            <value>
            <c>this</c> since this is the root mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.PropertyClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.TableClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Table"/> objects that this 
            mapped class reads from and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            There is only one <see cref="T:NHibernate.Mapping.Table"/> in the <see cref="T:System.Collections.ICollection"/> since
            this is the root class.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsExplicitPolymorphism">
            <summary>
            Gets or sets a boolean indicating if explicit polymorphism should be used in Queries.
            </summary>
            <value>
            <see langword="true" /> if only classes queried on should be returned, <see langword="false" />
            if any class in the heirarchy should implicitly be returned.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Version">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsVersioned">
            <summary>
            Gets a boolean indicating if the mapped class has a version property.
            </summary>
            <value><see langword="true" /> if there is a Property for a <c>version</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.CacheConcurrencyStrategy">
            <summary>
            Gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The CacheConcurrencyStrategy used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.CacheRegionName">
            <summary>
            Gets or sets the cache region name.
            </summary>
            <value>The region name used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsMutable">
            <summary>
            Gets or set a boolean indicating if the mapped class has properties that can be changed.
            </summary>
            <value><see langword="true" /> if the object is mutable.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.HasEmbeddedIdentifier">
            <summary>
            Gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><see langword="true" /> if the class identifies itself.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.ClassPersisterClass">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> of the Persister.
            </summary>
            <value>The <see cref="T:System.Type"/> of the Persister.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.RootTable">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Table"/> of the class this mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Superclass">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </summary>
            <value>
            <see langword="null"/> since this is the root class.
            </value>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the setter is called.  The Superclass can not be set on the 
            RootClass, only the Subclass can have a Superclass set.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Key">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsForceDiscriminator">
            <summary>
            Gets or sets a boolean indicating if only values in the discriminator column that
            are mapped will be included in the sql.
            </summary>
            <value><see langword="true" /> if the mapped discriminator values should be forced.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Where">
            <summary>
            Gets or sets the sql string that should be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Set">
            <summary>
            A Set with no nullable element columns will have a primary
            key consisting of all table columns (ie - key columns + 
            element columns).
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Subclass">
            <summary>
            Declaration of a System.Type mapped with the <c>&lt;subclass&gt;</c> or 
            <c>&lt;joined-subclass&gt;</c> element.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.Subclass"/> class.
            </summary>
            <param name="superclass">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that is the superclass.</param>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            Add the <see cref="T:NHibernate.Mapping.Property"/> to this PersistentClass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> to add.</param>
            <remarks>
            This also adds the <see cref="T:NHibernate.Mapping.Property"/> to the Superclass' collection
            of Subclass Properties.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddSubclassProperty(NHibernate.Mapping.Property)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Property"/> that is implemented by a subclass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> implemented by a subclass.</param>
            <remarks>
            This also adds the <see cref="T:NHibernate.Mapping.Property"/> to the Superclass' collection
            of Subclass Properties.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddSubclassTable(NHibernate.Mapping.Table)">
            <summary>
            Adds a <see cref="P:NHibernate.Mapping.Subclass.Table"/> that a subclass is stored in.
            </summary>
            <param name="table">The <see cref="P:NHibernate.Mapping.Subclass.Table"/> the subclass is stored in.</param>
            <remarks>
            This also adds the <see cref="P:NHibernate.Mapping.Subclass.Table"/> to the Superclass' collection
            of Subclass Tables.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.CacheConcurrencyStrategy">
            <summary>
            Gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The CacheConcurrencyStrategy used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.RootClazz">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.RootClass"/> of the class that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.RootClass"/> of the Superclass that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Superclass">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.ClassPersisterClass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IdentifierProperty">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> from the Superclass that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Identifier">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> from the Superclass that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.HasIdentifierProperty">
            <summary>
            Gets a boolean indicating if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><see langword="true" /> if in the Superclass there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Discriminator">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> from the Superclass that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsMutable">
            <summary>
            Gets or set a boolean indicating if the mapped class has properties that can be changed.
            </summary>
            <value><see langword="true" /> if the Superclass is mutable.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsInherited">
            <summary>
            Gets a boolean indicating if this mapped class is inherited from another. 
            </summary>
            <value>
            <see langword="true" /> because this is a Subclass.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsPolymorphic">
            <summary>
            Gets or sets if the mapped class is a subclass.
            </summary>
            <value>
            <see langword="true" /> since this mapped class is a subclass.
            </value>
            <remarks>
            The setter should not be used to set the value to anything but <see langword="true" />.  
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Table">
            <summary>
            Gets or Sets the <see cref="P:NHibernate.Mapping.Subclass.Table"/> that this class is stored in.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.Subclass.Table"/> this class is stored in.</value>
            <remarks>
            This also adds the <see cref="P:NHibernate.Mapping.Subclass.Table"/> to the Superclass' collection
            of Subclass Tables.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.PropertyClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
            <remarks>
            This is all of the properties of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.TableClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.Subclass.Table"/> objects that this 
            mapped class reads from and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.Subclass.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            This is all of the tables of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsVersioned">
            <summary>
            Gets a boolean indicating if the mapped class has a version property.
            </summary>
            <value><see langword="true" /> if for the Superclass there is a Property for a <c>version</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Version">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> from the Superclass that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.HasEmbeddedIdentifier">
            <summary>
            Gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><see langword="true" /> if the Superclass has an embedded identifier.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.RootTable">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.Subclass.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Subclass.Table"/> of the Superclass that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Key">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsExplicitPolymorphism">
            <summary>
            Gets or sets a boolean indicating if explicit polymorphism should be used in Queries.
            </summary>
            <value>
            The value of the Superclasses <c>IsExplicitPolymorphism</c> property.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Where">
            <summary>
            Gets the sql string that should be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the setter is called.  The where clause can not be set on the 
            Subclass, only the RootClass.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Table">
            <summary>
            Represents a Table in a database that an object gets mapped against.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Table.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Table"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQualifiedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the schema qualified name of the Table.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to Quote the Table name.</param>
            <returns>The name of the table qualified with the schema if one is specified.</returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQualifiedName(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Gets the schema qualified name of the Table using the specified qualifier
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to Quote the Table name.</param>
            <param name="defaultQualifier">The Qualifier to use when accessing the table.</param>
            <returns>A String representing the Qualified name.</returns>
            <remarks>If this were used with MSSQL it would return a dbo.table_name.</remarks>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQuotedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the name of this Table in quoted form if it is necessary.
            </summary>
            <param name="dialect">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote the Table name.
            </param>
            <returns>
            The Table name in a form that is safe to use inside of a SQL statement.
            Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQuotedSchemaName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the schema for this table in quoted form if it is necessary.
            </summary>
            <param name="dialect">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote the table name.
            </param>
            <returns>
            The schema name for this table in a form that is safe to use inside
            of a SQL statement. Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetColumn(System.Int32)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.Column"/> at the specified index.
            </summary>
            <param name="n">The index of the Column to get.</param>
            <returns> 
            The <see cref="T:NHibernate.Mapping.Column"/> at the specified index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the Table.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Table.</param>
        </member>
        <member name="M:NHibernate.Mapping.Table.SqlAlterStrings(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.Data.DataTable)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <param name="p"></param>
            <param name="tableInfo"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String)">
            <summary>
            Generates the SQL string to create this Table in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create this Table, Primary Key Constraints
            , and Unique Key Constraints.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to drop this Table in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Table and to cascade the drop to 
            the constraints if the database supports it.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetIndex(System.String)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.Index"/> identified by the name.
            </summary>
            <param name="name">The name of the <see cref="T:NHibernate.Mapping.Index"/> to get.</param>
            <returns>
            The <see cref="T:NHibernate.Mapping.Index"/> identified by the name.  If the <see cref="T:NHibernate.Mapping.Index"/>
            identified by the name does not exist then it is created.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetUniqueKey(System.String)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.UniqueKey"/> identified by the name.
            </summary>
            <param name="name">The name of the <see cref="T:NHibernate.Mapping.UniqueKey"/> to get.</param>
            <returns>
            The <see cref="T:NHibernate.Mapping.UniqueKey"/> identified by the name.  If the <see cref="T:NHibernate.Mapping.UniqueKey"/>
            identified by the name does not exist then it is created.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.CreateForeignKey(System.String,System.Collections.IList,System.Type)">
            <summary>
            Create a <see cref="T:NHibernate.Mapping.ForeignKey"/> for the columns in the Table.
            </summary>
            <param name="keyName"></param>
            <param name="columns">An <see cref="T:System.Collections.IList"/> of <see cref="T:NHibernate.Mapping.Column"/> objects.</param>
            <param name="referencedClass"></param>
            <returns>
            A <see cref="T:NHibernate.Mapping.ForeignKey"/> for the columns in the Table.  
            </returns>
            <remarks>
            This does not necessarily create a <see cref="T:NHibernate.Mapping.ForeignKey"/>, if
            one already exists for the columns then it will return an 
            existing <see cref="T:NHibernate.Mapping.ForeignKey"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Table.UniqueColumnString(System.Collections.ICollection)">
            <summary>
            Generates a unique string for an <see cref="T:System.Collections.ICollection"/> of 
            <see cref="T:NHibernate.Mapping.Column"/> objects.
            </summary>
            <param name="col">An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects.</param>
            <returns>
            An unique string for the <see cref="T:NHibernate.Mapping.Column"/> objects.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.SetIdentifierValue(NHibernate.Mapping.SimpleValue)">
            <summary>
            Sets the Identifier of the Table.
            </summary>
            <param name="idValue">The <see cref="T:NHibernate.Mapping.SimpleValue"/> that represents the Identifier.</param>
        </member>
        <member name="M:NHibernate.Mapping.Table.AddCheckConstraint(System.String)">
            <summary>
            
            </summary>
            <param name="constraint"></param>
        </member>
        <member name="P:NHibernate.Mapping.Table.Name">
            <summary>
            Gets or sets the name of the Table in the database.
            </summary>
            <value>
            The name of the Table in the database.  The get does 
            not return a Quoted Table name.
            </value>
            <remarks>
            <p>
            If a value is passed in that is wrapped by <c>`</c> then 
            NHibernate will Quote the Table whenever SQL is generated
            for it.  How the Table is quoted depends on the Dialect.
            </p>
            <p>
            The value returned by the getter is not Quoted.  To get the
            column name in quoted form use <see cref="M:NHibernate.Mapping.Table.GetQuotedName(NHibernate.Dialect.Dialect)"/>.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Table.ColumnSpan">
            <summary>
            Gets the number of columns that this Table contains.
            </summary>
            <value>
            The number of columns that this Table contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.IndexCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Index"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Index"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.ForeignKeyCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.ForeignKey"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.ForeignKey"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.UniqueKeyCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.UniqueKey"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.UniqueKey"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.PrimaryKey">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Table.PrimaryKey"/> of the Table.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.Table.PrimaryKey"/> of the Table.</value>
        </member>
        <member name="P:NHibernate.Mapping.Table.Schema">
            <summary>
            Gets or sets the schema the table is in.
            </summary>
            <value>
            The schema the table is in or <see langword="null" /> if no schema is specified.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.UniqueInteger">
            <summary>
            Gets the unique number of the Table.
            </summary>
            <value>The unique number of the Table.</value>
        </member>
        <member name="P:NHibernate.Mapping.Table.IsQuoted">
            <summary>
            Gets or sets if the column needs to be quoted in SQL statements.
            </summary>
            <value><see langword="true" /> if the column is quoted.</value>
        </member>
        <member name="T:NHibernate.Mapping.UniqueKey">
            <summary>
            An Unique Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlConstraintString(NHibernate.Dialect.Dialect)">
            <summary>
            Generates the SQL string to create the Unique Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <returns>
            A string that contains the SQL to create the Unique Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to create the Unique Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the Unique Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="T:NHibernate.Metadata.IClassMetadata">
            <summary>
            Exposes entity class metadata to the application
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.Instantiate(System.Object)">
            <summary>
            Create a class instance initialized with the given identifier
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyType(System.String)">
            <summary>
            Get the type of a particular (named) property
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValue(System.Object,System.String)">
            <summary>
            Get the value of a particular (named) property 
            </summary>
            <param name="obj"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Set the value of a particular (named) property 
            </summary>
            <param name="obj"></param>
            <param name="propertyName"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValues(System.Object)">
            <summary>
            Return the values of the mapped properties of the object
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Set the given values to the mapped properties of the given object
            </summary>
            <param name="entity"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetIdentifier(System.Object)">
            <summary>
            Get the identifier of an instance (throw an exception if no identifier property)
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetIdentifier(System.Object,System.Object)">
            <summary>
            Set the identifier of an instance (or do nothing if no identifier property)
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetVersion(System.Object)">
            <summary>
            Get the version number (or timestamp) from the object's version property 
            (or return null if not versioned)
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.MappedClass">
            <summary>
            The persistent class
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IdentifierPropertyName">
            <summary>
            The name of the identifier property (or return null)
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyNames">
            <summary>
            The names of the class' persistent properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IdentifierType">
            <summary>
            The identifier Hibernate type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyTypes">
            <summary>
            The Hibernate types of the classes properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.ImplementsLifecycle">
            <summary>
            Does the class implement the <c>ILifecycle</c> interface?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.ImplementsValidatable">
            <summary>
            Does the class implement the <c>IValidatable</c> inteface?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.HasProxy">
            <summary>
            Does the class support dynamic proxies?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IsMutable">
            <summary>
            Are instances of this class mutable?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IsVersioned">
            <summary>
            Are instances of this class versioned by a timestamp or version number column?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.VersionProperty">
            <summary>
            Gets the index of the version property
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyNullability">
            <summary>
            Get the nullability of the class' persistent properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.HasIdentifierProperty">
            <summary>
            Does the class have an identifier property?
            </summary>
        </member>
        <member name="T:NHibernate.Metadata.ICollectionMetadata">
            <summary>
            Exposes collection metadata to the application
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.KeyType">
            <summary>
            The collection key type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.ElementType">
            <summary>
            The collection element type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IndexType">
            <summary>
            The collection index type (or null if the collection has no index)
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.HasIndex">
            <summary>
            Is the collection indexed?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.Role">
            <summary>
            The name of this collection role
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsArray">
            <summary>
            Is the collection an array?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsPrimitiveArray">
            <summary>
            Is the collection a primitive array?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsLazy">
            <summary>
            Is the collection lazily initialized?
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.AbstractCollectionPersister">
            <summary>
            Summary description for AbstractCollectionPersister.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.IQueryableCollection">
            <summary>
            A collection role that may be queried or loaded by outer join.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IPropertyMapping">
            <summary>
            Abstraction of all mappings that define properties: entities, collection elements.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IPropertyMapping.ToType(System.String)">
            <summary>
            Given a component path expression, get the type of the property
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IPropertyMapping.ToColumns(System.String,System.String)">
            <summary>
            Given a query alias and a property path, return the qualified column name
            </summary>
            <param name="alias"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IPropertyMapping.Type">
            <summary>
            Get the type of the thing containing the properties
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IJoinable">
            <summary>
            Anything that can be loaded by outer join - namely persisters for classes or collections.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.SelectFragment(NHibernate.Persister.Entity.IJoinable,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            All columns to select, when loading.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.WhereJoinFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get the where clause part of any joins (optional operation)
            </summary>
            <param name="alias"></param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.FromJoinFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get the from clause part of any joins (optional operation)
            </summary>
            <param name="alias"></param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.FilterFragment(System.String,System.Collections.IDictionary)">
            <summary>
            Get the where clause filter, given a query alias and considering enabled session filters
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.ConsumesEntityAlias">
            <summary>
            Very, very, very ugly...
            </summary>
            <value>Does this persister "consume" entity column aliases in the result
            set?</value>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.ConsumesCollectionAlias">
            <summary>
            Very, very, very ugly...
            </summary>
            <value>Does this persister "consume" collection column aliases in the result
            set?</value>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.Name">
            <summary>
            An identifying name; a class name or collection role name.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.TableName">
            <summary>
            The table to join to.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.KeyColumnNames">
            <summary>
            The columns to join on.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.IsCollection">
            <summary>
            Is this instance actually a ICollectionPersister?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.IsManyToMany">
            <summary>
            Is this instance actually a many-to-many association?
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.ICollectionPersister">
            <summary>
            <p>A strategy for persisting a collection role. Defines a contract between
            the persistence strategy and the actual persistent collection framework
            and session. Does not define operations that are required for querying
            collections, or loading by outer join.</p>
            <p>
            Implements persistence of a collection instance while the instance is
            referenced in a particular role.</p>
            <p>
            This class is highly coupled to the <see cref="T:NHibernate.Collection.IPersistentCollection"/>
            hierarchy, since double dispatch is used to load and update collection 
            elements.</p>
            </summary>
            <remarks>
            May be considered an immutable view of the mapping object
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Initialize(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initialize the given collection with the given key
            </summary>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadKey(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the key from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadElement(System.Data.IDataReader,System.Object,System.String[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the element from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadIndex(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the index from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadIdentifier(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the identifier from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Remove(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Completely remove the persistent state of the collection
            </summary>
            <param name="id"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Recreate(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            (Re)create the collection's persistent state
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.DeleteRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Delete the persistent state of any elements that were removed from the collection
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.UpdateRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Update the persistent state of any elements that were modified
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.InsertRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Insert the persistent state of any new collection elements
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetKeyColumnAliases(System.String)">
            <summary>
            Generates the collection's key column aliases, based on the given
            suffix.
            </summary>
            <param name="suffix">The suffix to use in the key column alias generation.</param>
            <returns>The key column aliases.</returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetIndexColumnAliases(System.String)">
            <summary>
            Generates the collection's index column aliases, based on the given
            suffix.
            </summary>
            <param name="suffix">The suffix to use in the index column alias generation.</param>
            <returns>The index column aliases, or null if not indexed.</returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetElementColumnAliases(System.String)">
            <summary>
            Generates the collection's element column aliases, based on the given
            suffix.
            </summary>
            <param name="suffix">The suffix to use in the element column alias generation.</param>
            <returns>The element column aliases.</returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetIdentifierColumnAlias(System.String)">
            <summary>
            Generates the collection's identifier column aliases, based on the given
            suffix.
            </summary>
            <param name="suffix">The suffix to use in the identifier column alias generation.</param>
            <returns>The identifier column aliases.</returns>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.Cache">
            <summary>
            Get the cache
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasCache">
            <summary>
            Is this collection role cacheable
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CollectionType">
            <summary>
            Get the associated <c>IType</c>
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.KeyType">
            <summary>
            Get the "key" type (the type of the foreign key)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IndexType">
            <summary>
            Get the "index" type for a list or map (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.ElementType">
            <summary>
            Get the "element" type
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.ElementClass">
            <summary>
            Return the element class of an array, or null otherwise
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsPrimitiveArray">
            <summary>
            Is this an array or primitive values?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsArray">
            <summary>
            Is this an array?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsOneToMany">
            <summary>
            Is this a one-to-many association?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasIndex">
            <summary>
            Is this an "indexed" collection? (list or map)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsLazy">
            <summary>
            Is this collection lazyily initialized?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsInverse">
            <summary>
            Is this collection "inverse", so state changes are not propogated to the database.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.Role">
            <summary>
            Get the name of this collection role (the fully qualified class name, extended by a "property path")
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.OwnerClass">
            <summary>
            Get the entity class that "owns" this collection
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IdentifierGenerator">
            <summary>
            Get the surrogate key generation strategy (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IdentifierType">
            <summary>
            Get the type of the surrogate key
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasOrphanDelete">
            <summary>
            Does this collection implement "orphan delete"?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasOrdering">
            <summary>
            Is this an ordered collection? (An ordered collection is
            ordered by the initialization operation, not by sorting
            that happens in memory, as in the case of a sorted collection.)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CollectionSpace">
            <summary>
            Get the "space" that holds the persistent state
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.SelectFragment(System.String,System.String)">
            <summary>
            Generate a list of collection index and element columns
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetElementColumnNames(System.String)">
            <summary>
            Get the names of the collection element columns (or the primary
            key columns in the case of a one-to-many association),
            aliased by the given table alias
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetSQLWhereString(System.String)">
            <summary>
            Get the extra where clause filter SQL
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetSQLOrderByString(System.String)">
            <summary>
            Get the order by SQL
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetManyToManyOrderByString(System.String)">
            <summary>
            Get the order-by to be applied at the target table of a many to many
            </summary>
            <param name="alias">The alias for the many-to-many target table</param>
            <returns>Appropriate order-by fragment or empty string.</returns>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.IndexColumnNames">
            <summary>
            Get the names of the collection index columns if this is an indexed collection (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.ElementColumnNames">
            <summary>
            Get the names of the collection element columns (or the primary key columns in the case of a one-to-many association)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.HasWhere">
            <summary>
            Does this collection role have a where clause filter?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.ElementPersister">
            <summary>
            Get the persister of the element class, if this is a
            collection of entities (optional operation).  Note that
            for a one-to-many association, the returned persister
            must be <c>OuterJoinLoadable</c>.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.FetchMode">
            <summary>
            Should we load this collection role by outer joining?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.AbstractCollectionPersister.ReadElement(System.Data.IDataReader,System.Object,System.String[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Reads the Element from the IDataReader.  The IDataReader will probably only contain
            the id of the Element.
            </summary>
            <remarks>See ReadElementIdentifier for an explanation of why this method will be depreciated.</remarks>
        </member>
        <member name="M:NHibernate.Persister.Collection.AbstractCollectionPersister.ReadElementIdentifier(System.Data.IDataReader,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Gets just the Identifier of the Element for the Collection.
            </summary>
            <param name="rs"></param>
            <param name="owner"></param>
            <param name="session"></param>
            <returns></returns>
            <remarks>
            This was created in addition to ReadElement because ADO.NET does not allow
            for 2 IDataReaders to be open against a single IDbConnection at one time.  
            
            When a Collection is loaded it was recursively opening IDbDataReaders to resolve
            the Element for the Collection while the IDbDataReader was open that contained the
            record for the Collection.
            </remarks>		
        </member>
        <member name="P:NHibernate.Persister.Collection.AbstractCollectionPersister.ElementClass">
            <summary>
            Return the element class of an array, or null otherwise
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.AbstractCollectionPersister.Role">
            <summary>
            Get the name of this collection role (the fully qualified class name,
            extended by a "property path")
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.BasicCollectionPersister">
            <summary>
            Collection persister for collections of values and many-to-many associations.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateDeleteString">
            <summary>
            Generate the SQL DELETE that deletes all rows
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateInsertRowString">
            <summary>
            Generate the SQL INSERT that creates a new row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateUpdateRowString">
            <summary>
            Generate the SQL UPDATE that updates a row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateDeleteRowString">
            <summary>
            Generate the SQL DELETE that deletes a particular row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.CreateCollectionInitializer(System.Collections.IDictionary)">
            <summary>
            Create the <see cref="T:NHibernate.Loader.Collection.CollectionLoader"/>
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.CollectionPropertyMapping">
            <summary>
            Summary description for CollectionPropertyMapping.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.CollectionPropertyNames">
            <summary>
            The names of all the collection properties.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.CompositeElementPropertyMapping">
            <summary>
            Summary description for CompositeElementPropertyMapping.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.AbstractPropertyMapping">
            <summary>
            Base implementation of a PropertyMapping.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractPropertyMapping.ToType(System.String)">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractPropertyMapping.InitIdentifierPropertyPaths(System.String,NHibernate.Type.EntityType,System.String[],NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="etype"></param>
            <param name="columns"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractPropertyMapping.HandlePath(System.String,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="type"></param>
        </member>
        <member name="P:NHibernate.Persister.Collection.CompositeElementPropertyMapping.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.CompositeElementPropertyMapping.ClassName">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.ElementPropertyMapping">
            <summary>
            Summary description for ElementPropertyMapping.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ElementPropertyMapping.#ctor(System.String[],NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elementColumns"></param>
            <param name="type"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ElementPropertyMapping.ToType(System.String)">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.ElementPropertyMapping.ToColumns(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.Collection.ElementPropertyMapping.Type">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.OneToManyPersister">
            <summary>
            Summary description for OneToManyPersister.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateDeleteString">
            <summary>
            Generate the SQL UPDATE that updates all the foreign keys to null
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateInsertRowString">
            <summary>
            Generate the SQL UPDATE that updates a foreign key to a value
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateUpdateRowString">
            <summary>
            Not needed for one-to-many association
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateDeleteRowString">
            <summary>
            Generate the SQL UPDATE that updates a particular row's foreign
            key to null
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.CreateCollectionInitializer(System.Collections.IDictionary)">
            <summary>
            Create the <see cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.AbstractEntityPersister">
            <summary>
            Superclass for built-in mapping strategies. Implements functionalty common to both mapping
            strategies
            </summary>
            <remarks>
            May be considered an immutable view of the mapping object
            </remarks>
        </member>
        <member name="T:NHibernate.Persister.Entity.IOuterJoinLoadable">
            <summary>
            A <c>ClassPersister</c> that may be loaded by outer join using
            the <c>OuterJoinLoader</c> hierarchy and may be an element
            of a one-to-many association.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.ILoadable">
            <summary>
            Implemented by <c>ClassPersister</c> that uses <c>Loader</c>. There are several optional
            operations used only by loaders that inherit <c>OuterJoinLoader</c>
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IEntityPersister">
            <summary>
            Concrete <c>IEntityPersister</c>s implement mapping and persistence logic for a particular class.
            </summary>
            <remarks>
            Implementors must be threadsafe (preferrably immutable) and must provide a constructor of type
            (PersistentClass, SessionFactoryImplementor)
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.PostInstantiate">
            <summary>
            Finish the initialization of this object, once all <c>ClassPersisters</c> have been
            instantiated. Called only once, before any other method.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.CreateProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a new proxy instance
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsUnsaved(System.Object)">
            <summary>
            Is this a new transient instance?
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Set the given values to the mapped properties of the given object
            </summary>
            <param name="obj"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValues(System.Object)">
            <summary>
            Return the values of the mapped properties of the object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary>
            Set the value of a particular property
            </summary>
            <param name="obj"></param>
            <param name="i"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            Get the value of a particular property
            </summary>
            <param name="obj"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValue(System.Object,System.String)">
            <summary>
            Get the value of a particular property
            </summary>
            <param name="obj"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyType(System.String)">
            <summary>
            Get the type of a particular property
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.FindDirty(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Compare two snapshots of the state of an instance to determine if the persistent state
            was modified
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="owner"></param>
            <param name="session"></param>
            <returns><see langword="null" /> or the indices of the dirty properties</returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.FindModified(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Compare the state of an instance to the current database state
            </summary>
            <param name="old"></param>
            <param name="current"></param>
            <param name="owner"></param>
            <param name="session"></param>
            <returns>return <see langword="null" /> or the indicies of the modified properties</returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetIdentifier(System.Object)">
            <summary>
            Get the identifier of an instance ( throw an exception if no identifier property)
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetIdentifier(System.Object,System.Object)">
            <summary>
            Set the identifier of an instance (or do nothing if no identifier property)
            </summary>
            <param name="obj">The object to set the Id property on.</param>
            <param name="id">The value to set the Id property to.</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetVersion(System.Object)">
            <summary>
            Get the version number (or timestamp) from the object's version property (or return null if not versioned)
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Instantiate(System.Object)">
            <summary>
            Create a class instance initialized with the given identifier
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an insatance of the persistent class.
            </summary>
            <param name="id"></param>
            <param name="optionalObject"></param>
            <param name="lockMode"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Lock(System.Object,System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Do a version check (optional operation)
            </summary>
            <param name="id"></param>
            <param name="version"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Insert(System.Object,System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an instance
            </summary>
            <param name="id"></param>
            <param name="fields"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Insert(System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an instance, using a natively generated identifier (optional operation)
            </summary>
            <param name="fields"></param>
            <param name="obj"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Delete(System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Delete a persistent instance
            </summary>
            <param name="id"></param>
            <param name="version"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Update(System.Object,System.Object[],System.Int32[],System.Boolean,System.Object[],System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Update a persistent instance
            </summary>
            <param name="id">The id.</param>
            <param name="fields">The fields.</param>
            <param name="dirtyFields">The dirty fields.</param>
            <param name="hasDirtyCollection">if set to <see langword="true" /> [has dirty collection].</param>
            <param name="oldFields">The old fields.</param>
            <param name="oldVersion">The old version.</param>
            <param name="obj">The obj.</param>
            <param name="session">The session.</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetDatabaseSnapshot(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the current database state of the object, in a "hydrated" form, without resolving identifiers
            </summary>
            <param name="id"></param>
            <param name="version"></param>
            <param name="session"></param>
            <returns><see langword="null" /> if select-before-update is not enabled or not supported</returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetCurrentVersion(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the current version of the object, or return null if there is no row for
            the given identifier. In the case of unversioned data, return any object
            if the row exists.
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsUnsavedVersion(System.Object[])">
            <summary>
            </summary>
            <param name="values"></param>
            <returns></returns>
            <remarks>NHibernate-specific feature, not present in H2.1</remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsInstance(System.Object)">
            <summary>
            Determines whether the specified entity is an instance of the class
            managed by this persister.
            </summary>
            <param name="entity">The entity.</param>
            <returns>
            	<see langword="true"/> if the specified entity is an instance; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.ProcessInsertGeneratedProperties(System.Object,System.Object,System.Object[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform a select to retrieve the values of any generated properties
            back from the database, injecting these generated values into the
            given entity as well as writing this state to the persistence context.
            </summary>
            <remarks>
            Note, that because we update the persistence context here, callers
            need to take care that they have already written the initial snapshot
            to the persistence context before calling this method. 
            </remarks>
            <param name="id">The entity's id value.</param>
            <param name="entity">The entity for which to get the state.</param>
            <param name="state">The entity state (at the time of Save).</param>
            <param name="session">The session.</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.ProcessUpdateGeneratedProperties(System.Object,System.Object,System.Object[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform a select to retrieve the values of any generated properties
            back from the database, injecting these generated values into the
            given entity as well as writing this state to the persistence context.
            </summary>
            <remarks>
            Note, that because we update the persistence context here, callers
            need to take care that they have already written the initial snapshot
            to the persistence context before calling this method. 
            </remarks>
            <param name="id">The entity's id value.</param>
            <param name="entity">The entity for which to get the state.</param>
            <param name="state">The entity state (at the time of Save).</param>
            <param name="session">The session.</param>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierSpace">
            <summary>
            Returns an object that identifies the space in which identifiers of this class hierarchy
            are unique. eg. a table name, etc.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertySpaces">
            <summary>
            Returns an array of objects that identifies spaces in which properties of this class
            instance are persisted. eg. table names.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.MappedClass">
            <summary>
            The persistent class
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.ClassName">
            <summary>
            The classname of the persistent class (used only for messages)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.ImplementsLifecycle">
            <summary>
            Does the class implement the <c>ILifecycle</c> inteface?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.ImplementsValidatable">
            <summary>
            Does the class implement the <c>IValidatable</c> interface?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasProxy">
            <summary>
            Does this class support dynamic proxies?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.ConcreteProxyClass">
            <summary>
            Get the proxy interface that instances of <c>this</c> concrete class will be cast to
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCollections">
            <summary>
            Do instances of this class contain collections?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCascades">
            <summary>
            Does this class declare any cascading save/update/deletes?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsMutable">
            <summary>
            Are instances of this class mutable?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsIdentifierAssignedByInsert">
            <summary>
            Is the identifier assigned before the insert by an <c>IDGenerator</c> or is it returned
            by the <c>Insert()</c> method?
            </summary>
            <remarks>
            This determines which form of <c>Insert()</c> will be called.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasIdentifierProperty">
            <summary>
            Does the class have a property holding the identifier value?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasIdentifierPropertyOrEmbeddedCompositeIdentifier">
            <summary>
            Gets if the Type has a Property for the &lt;id&gt; or uses a &lt;composite-id&gt;
            to store the id.
            </summary>
            <returns><c>true if there is a Identifier Property or Composite Identifier.</c></returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsVersioned">
            <summary>
            Are instances of this class versioned by a timestamp or version number column?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.VersionType">
            <summary>
            Get the type of versioning (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.VersionProperty">
            <summary>
            Which property holds the version number? (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierGenerator">
            <summary>
            Return the <c>IIdentifierGenerator</c> for the class
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyTypes">
            <summary>
            Get the Hibernate types of the class properties
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyNames">
            <summary>
            Get the names of the class properties - doesn't have to be the names of the actual
            .NET properties (used for XML generation only)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyUpdateability">
            <summary>
            Gets if the Property is updatable
            </summary>
            <value><see langword="true" /> if the Property's value can be updated.</value>
            <remarks>
            This is for formula columns and if the user sets the update attribute on the &lt;property&gt; element.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyCheckability">
            <summary>
            Properties that may be dirty (and thus should be dirty-checked). These
            include all updatable properties and some associations.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyNullability">
            <summary>
            Get the nullability of the properties of this class
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyInsertability">
            <summary>
            Gets if the Property is insertable.
            </summary>
            <value><see langword="true" /> if the Property's value can be inserted.</value>
            <remarks>
            This is for formula columns and if the user sets the insert attribute on the &lt;property&gt; element.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyVersionability">
            <summary>
            Get the "versionability" of the properties of this class (is the property optimistic-locked)
            </summary>
            <value><see langword="true" /> if the property is optimistic-locked; otherwise, <see langword="false" />.</value>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyCascadeStyles">
            <summary>
            Get the cascade styles of the properties (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierType">
            <summary>
            Get the identifier type
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierPropertyName">
            <summary>
            Get the name of the indentifier property (or return null) - need not return the
            name of an actual .NET property
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsCacheInvalidationRequired">
            <summary>
            Should we always invalidate the cache instead of recaching updated state
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCache">
            <summary>
            Does this class have a cache?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.Cache">
            <summary>
            Get the cache (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.ClassMetadata">
            <summary>
            Get the user-visible metadata for the class (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsBatchLoadable">
            <summary>
            Is batch loading enabled?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.QuerySpaces">
            <summary>
            Returns an array of objects that identify spaces in which properties of this class are persisted,
            for instances of this class and its subclasses.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.Factory">
            <summary>
            The session factory this instance is associated with.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsVersionPropertyGenerated">
            <summary>
            Does this entity contain a version property that is defined
            to be database generated?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasInsertGeneratedProperties">
            <summary>
            Does this entity define any properties as being database-generated on insert?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasUpdateGeneratedProperties">
            <summary>
            Does this entity define any properties as being database-generated on update?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetSubclassForDiscriminatorValue(System.Object)">
            <summary>
            Get the concrete subclass corresponding to the given discriminator value
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetIdentifierAliases(System.String)">
            <summary>
            Get the result set aliases used for the identifier columns, given a suffix
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetPropertyAliases(System.String,System.Int32)">
            <summary>
            Get the result set aliases used for the property columns, given a suffix (properties of this class, only).
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetPropertyColumnNames(System.Int32)">
            <summary>
            Get the result set column names mapped for this property (properties of this class, only).
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetDiscriminatorAlias(System.String)">
            <summary>
            Get the alias used for the discriminator column, given a suffix
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.HasSubclasses">
            <summary>
            Does the persistent class have subclasses?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.DiscriminatorType">
            <summary>
            The discriminator type
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.IdentifierColumnNames">
            <summary>
            Get the names of columns used to persist the identifier
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.DiscriminatorColumnName">
            <summary>
            Get the name of the column used as a discriminator
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.HasSubselectLoadableCollections">
            <summary>
            Does this entity own any collections which are fetchable by subselect?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.CountSubclassProperties">
            <summary>
            How many properties are there, for this class and all subclasses? (optional operation)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetFetchMode(System.Int32)">
            <summary>
            May this property be fetched using an SQL outerjoin?
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetCascadeStyle(System.Int32)">
            <summary>
            Get the cascade style of this (subclass closure) property
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.IsDefinedOnSubclass(System.Int32)">
            <summary>
            Is this property defined on a subclass of the mapped class?
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyType(System.Int32)">
            <summary>
            Get an array of the types of all properties of all subclasses (optional operation)
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyName(System.Int32)">
            <summary>
            Get the name of the numbered property of the class or a subclass
            (optional operation)
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.IsSubclassPropertyNullable(System.Int32)">
            <summary>
            Is the numbered property of the class of subclass nullable?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyColumnNames(System.Int32)">
            <summary>
            Return the column names used to persist all properties of all sublasses of the persistent class
            (optional operation)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyTableName(System.Int32)">
            <summary>
            Return the table name used to persist the numbered property of 
            the class or a subclass
            (optional operation)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.ToColumns(System.String,System.Int32)">
            <summary>
            Given the number of a property of a subclass, and a table alias, return the aliased column names
            (optional operation)
            </summary>
            <param name="name"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.FromTableFragment(System.String)">
            <summary>
            Get the main from table fragment, given a query alias (optional operation)
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.SelectFragment(System.String,System.String)">
            <summary>
            Generate a list of collection index and element columns
            </summary>
            <param name="alias"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetPropertyColumnNames(System.String)">
            <summary>
            Get the column names for the given property path
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetPropertyTableName(System.String)">
            <summary>
            Get the table name for the given property path
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IQueryable">
            <summary>
            Extends the generic <c>ILoadable</c> contract to add operations required by HQL
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.QueryWhereFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get the where clause fragment, give a query alias
            </summary>
            <param name="alias">SQL alias to use for column names in the returned query</param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.IdentifierSelectFragment(System.String,System.String)">
            <summary>
            Given a query alias and an identifying suffix, render the intentifier select fragment.
            </summary>
            <param name="name"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.PropertySelectFragment(System.String,System.String)">
            <summary>
            Given a query alias and an identifying suffix, render the property select fragment.
            </summary>
            <param name="alias"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.IsInherited">
            <summary>
            Is this class mapped as a subclass of another class?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.IsExplicitPolymorphism">
            <summary>
            Is this class explicit polymorphism only?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.MappedSuperclass">
            <summary>
            The class that this class is mapped as a subclass of - not necessarily the direct superclass
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.DiscriminatorSQLValue">
            <summary>
            The discriminator value for this particular concrete subclass, as a string that may be
            embedded in a select statement
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.DiscriminatorValue">
            <summary>
            The discriminator value for this particular concrete subclass (the value in the hbm)
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IUniqueKeyLoadable">
            <summary>
            Describes a class that may be loaded via a unique key.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IUniqueKeyLoadable.LoadByUniqueKey(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an instance of the persistent class, by a unique key other than the primary key.
            </summary>
            <param name="propertyName"></param>
            <param name="uniqueKey"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IUniqueKeyLoadable.GetPropertyIndex(System.String)">
            <summary>
            Get the property number of the unique key property
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.ISqlLoadable">
            <summary>
            A class persister that supports queries expressed in the platform native SQL dialect.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ISqlLoadable.GetSubclassPropertyColumnAliases(System.String,System.String)">
            <summary>
            Returns the column alias names used to persist/query the numbered property of the class or a subclass (optional operation).
            </summary>
            <param name="propertyName"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.ISqlLoadable.SelectFragment(System.String,System.String)">
            <summary>
            All columns to select, when loading.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ISqlLoadable.Type">
            <summary>
            Get the type
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Set the given values to the mapped properties of the given object
            </summary>
            <remarks>
            Use the access optimizer if available
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertyValues(System.Object)">
            <summary>
            Return the values of the mapped properties of the object
            </summary>
            <remarks>
            Uses the access optimizer, if available.
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            Get the value of the numbered property
            </summary>
            <param name="obj"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary>
            Set the value of the numbered property
            </summary>
            <param name="obj"></param>
            <param name="i"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.FindDirty(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine if the given field values are dirty.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="obj"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.FindModified(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine if the given field values are dirty.
            </summary>
            <param name="old"></param>
            <param name="current"></param>
            <param name="obj"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Instantiate(System.Object)">
            <summary>
            Return a new instance initialized with the given identifier.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.SqlIdentitySelect(System.String,System.String)">
            <summary>
            Returns the SQL used to get the Identity value from the last insert.
            </summary>
            <remarks>This is not a NHibernate Command because the SQL contains no parameters.</remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.InitSubclassPropertyAliasesMap(NHibernate.Mapping.PersistentClass)">
            <summary>
            Must be called by subclasses, at the end of their constructors
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetCurrentVersion(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Retrieve the version number
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Lock(System.Object,System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Do a version check
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GenerateSelectVersionString">
            <summary>
            Generate the SQL that selects the version number by id
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertiesToUpdate(System.Int32[],System.Boolean)">
            <summary>
            Transform the array of property indexes to an array of booleans
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertyColumnNames(System.Int32)">
            <summary>
            Get the column names for the numbered property of <em>this</em> class
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetTableUpdateNeeded(System.Int32[],System.Boolean)">
            <summary>
            Decide which tables need to be updated
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Insert(System.Object[],System.Boolean[],NHibernate.SqlCommand.SqlCommandInfo,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an object, using a natively generated identifier
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetSubclassPropertyTableNumber(System.String)">
            <remarks>
            Warning:
            When there are duplicated property names in the subclasses
            of the class, this method may return the wrong table
            number for the duplicated subclass property (note that
            SingleTableEntityPersister defines an overloaded form
            which takes the entity name.
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an instance using the appropriate loader (as determined by <see cref="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetAppropriateLoader(NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Delete(System.Object,System.Object,System.Int32,System.Object,NHibernate.SqlCommand.SqlCommandInfo,NHibernate.Engine.ISessionImplementor,System.Object[])">
            <summary>
            Delete an object.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Insert(System.Object,System.Object[],System.Boolean[],System.Int32,NHibernate.SqlCommand.SqlCommandInfo,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an object
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.IsInstance(System.Object)">
            <summary>
            Determines whether the specified entity is an instance of the class
            managed by this persister.
            </summary>
            <param name="entity">The entity.</param>
            <returns>
            	<see langword="true"/> if the specified entity is an instance; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.PropertyNames">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.IdentifierPropertyName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.VersionColumnName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.ImplementsLifecycle">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.ImplementsValidatable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.HasCollections">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.IsMutable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.HasCache">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlDeleteStrings">
            <summary>
            The queries that delete rows by id (and version)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlInsertStrings">
            <summary>
            The queries that insert rows with a given id
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlIdentityInsertString">
            <summary>
            The query that insert a row into the root table, letting the database generate an id
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlUpdateStrings">
            <summary>
            The queries that update rows by id (and version)
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.JoinedSubclassEntityPersister">
            <summary>
            A <c>IEntityPersister</c> implementing the normalized "table-per-subclass" mapping strategy
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.GenerateLockString(NHibernate.SqlCommand.SqlString,System.String)">
            <summary>
            Generate the SQL that pessimistic locks a row by id (and version)
            </summary>
            <param name="sqlString">An existing SqlString to copy for then new SqlString.</param>
            <param name="forUpdateFragment"></param>
            <returns>A new SqlString</returns>
            <remarks>
            The parameter <c>sqlString</c> does not get modified.  It is Cloned to make a new SqlString.
            If the parameter<c>sqlString</c> is null a new one will be created.
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.#ctor(NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
            <summary>
            Constructs the NormalizedEntityPerister for the PersistentClass.
            </summary>
            <param name="model">The PeristentClass to create the EntityPersister for.</param>
            <param name="cache">The configured <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/>.</param>
            <param name="factory">The SessionFactory that this EntityPersister will be stored in.</param>
            <param name="mapping">The mapping used to retrieve type information.</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.Reverse(System.String[])">
            <summary>
            Create a new one dimensional array sorted in the Reverse order of the original array.
            </summary>
            <param name="objects">The original array.</param>
            <returns>A new array in the reverse order of the original array.</returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.Reverse(System.String[][])">
            <summary>
            Create a new two dimensional array sorted in the Reverse order of the original array. The 
            second dimension is not reversed.
            </summary>
            <param name="objects">The original array.</param>
            <returns>A new array in the reverse order of the original array.</returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.GetTableId(System.String,System.String[])">
            <summary>
            Find the Index of the table name from a list of table names.
            </summary>
            <param name="tableName">The name of the table to find.</param>
            <param name="tables">The array of table names</param>
            <returns>The Index of the table in the array.</returns>
            <exception cref="T:NHibernate.AssertionFailure">Thrown when the tableName specified can't be found</exception>
        </member>
        <member name="T:NHibernate.Persister.Entity.LoadableConstants">
            <summary>
            Constants from <see cref="T:NHibernate.Persister.Entity.ILoadable"/> interface.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.SingleTableEntityPersister">
            <summary>
            Default implementation of the <c>ClassPersister</c> interface. Implements the
            "table-per-class hierarchy" mapping strategy for an entity class.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.SingleTableEntityPersister.GenerateSelectForUpdateString">
            <summary>
            Generate the SQL that selects a row by id using <c>FOR UPDATE</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.SingleTableEntityPersister.GenerateSelectForUpdateNoWaitString">
            <summary>
            Generate the SQL that selects a row by id using <c>FOR UPDATE NOWAIT</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.SingleTableEntityPersister.GenerateSelectString(System.String)">
            <summary>
            Generates an SqlString that selects a row by id
            </summary>
            <param name="forUpdateFragment">SQL containing <c>FOR UPDATE</c> clauses
            to append at the end of the query (optional)</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.SingleTableEntityPersister.GenerateUpdateString(System.Boolean[])">
            <summary>
            Generate the SQL that updates a row by id, excluding subclasses
            </summary>
            <param name="includeProperty"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.SingleTableEntityPersister.GenerateLockString(NHibernate.SqlCommand.SqlString,System.String)">
            <summary>
            Generates the SQL that pessimistically locks a row by id (and version)
            </summary>
            <param name="sqlString">An existing SqlString to copy for then new SqlString.</param>
            <param name="forUpdateFragment"></param>
            <returns>A new SqlString</returns>
            <remarks>
            The parameter <c>sqlString</c> does not get modified.  It is Cloned to make a new SqlString.
            If the parameter<c>sqlString</c> is null a new one will be created.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.SingleTableEntityPersister.IsCacheInvalidationRequired">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.SingleTableEntityPersister.VersionedTableName">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Persister.PersisterFactory">
            <summary>
            Factory for <c>IEntityPersister</c> and <c>ICollectionPersister</c> instances.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.PersisterFactory.CreateClassPersister(NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
            <summary>
            Creates a built in Entity Persister or a custom Persister.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.PersisterFactory.Create(System.Type,NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
            <summary>
            Creates a specific Persister - could be a built in or custom persister.
            </summary>
        </member>
        <member name="T:NHibernate.Property.BasicGetter">
            <summary>
            An <see cref="T:NHibernate.Property.IGetter"/> for a Property <c>get</c>.
            </summary>
        </member>
        <member name="T:NHibernate.Property.IGetter">
            <summary>
            Gets values of a particular mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Property.IGetter.Get(System.Object)">
            <summary>
            When implemented by a class, gets the value of the Property/Field from the object.
            </summary>
            <param name="target">The object to get the Property/Field value from.</param>
            <returns>
            The value of the Property for the target.
            </returns>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem getting the value from the target.
            </exception>
        </member>
        <member name="P:NHibernate.Property.IGetter.ReturnType">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Type"/> that the Property/Field returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Property returns.</value>
        </member>
        <member name="P:NHibernate.Property.IGetter.PropertyName">
            <summary>
            When implemented by a class, gets the name of the Property.
            </summary>
            <value>The name of the Property or <see langword="null"/>.</value>
            <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Property.IGetter"/> is not 
            for a Property <c>get</c> then <see langword="null"/> is an acceptable value to return.
            </remarks>
        </member>
        <member name="P:NHibernate.Property.IGetter.Method">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Reflection.MethodInfo"/> for the <c>get</c>
            accessor of the property.
            </summary>
            <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Property.IGetter"/> is not 
            for a property <c>get</c> then <see langword="null"/> is an acceptable value to return.
            It is used by the proxies to determine which getter to intercept for the
            identifier property.
            </remarks>
        </member>
        <member name="T:NHibernate.Property.IOptimizableGetter">
            <summary>
            An <see cref="T:NHibernate.Property.IGetter"/> that can emit IL to get the property value.
            </summary>
        </member>
        <member name="M:NHibernate.Property.IOptimizableGetter.Emit(System.Reflection.Emit.ILGenerator)">
            <summary>
            Emit IL to get the property value from the object on top of the stack.
            </summary>
        </member>
        <member name="M:NHibernate.Property.BasicGetter.#ctor(System.Type,System.Reflection.PropertyInfo,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.BasicGetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Property <c>get</c>.</param>
            <param name="property">The <see cref="T:System.Reflection.PropertyInfo"/> for reflection.</param>
            <param name="propertyName">The name of the Property.</param>
        </member>
        <member name="M:NHibernate.Property.BasicGetter.Get(System.Object)">
            <summary>
            Gets the value of the Property from the object.
            </summary>
            <param name="target">The object to get the Property value from.</param>
            <returns>
            The value of the Property for the target.
            </returns>
        </member>
        <member name="P:NHibernate.Property.BasicGetter.ReturnType">
            <summary>
            Gets the <see cref="T:System.Type"/> that the Property returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Property returns.</value>
        </member>
        <member name="P:NHibernate.Property.BasicGetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value>The name of the Property.</value>
        </member>
        <member name="P:NHibernate.Property.BasicGetter.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value>
            The <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </value>
        </member>
        <member name="T:NHibernate.Property.BasicPropertyAccessor">
            <summary>
            Accesses mapped property values via a get/set pair, which may be nonpublic.
            The default (and recommended strategy).
            </summary>
        </member>
        <member name="T:NHibernate.Property.IPropertyAccessor">
            <summary>
            Abstracts the notion of a "property". Defines a strategy for accessing the
            value of a mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Property.IPropertyAccessor.GetGetter(System.Type,System.String)">
            <summary>
            When implemented by a class, create a "getter" for the mapped property.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.IGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.IPropertyAccessor.GetSetter(System.Type,System.String)">
            <summary>
            When implemented by a class, create a "setter" for the mapped property.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Property.ISetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.BasicPropertyAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.BasicGetter"/> for the mapped property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.BasicPropertyAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.BasicSetter"/> for the mapped property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.BasicPropertyAccessor.GetGetterOrNull(System.Type,System.String)">
            <summary>
            Helper method to find the Property <c>get</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicGetter"/> for the Property <c>get</c> or <see langword="null"/>
            if the Property could not be found.
            </returns>
        </member>
        <member name="M:NHibernate.Property.BasicPropertyAccessor.GetSetterOrNull(System.Type,System.String)">
            <summary>
            Helper method to find the Property <c>set</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicSetter"/> for the Property <c>set</c> or <see langword="null"/>
            if the Property could not be found.
            </returns>
        </member>
        <member name="T:NHibernate.Property.BasicSetter">
            <summary>
            An <see cref="T:NHibernate.Property.ISetter"/> for a Property <c>set</c>.
            </summary>
        </member>
        <member name="T:NHibernate.Property.ISetter">
            <summary>
            Sets values of a particular mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Property.ISetter.Set(System.Object,System.Object)">
            <summary>
            When implemented by a class, sets the value of the Property/Field on the object.
            </summary>
            <param name="target">The object to set the Property value in.</param>
            <param name="value">The value to set the Property to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Property.ISetter.PropertyName">
            <summary>
            When implemented by a class, gets the name of the Property.
            </summary>
            <value>The name of the Property or <see langword="null" />.</value>
            <remarks>
            This is an optional operation - if it is not implemented then 
            <see langword="null" /> is an acceptable value to return.
            </remarks>
        </member>
        <member name="P:NHibernate.Property.ISetter.Method">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Reflection.MethodInfo"/> for the <c>set</c>
            accessor of the property.
            </summary>
            <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Property.ISetter"/> is not 
            for a property <c>set</c> then <see langword="null"/> is an acceptable value to return.
            It is used by the proxies to determine which setter to intercept for the
            identifier property.
            </remarks>
        </member>
        <member name="T:NHibernate.Property.IOptimizableSetter">
            <summary>
            An <see cref="T:NHibernate.Property.ISetter"/> that can emit IL to set the property value.
            </summary>
        </member>
        <member name="M:NHibernate.Property.IOptimizableSetter.Emit(System.Reflection.Emit.ILGenerator)">
            <summary>
            Emit IL to set the property of an object to the value. The object
            is loaded onto the stack first, then the value, then this method
            is called.
            </summary>
        </member>
        <member name="M:NHibernate.Property.BasicSetter.#ctor(System.Type,System.Reflection.PropertyInfo,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.BasicSetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Property <c>set</c>.</param>
            <param name="property">The <see cref="T:System.Reflection.PropertyInfo"/> for reflection.</param>
            <param name="propertyName">The name of the mapped Property.</param>
        </member>
        <member name="M:NHibernate.Property.BasicSetter.Set(System.Object,System.Object)">
            <summary>
            Sets the value of the Property on the object.
            </summary>
            <param name="target">The object to set the Property value in.</param>
            <param name="value">The value to set the Property to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Property.BasicSetter.PropertyName">
            <summary>
            Gets the name of the mapped Property.
            </summary>
            <value>The name of the mapped Property or <see langword="null" />.</value>
        </member>
        <member name="P:NHibernate.Property.BasicSetter.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the mapped Property.
            </summary>
            <value>The <see cref="T:System.Reflection.PropertyInfo"/> for the mapped Property.</value>
        </member>
        <member name="T:NHibernate.Property.CamelCaseStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are the 
            camelCase version of the PropertyName
            </summary>
        </member>
        <member name="T:NHibernate.Property.IFieldNamingStrategy">
            <summary>
            A Strategy for converting a mapped property name to a Field name.
            </summary>
        </member>
        <member name="M:NHibernate.Property.IFieldNamingStrategy.GetFieldName(System.String)">
            <summary>
            When implemented by a class, converts the Property's name into a Field name
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field.</returns>
        </member>
        <member name="M:NHibernate.Property.CamelCaseStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character
            lower case.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in CamelCase format.</returns>
        </member>
        <member name="T:NHibernate.Property.CamelCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are prefixed with
            an underscore and the PropertyName is changed to camelCase.
            </summary>
        </member>
        <member name="M:NHibernate.Property.CamelCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> lowercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in CamelCase format prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Property.FieldAccessor">
            <summary>
            Access the mapped property by using a Field to <c>get</c> and <c>set</c> the value.
            </summary>
            <remarks>
            The <see cref="T:NHibernate.Property.FieldAccessor"/> is useful when you expose <c>getter</c> and <c>setters</c>
            for a Property, but they have extra code in them that shouldn't be executed when NHibernate
            is setting or getting the values for loads or saves.
            </remarks>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.FieldAccessor"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.#ctor(NHibernate.Property.IFieldNamingStrategy)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.FieldAccessor"/>.
            </summary>
            <param name="namingStrategy">The <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> to use.</param>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.FieldGetter"/> to <c>get</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.FieldGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.FieldSetter"/> to <c>set</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the mapped Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Property.FieldSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field for the Property specified by the <c>propertyName</c> using the
            <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> could not be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.GetField(System.Type,System.String)">
            <summary>
            Helper method to find the Field.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Field in.</param>
            <param name="fieldName">The name of the Field to find.</param>
            <returns>
            The <see cref="T:System.Reflection.FieldInfo"/> for the field.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a field could not be found.
            </exception>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.GetFieldName(System.String)">
            <summary>
            Converts the mapped property's name into a Field using 
            the <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> if one exists.
            </summary>
            <param name="propertyName">The name of the Property.</param>
            <returns>The name of the Field.</returns>
        </member>
        <member name="P:NHibernate.Property.FieldAccessor.NamingStrategy">
            <summary>
            Gets the <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> used to convert the name of the
            mapped Property in the hbm.xml file to the name of the field in the class.
            </summary>
            <value>The <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> or <see langword="null"/>.</value>
        </member>
        <member name="T:NHibernate.Property.FieldGetter">
            <summary>
            An <see cref="T:NHibernate.Property.IGetter"/> that uses a Field instead of the Property <c>get</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Property.FieldGetter.#ctor(System.Reflection.FieldInfo,System.Type,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.FieldGetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the field to use for the Property <c>get</c>.</param>
            <param name="field">The <see cref="T:System.Reflection.FieldInfo"/> for reflection.</param>
            <param name="name">The name of the Field.</param>
        </member>
        <member name="M:NHibernate.Property.FieldGetter.Get(System.Object)">
            <summary>
            Gets the value of the Field from the object.
            </summary>
            <param name="target">The object to get the Field value from.</param>
            <returns>
            The value of the Field for the target.
            </returns>
        </member>
        <member name="P:NHibernate.Property.FieldGetter.ReturnType">
            <summary>
            Gets the <see cref="T:System.Type"/> that the Field returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Field returns.</value>
        </member>
        <member name="P:NHibernate.Property.FieldGetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value><see langword="null" /> since this is a Field - not a Property.</value>
        </member>
        <member name="P:NHibernate.Property.FieldGetter.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value><see langword="null"/> since this is a Field - not a Property.</value>
        </member>
        <member name="T:NHibernate.Property.FieldSetter">
            <summary>
            An <see cref="T:NHibernate.Property.IGetter"/> that uses a Field instead of the Property <c>set</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Property.FieldSetter.#ctor(System.Reflection.FieldInfo,System.Type,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.FieldSetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Field to use for the Property <c>set</c>.</param>
            <param name="field">The <see cref="T:System.Reflection.FieldInfo"/> for reflection.</param>
            <param name="name">The name of the Field.</param>
        </member>
        <member name="M:NHibernate.Property.FieldSetter.Set(System.Object,System.Object)">
            <summary>
            Sets the value of the Field on the object.
            </summary>
            <param name="target">The object to set the Field value in.</param>
            <param name="value">The value to set the Field to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Property.FieldSetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value><see langword="null" /> since this is a Field - not a Property.</value>
        </member>
        <member name="P:NHibernate.Property.FieldSetter.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value><see langword="null"/> since this is a Field - not a Property.</value>
        </member>
        <member name="T:NHibernate.Property.LowerCaseStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are  
            the PropertyName in all LowerCase characters.
            </summary>
        </member>
        <member name="M:NHibernate.Property.LowerCaseStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the all characters 
            of the <c>propertyName</c> lowercase.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in lowercase.</returns>
        </member>
        <member name="T:NHibernate.Property.LowerCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are prefixed with
            an underscore and the PropertyName is changed to lower case.
            </summary>
        </member>
        <member name="M:NHibernate.Property.LowerCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the all characters 
            of the <c>propertyName</c> lowercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in lowercase prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Property.NoSetterAccessor">
            <summary>
            Access the mapped property through a Property <c>get</c> to get the value 
            and go directly to the Field to set the value.
            </summary>
            <remarks>
            This is most useful because Classes can provider a get for the Property
            that is the <c>&lt;id&gt;</c> but tell NHibernate there is no setter for the Property
            so the value should be written directly to the field.
            </remarks>
        </member>
        <member name="M:NHibernate.Property.NoSetterAccessor.#ctor(NHibernate.Property.IFieldNamingStrategy)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.NoSetterAccessor"/>.
            </summary>
            <param name="namingStrategy">The <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> to use.</param>
        </member>
        <member name="M:NHibernate.Property.NoSetterAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Creates an <see cref="T:NHibernate.Property.BasicGetter"/> to <c>get</c> the value from the Property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.NoSetterAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.FieldSetter"/> to <c>set</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the mapped Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Property.FieldSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field for the Property specified by the <c>propertyName</c> using the
            <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> could not be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.PascalCaseMStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with the letter 'm'.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in PascalCase format prefixed with an 'm'.</returns>
        </member>
        <member name="T:NHibernate.Property.PascalCaseMUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are prefixed with
            an <c>m_</c> and the first character in PropertyName capitalized.
            </summary>
        </member>
        <member name="M:NHibernate.Property.PascalCaseMUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with the letter 'm' 
            and an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in PascalCase format prefixed with an 'm' and an underscore.</returns>
        </member>
        <member name="T:NHibernate.Property.PascalCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are prefixed with
            an <c>_</c> and the first character in PropertyName capitalized.
            </summary>
        </member>
        <member name="M:NHibernate.Property.PascalCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in PascalCase format prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Property.PropertyAccessorFactory">
            <summary>
            Factory for creating the various PropertyAccessor strategies.
            </summary>
        </member>
        <member name="M:NHibernate.Property.PropertyAccessorFactory.#cctor">
            <summary>
            Initializes the static members in <see cref="T:NHibernate.Property.PropertyAccessorFactory"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Property.PropertyAccessorFactory.GetPropertyAccessor(System.String)">
            <summary>
            Gets or creates the <see cref="T:NHibernate.Property.IPropertyAccessor"/> specified by the type.
            </summary>
            <param name="type"></param>
            <returns>The <see cref="T:NHibernate.Property.IPropertyAccessor"/> specified by the type.</returns>
            <remarks>
            <para>
            The built in ways of accessing the values of Properties in your domain class are:
            </para>
            <list type="table">
            	<listheader>
            		<term>Access Method</term>
            		<description>How NHibernate accesses the Mapped Class.</description>
            	</listheader>
            	<item>
            		<term>property</term>
            		<description>
            			The <c>name</c> attribute is the name of the Property.  This is the 
            			default implementation.
            		</description>
            	</item>
            	<item>
            		<term>field</term>
            		<description>
            			The <c>name</c> attribute is the name of the field.  If you have any Properties
            			in the Mapped Class those will be bypassed and NHibernate will go straight to the
            			field.  This is a good option if your setters have business rules attached to them
            			or if you don't want to expose a field through a Getter &amp; Setter.
            		</description>
            	</item>
            	<item>
            		<term>nosetter</term>
            		<description>
            			The <c>name</c> attribute is the name of the Property.  NHibernate will use the 
            			Property's get method to retreive the value and will use the field
            			to set the value.  This is a good option for &lt;id&gt; Properties because this access method 
            			allow's users of the Class to get the value of the Id but not set the value.
            		</description>
            	</item>
            	<item>
            		<term>Assembly Qualified Name</term>
            		<description>
            			If NHibernate's built in <see cref="T:NHibernate.Property.IPropertyAccessor"/>s are not what is needed for your 
            			situation then you are free to build your own.  Provide an Assembly Qualified Name so that 
            			NHibernate can call <c>Activator.CreateInstance(AssemblyQualifiedName)</c> to create it.  
            		</description>
            	</item>
            </list>
            <para>
            In order for the <c>nosetter</c> to know the name of the field to access NHibernate needs to know
            what the naming strategy is.  The following naming strategies are built into NHibernate:
            </para>
            <list type="table">
            	<listheader>
            		<term>Naming Strategy</term>
            		<description>How NHibernate converts the value of the <c>name</c> attribute to a field name.</description>
            	</listheader>
            	<item>
            		<term>camelcase</term>
            		<description>
            			The <c>name</c> attribute should be changed to CamelCase to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>foo</c>.
            		</description>
            	</item>
            	<item>
            		<term>camelcase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be changed to CamelCase and prefixed with
            			an underscore to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>_foo</c>.
            		</description>
            	</item>
            	<item>
            		<term>pascalcase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be prefixed with an underscore
            			to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>_Foo</c>.
            		</description>
            	</item>
            	<item>
            		<term>pascalcase-m-underscore</term>
            		<description>
            			The <c>name</c> attribute should be prefixed with an 'm' and underscore
            			to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>m_Foo</c>.
            		</description>
            	</item>
            	<item>
            		<term>pascalcase-m</term>
            		<description>
            			The <c>name</c> attribute should be prefixed with an 'm'.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>mFoo</c>.
            		</description>
            	</item>
            	<item>
            		<term>lowercase</term>
            		<description>
            			The <c>name</c> attribute should be changed to lowercase to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>foobar</c>.
            		</description>
            	</item>
            	<item>
            		<term>lowercase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be changed to lowercase and prefixed with
            			and underscore to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>_foobar</c>.
            		</description>
            	</item>
            </list>
            <para>
            The naming strategy can also be appended at the end of the <c>field</c> access method.  Where
            this could be useful is a scenario where you do expose a get and set method in the Domain Class 
            but NHibernate should only use the fields.  
            </para>
            <para>
            With a naming strategy and a get/set for the Property available the user of the Domain Class 
            could write an Hql statement <c>from Foo as foo where foo.SomeProperty = 'a'</c>.   If no naming 
            strategy was specified the Hql statement whould have to be <c>from Foo as foo where foo._someProperty</c>
             (assuming CamelCase with an underscore field naming strategy is used).  
            </para>
            </remarks>
        </member>
        <member name="T:NHibernate.Proxy.CastleLazyInitializer">
            <summary>
            A <see cref="T:NHibernate.Proxy.LazyInitializer"/> for use with the Castle Dynamic Class Generator.
            </summary>
        </member>
        <member name="T:NHibernate.Proxy.LazyInitializer">
            <summary>
            Provides the base functionallity to Handle Member calls into a dynamically
            generated NHibernate Proxy.
            </summary>
            <remarks>
            This could be an extension point later if the .net framework ever gets a Proxy
            class that is similar to the java.lang.reflect.Proxy or if a library similar
            to cglib was made in .net.
            </remarks>
        </member>
        <member name="F:NHibernate.Proxy.LazyInitializer.InvokeImplementation">
            <summary>
            If this is returned by Invoke then the subclass needs to Invoke the
            method call against the object that is being proxied.
            </summary>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.#ctor(System.Type,System.Object,System.Reflection.MethodInfo,System.Reflection.MethodInfo,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a LazyInitializer to handle all of the Methods/Properties that are called
            on the Proxy.
            </summary>
            <param name="persistentClass">The Class to Proxy.</param>
            <param name="id">The Id of the Object we are Proxying.</param>
            <param name="getIdentifierMethod"></param>
            <param name="setIdentifierMethod"></param>
            <param name="session">The ISession this Proxy is in.</param>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.Initialize">
            <summary>
            Perform an ImmediateLoad of the actual object for the Proxy.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the Proxy has no Session or the Session is closed or disconnected.
            </exception>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.AddSerializationInfo(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Adds all of the information into the SerializationInfo that is needed to
            reconstruct the proxy during deserialization or to replace the proxy
            with the instantiated target.
            </summary>
            <remarks>
            This will only be called if the Dynamic Proxy generator does not handle serialization
            itself or delegates calls to the method GetObjectData to the LazyInitializer.
            </remarks>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.Invoke(System.Reflection.MethodBase,System.Object[],System.Object)">
            <summary>
            Invokes the method if this is something that the LazyInitializer can handle
            without the underlying proxied object being instantiated.
            </summary>
            <param name="method">The name of the method/property to Invoke.</param>
            <param name="args">The arguments to pass the method/property.</param>
            <param name="proxy">The proxy object that the method is being invoked on.</param>
            <returns>
            The result of the Invoke if the underlying proxied object is not needed.  If the 
            underlying proxied object is needed then it returns the result <see cref="F:NHibernate.Proxy.LazyInitializer.InvokeImplementation"/>
            which indicates that the Proxy will need to forward to the real implementation.
            </returns>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.GetImplementation">
            <summary>
            Return the Underlying Persistent Object, initializing if necessary.
            </summary>
            <returns>The Persistent Object this proxy is Proxying.</returns>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.GetImplementation(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Return the Underlying Persistent Object in a given <see cref="T:NHibernate.ISession"/>, or null.
            </summary>
            <param name="s">The Session to get the object from.</param>
            <returns>The Persistent Object this proxy is Proxying, or <see langword="null"/>.</returns>
        </member>
        <member name="P:NHibernate.Proxy.LazyInitializer.Identifier">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Proxy.LazyInitializer.PersistentClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Proxy.LazyInitializer.IsUninitialized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Proxy.LazyInitializer.Session">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Proxy.CastleLazyInitializer.#ctor(System.Type,System.Object,System.Reflection.MethodInfo,System.Reflection.MethodInfo,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new <see cref="T:NHibernate.Proxy.CastleLazyInitializer"/> object.
            </summary>
            <param name="persistentClass">The Class to Proxy.</param>
            <param name="id">The Id of the Object we are Proxying.</param>
            <param name="getIdentifierMethod"></param>
            <param name="setIdentifierMethod"></param>
            <param name="session">The ISession this Proxy is in.</param>
        </member>
        <member name="M:NHibernate.Proxy.CastleLazyInitializer.Intercept(Castle.DynamicProxy.IInvocation,System.Object[])">
            <summary>
            Invoke the actual Property/Method using the Proxy or instantiate the actual
            object and use it when the Proxy can't handle the method. 
            </summary>
            <param name="invocation">The <see cref="T:Castle.DynamicProxy.IInvocation"/> from the generated Castle.DynamicProxy.</param>
            <param name="args">The parameters for the Method/Property</param>
            <returns>The result just like the actual object was called.</returns>
        </member>
        <member name="M:NHibernate.Proxy.IProxyFactory.PostInstantiate(System.Type,Iesi.Collections.ISet,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Called immediately after instantiation
            </summary>
            <param name="persistentClass"></param>
            <param name="interfaces"></param>
            <param name="getIdentifierMethod"></param>
            <param name="setIdentifierMethod"></param>
        </member>
        <member name="M:NHibernate.Proxy.IProxyFactory.GetProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a new proxy
            </summary>
            <param name="id">The id value for the proxy to be generated.</param>
            <param name="session">The session to which the generated proxy will be
            associated.</param>
            <returns>The generated proxy.</returns>
            <exception cref="T:NHibernate.HibernateException">Indicates problems generating
            requested proxy.</exception>
        </member>
        <member name="M:NHibernate.Proxy.CastleProxyFactory.GetProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Build a proxy using the Castle.DynamicProxy library.
            </summary>
            <param name="id">The value for the Id.</param>
            <param name="session">The Session the proxy is in.</param>
            <returns>A fully built <c>INHibernateProxy</c>.</returns>
        </member>
        <member name="T:NHibernate.Proxy.INHibernateProxy">
            <summary>
            A marker interface so NHibernate can know if it is dealing with
            an object that is a Proxy. 
            </summary>
            <remarks>
            <para>
            This interface should not be implemented by anything other than
            the Dynamically generated Proxy.  If it is implemented by a class then
            NHibernate will think that class is a Proxy and will not work.
            </para> 
            <para>
            It has to be public scope because
            the Proxies are created in a seperate DLL than NHibernate. 
            </para> 
            </remarks>
        </member>
        <member name="T:NHibernate.Proxy.NHibernateProxyHelper">
            <summary>
            NHibernateProxyHelper provides convenience methods for working with
            objects that might be instances of Classes or the Proxied version of 
            the Class.
            </summary>
        </member>
        <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GetLazyInitializer(NHibernate.Proxy.INHibernateProxy)">
            <summary>
            Gets the <see cref="T:NHibernate.Proxy.LazyInitializer"/> that is used by the Proxy.
            </summary>
            <param name="proxy">The Proxy object</param>
            <returns>
            A reference to <see cref="T:NHibernate.Proxy.LazyInitializer"/> that contains the details 
            of the Proxied object.
            </returns>
        </member>
        <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GetClass(System.Object)">
            <summary>
            Convenience method to figure out the underlying type for the object regardless of it
            is a Proxied object or the real object.
            </summary>
            <param name="obj">The object to get the type of.</param>
            <returns>The Underlying Type for the object regardless of if it is a Proxy.</returns>
        </member>
        <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GuessClass(System.Object)">
            <summary>
            Get the true, underlying class of a proxied persistent class. This operation
            will NOT initialize the proxy and thus may return an incorrect result.
            </summary>
            <param name="proxy">a persistable object or proxy</param>
            <returns>guessed class of the instance</returns>
            <remarks>
            This method is approximate match for Session.bestGuessEntityName in H3.2
            </remarks>
        </member>
        <member name="M:NHibernate.Proxy.ProxyTypeValidator.ValidateType(System.Type)">
            <summary>
            Validates whether <paramref name="type"/> can be specified as the base class
            (or an interface) for a dynamically-generated proxy.
            </summary>
            <returns>
            A collection of errors, if any, or <see langword="null" /> if none were found.
            </returns>
            <param name="type">The type to validate.</param>
        </member>
        <member name="T:NHibernate.SqlCommand.Alias">
            <summary>
            Aliases tables and fields for Sql Statements.
            </summary>
            <remarks>
            Several methods of this class take an additional
            <see cref="T:NHibernate.Dialect.Dialect"/> parameter, while their Java counterparts
            do not. The dialect is used to correctly quote and unquote identifiers.
            Java versions do the quoting and unquoting themselves and fail to
            consider dialect-specific rules, such as escaping closing brackets in
            identifiers on MS SQL 2000.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <param name="suffix"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="suffix"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToAliasString(System.String,NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifier"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToUnquotedAliasString(System.String,NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifier"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToUnquotedAliasStrings(System.String[],NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifiers"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToAliasStrings(System.String[],NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifiers"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.SqlCommand.ANSICaseFragment">
            <summary>
            Represents an SQL <c>case when ... then ... end as ...</c>
            </summary>
            <remarks>This class looks StringHelper.SqlParameter safe...</remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.CaseFragment">
            <summary>
            Represents an SQL <c>case when ... then ... end as ...</c>
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.CaseFragment.SetReturnColumnName(System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.CaseFragment.SetReturnColumnName(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.CaseFragment.AddWhenColumnNotNull(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnName"></param>
            <param name="columnValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.CaseFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.SetReturnColumnName(System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.SetReturnColumnName(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.AddWhenColumnNotNull(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnName"></param>
            <param name="columnValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ANSIJoinFragment">
            <summary>
            An ANSI-style Join.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.JoinFragment">
            <summary>
            Represents a SQL <c>JOIN</c>
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ConditionalFragment">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetOp(System.String)">
            <summary>
            Sets the op
            </summary>
            <param name="op">The op to set</param>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetTableAlias(System.String)">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetCondition(System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetCondition(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.DecodeCaseFragment">
            <summary>
            Represents an SQL decode(pkvalue, key1, 1, key2, 2, ..., 0)
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.SetReturnColumnName(System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.SetReturnColumnName(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.AddWhenColumnNotNull(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnName"></param>
            <param name="columnValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ForUpdateFragment">
            <summary>
            Represents an SQL <c>for update of ... nowait</c> statement
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.InFragment">
            <summary>
            Represents an <c>... in (...)</c> expression
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.AddValue(System.Object)">
            <summary>
            Add a value to the value list. Value may be a string,
            a <see cref="T:NHibernate.SqlCommand.Parameter"/>, or one of special values
            <see cref="F:NHibernate.SqlCommand.InFragment.Null"/> or <see cref="F:NHibernate.SqlCommand.InFragment.NotNull"/>.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.SetColumn(System.String)">
            <summary>
            
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.SetColumn(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.ToFragmentString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ISqlStringBuilder">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ISqlStringBuilder.ToSqlString">
            <summary>
            Builds a SqlString from the internal data.
            </summary>
            <returns>A valid SqlString that can be converted into an IDbCommand</returns>
        </member>
        <member name="T:NHibernate.SqlCommand.JoinType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.OracleJoinFragment">
            <summary>
            An Oracle-style (theta) Join
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddLeftOuterJoinCondition(System.String)">
            <summary>
            This method is a bit of a hack, and assumes
            that the column on the "right" side of the
            join appears on the "left" side of the
            operator, which is extremely wierd if this
            was a normal join condition, but is natural
            for a filter.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.Parameter">
            <summary>
            A placeholder for an ADO.NET parameter in an <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parameter.Placeholder">
            <summary>
            Used as a placeholder when parsing HQL or SQL queries.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.GenerateParameters(System.Int32)">
            <summary>
            Generates an array of parameters for the given <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see>.
            </summary>
            <param name="count">The number of parameters to generate.</param>
            <returns>An array of <see cref="T:NHibernate.SqlCommand.Parameter"/> objects</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.Equals(System.Object)">
            <summary>
            Determines wether this instance and the specified object 
            are of the same type and have the same values.
            </summary>
            <param name="obj">An object to compare to this instance.</param>
            <returns>
            <see langword="true" /> if the object equals the current instance.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.GetHashCode">
            <summary>
            Gets a hash code for the parameter.
            </summary>
            <returns>
            An <see cref="T:System.Int32"/> value for the hash code.
            </returns>
        </member>
        <member name="T:NHibernate.SqlCommand.QueryJoinFragment">
            <summary>
            Summary description for QueryJoinFragment.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.QuerySelect">
            <summary>
            Summary description for QuerySelect.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.QuerySelect.dontSpace">
            <summary>
            Certain databases don't like spaces around these operators.
            </summary>
            <remarks>
            This needs to contain both a plain string and a 
            SqlString version of the operator because the portions in 
            the WHERE clause will come in as SqlStrings since there
            might be parameters, other portions of the clause come in
            as strings since there are no parameters.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectFragmentString(System.String)">
            <summary>
            
            </summary>
            <param name="fragment"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectColumn(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="columnName"></param>
            <param name="alias"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetWhereTokens(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetGroupByTokens(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetOrderByTokens(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetHavingTokens(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddOrderBy(System.String)">
            <summary>
            Adds a string containing a valid "order by" sql statement
            to this QuerySelect
            </summary>
            <param name="orderBySql">The "order by" sql statement.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AppendTokens(System.Text.StringBuilder,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="buf"></param>
            <param name="iter"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AppendTokens(NHibernate.SqlCommand.SqlStringBuilder,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="builder"></param>
            <param name="iter"></param>
        </member>
        <member name="P:NHibernate.SqlCommand.QuerySelect.JoinFragment">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.QuerySelect.Distinct">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SelectFragment">
            <summary>
            Represents part of an SQL <c>SELECT</c> clause
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlBaseBuilder">
            <summary>
            The base class for all of the SqlBuilders.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String[])">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <returns>A SqlString that contains the WhereFragment</returns>
            <remarks>This just calls the overloaded ToWhereFragment() with the operator as " = " and the tableAlias null.</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String,System.String[])">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <returns>A SqlString that contains the WhereFragment</returns>
            <remarks>This defaults the op to " = "</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String[],System.String)">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <param name="op">The operator to use between the names &amp; values.  For example " = " or "!="</param>
            <returns>A SqlString that contains the WhereFragment</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String,System.String[],System.String)">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <param name="op">The operator to use between the names &amp; values.  For example " = " or "!="</param>
            <returns>A SqlString that contains the WhereFragment</returns>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlDeleteBuilder">
            <summary>
            A class that builds an <c>DELETE</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>DELETE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlDeleteBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>DELETE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlDeleteBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlDeleteBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.AddWhereFragment(System.String)">
            <summary>
            Adds a string to the WhereFragement
            </summary>
            <param name="whereSql">A well formed sql statement with no parameters.</param>
            <returns>The SqlDeleteBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlInsertBuilder">
            <summary>
            A class that builds an <c>INSERT</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.#ctor(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.SetTableName(System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Adds the Property's columns to the INSERT sql
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="propertyType">The IType of the property.</param>
            <returns>The SqlInsertBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,System.Object,NHibernate.Type.ILiteralType)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">The value to set for the column.</param>
            <param name="literalType">The NHibernateType to use to convert the value to a sql string.</param>
            <returns>The SqlInsertBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,System.String)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">A valid sql string to set as the value of the column.</param>
            <returns>The SqlInsertBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlSelectBuilder">
            <summary>
            Builds a <c>SELECT</c> SQL statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(System.String)">
            <summary>
            Sets the text that should appear after the FROM 
            </summary>
            <param name="fromClause">The fromClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(System.String,System.String)">
            <summary>
            Sets the text that should appear after the FROM 
            </summary>
            <param name="tableName">The name of the Table to get the data from</param>
            <param name="alias">The Alias to use for the table name.</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the text that should appear after the FROM
            </summary>
            <param name="fromClause">The fromClause in a SqlString</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOrderByClause(System.String)">
            <summary>
            Sets the text that should appear after the ORDER BY.
            </summary>
            <param name="orderByClause">The orderByClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetGroupByClause(System.String)">
            <summary>
            Sets the text that should appear after the GROUP BY.
            </summary>
            <param name="groupByClause">The groupByClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOuterJoins(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the SqlString for the OUTER JOINs.  
            </summary>
            <remarks>
            All of the Sql needs to be included in the SELECT.  No OUTER JOINS will automatically be
            added.
            </remarks>
            <param name="outerJoinsAfterFrom">The outerJoinsAfterFrom to set</param>
            <param name="outerJoinsAfterWhere">The outerJoinsAfterWhere to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetSelectClause(System.String)">
            <summary>
            Sets the text for the SELECT
            </summary>
            <param name="selectClause">The selectClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetWhereClause(System.String,System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the criteria to use for the WHERE.  It joins all of the columnNames together with an AND.
            </summary>
            <param name="tableAlias"></param>
            <param name="columnNames">The names of the columns</param>
            <param name="whereType">The Hibernate Type</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetWhereClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the prebuilt SqlString to the Where clause
            </summary>
            <param name="whereSqlString">The SqlString that contains the sql and parameters to add to the WHERE</param>
            <returns>This SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlSimpleSelectBuilder">
            <summary>
            Summary description for SqlSimpleSelectBuilder.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.#ctor(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetTableName(System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumn(System.String)">
            <summary>
            Adds a columnName to the SELECT fragment.
            </summary>
            <param name="columnName">The name of the column to add.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumn(System.String,System.String)">
            <summary>
            Adds a columnName and its Alias to the SELECT fragment.
            </summary>
            <param name="columnName">The name of the column to add.</param>
            <param name="alias">The alias to use for the column</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumns(System.String[])">
            <summary>
            Adds an array of columnNames to the SELECT fragment.
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumns(System.String[],System.String[])">
            <summary>
            Adds an array of columnNames with their Aliases to the SELECT fragment.
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="aliases">The aliases to use for the columns</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.GetAlias(System.String)">
            <summary>
            Gets the Alias that should be used for the column
            </summary>
            <param name="columnName">The name of the column to get the Alias for.</param>
            <returns>The Alias if one exists, null otherwise</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>SELECT</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlSimpleSelectBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>SELECT</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlSimpleSelectBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetForUpdateFragment(System.String)">
            <summary>
            Sets the For Update Fragment to the Select Command
            </summary>
            <param name="fragment">The fragment to set.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetOrderBy(System.String)">
            <summary>
            Set the Order By fragment of the Select Command
            </summary>
            <param name="orderBy">The OrderBy fragment.  It should include the SQL "ORDER BY"</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlString">
            <summary>
            This is a non-modifiable SQL statement that is ready to be prepared 
            and sent to the Database for execution.
            </summary>
            <remarks>
            <para>
            If you need to modify this object pass it to a <c>SqlStringBuilder</c> and
            get a new object back from it.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Append(NHibernate.SqlCommand.SqlString)">
            <summary>
            Appends the SqlString parameter to the end of the current SqlString to create a 
            new SqlString object.
            </summary>
            <param name="rhs">The SqlString to append.</param>
            <returns>A new SqlString object.</returns>
            <remarks>
            A SqlString object is immutable so this returns a new SqlString.  If multiple Appends 
            are called it is better to use the SqlStringBuilder.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Append(System.String)">
            <summary>
            Appends the string parameter to the end of the current SqlString to create a 
            new SqlString object.
            </summary>
            <param name="rhs">The string to append.</param>
            <returns>A new SqlString object.</returns>
            <remarks>
            A SqlString object is immutable so this returns a new SqlString.  If multiple Appends 
            are called it is better to use the SqlStringBuilder.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Compact">
            <summary>
            Compacts the SqlString into the fewest parts possible.
            </summary>
            <returns>A new SqlString.</returns>
            <remarks>
            Combines all SqlParts that are strings and next to each other into
            one SqlPart.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.EndsWith(System.String)">
            <summary>
            Determines whether the end of this instance matches the specified String.
            </summary>
            <param name="value">A string to seek at the end.</param>
            <returns><see langword="true" /> if the end of this instance matches value; otherwise, <see langword="false" /></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Replace(System.String,System.String)">
            <summary>
            Replaces all occurrences of a specified <see cref="T:System.String"/> in this instance, 
            with another specified <see cref="T:System.String"/> .
            </summary>
            <param name="oldValue">A String to be replaced.</param>
            <param name="newValue">A String to replace all occurrences of oldValue. </param>
            <returns>
            A new SqlString with oldValue replaced by the newValue.  The new SqlString is 
            in the compacted form.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.StartsWithCaseInsensitive(System.String)">
            <summary>
            Determines whether the beginning of this SqlString matches the specified System.String,
            using case-insensitive comparison.
            </summary>
            <param name="value">The System.String to seek</param>
            <returns>true if the SqlString starts with the value.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Substring(System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position. 
            </summary>
            <param name="startIndex">The starting character position of a substring in this instance.</param>
            <returns>
            A new SqlString to the substring that begins at startIndex in this instance. 
            </returns>
            <remarks>
            If the startIndex is greater than the length of the SqlString then <see cref="F:NHibernate.SqlCommand.SqlString.Empty"/> is returned.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.IndexOfCaseInsensitive(System.String)">
            <summary>
            Returns the index of the first occurence of <paramref name="text"/>, case-insensitive.
            </summary>
            <param name="text">Text to look for in the <see cref="T:NHibernate.SqlCommand.SqlString"/>. Must be in lower
            case.</param>
            <remarks>
            The text must be located entirely in a string part of the <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            Searching for <c>"a ? b"</c> in an <see cref="T:NHibernate.SqlCommand.SqlString"/> consisting of
            <c>"a ", Parameter, " b"</c> will result in no matches.
            </remarks>
            <returns>The index of the first occurence of <paramref name="text"/>, or -1
            if not found.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Trim">
            <summary>
            Removes all occurrences of white space characters from the beginning and end of this instance.
            </summary>
            <returns>
            A new SqlString equivalent to this instance after white space characters 
            are removed from the beginning and end.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.ToString">
            <summary>
            Returns the SqlString in a string where it looks like
            SELECT col1, col2 FROM table WHERE col1 = ?
            </summary>
            <remarks>
            The question mark is used as the indicator of a parameter because at
            this point we are not using the specific provider so we don't know
            how that provider wants our parameters formatted.
            </remarks>
            <returns>A provider-neutral version of the CommandText</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.SubstringStartingWithLast(System.String)">
            <summary>
            Returns substring of this SqlString starting with the specified
            <paramref name="text" />. If the text is not found, returns an
            empty, not-null SqlString.
            </summary>
            <remarks>
            The method performs case-insensitive comparison, so the <paramref name="text" />
            passed should be in lower case.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Parse(System.String)">
            <summary>
            Parse SQL in <paramref name="sql" /> and create a SqlString representing it.
            </summary>
            <remarks>
            Parameter marks in single quotes will be correctly skipped, but otherwise the
            lexer is very simple and will not parse double quotes or escape sequences
            correctly, for example.
            </remarks>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlString.Count">
            <summary>
            Gets the number of SqlParts contained in this SqlString.
            </summary>
            <value>The number of SqlParts contained in this SqlString.</value>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlStringBuilder">
            <summary>
            The SqlStringBuilder is used to construct a SqlString.
            </summary>
            <remarks>
            <para>
            The SqlString is a nonmutable class so it can't have sql parts added
            to it.  Instead this class should be used to generate a new SqlString.
            The SqlStringBuilder is to SqlString what the StringBuilder is to
            a String.
            </para>
            <para>
            This is different from the original version of SqlString because this does not
            hold the sql string in the form of "column1=@column1" instead it uses an array to
            build the sql statement such that 
            object[0] = "column1="
            object[1] = ref to column1 parameter
            </para>
            <para>
            What this allows us to do is to delay the generating of the parameter for the sql
            until the very end - making testing dialect indifferent.  Right now all of our test
            to make sure the correct sql is getting built are specific to MsSql2000Dialect.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor">
            <summary>
            Create an empty StringBuilder with the default capacity.  
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor(System.Int32)">
            <summary>
            Create a StringBuilder with a specific capacity.
            </summary>
            <param name="partsCapacity">The number of parts expected.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor(NHibernate.SqlCommand.SqlString)">
            <summary>
            Create a StringBuilder to modify the SqlString
            </summary>
            <param name="sqlString">The SqlString to modify.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(System.String)">
            <summary>
            Adds the preformatted sql to the SqlString that is being built.
            </summary>
            <param name="sql">The string to add.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.Parameter)">
            <summary>
            Adds the Parameter to the SqlString that is being built.
            The correct operator should be added before the Add(Parameter) is called
            because there will be no operator ( such as "=" ) placed between the last Add call
            and this Add call.
            </summary>
            <param name="parameter">The Parameter to add.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.AddObject(System.Object)">
            <summary>
            Attempts to discover what type of object this is and calls the appropriate
            method.
            </summary>
            <param name="part">The part to add when it is not known if it is a Parameter, String, or SqlString.</param>
            <returns>This SqlStringBuilder.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the part is not a Parameter, String, or SqlString.</exception>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString)">
            <summary>
            Adds an existing SqlString to this SqlStringBuilder.  It does NOT add any
            prefix, postfix, operator, or wrap around this.  It is equivalent to just 
            adding a string.
            </summary>
            <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>This calls the overloaded Add(sqlString, null, null, null, false)</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString,System.String,System.String,System.String)">
            <summary>
            Adds an existing SqlString to this SqlStringBuilder
            </summary>
            <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
            <param name="prefix">String to put at the beginning of the combined SqlString.</param>
            <param name="op">How these Statements should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlString.</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>
            This calls the overloaded Add method with an array of SqlStrings and wrapStatment=false
            so it will not be wrapped with a "(" and ")"
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString[],System.String,System.String,System.String)">
            <summary>
            Adds existing SqlStrings to this SqlStringBuilder
            </summary>
            <param name="sqlStrings">The SqlStrings to combine.</param>
            <param name="prefix">String to put at the beginning of the combined SqlString.</param>
            <param name="op">How these SqlStrings should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlStrings.</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>This calls the overloaded Add method with wrapStatement=true</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString[],System.String,System.String,System.String,System.Boolean)">
            <summary>
            Adds existing SqlStrings to this SqlStringBuilder
            </summary>
            <param name="sqlStrings">The SqlStrings to combine.</param>
            <param name="prefix">String to put at the beginning of the combined SqlStrings.</param>
            <param name="op">How these SqlStrings should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlStrings.</param>
            <param name="wrapStatement">Wrap each SqlStrings with "(" and ")"</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Insert(System.Int32,System.String)">
            <summary>
            Insert a string containing sql into the SqlStringBuilder at the specified index.
            </summary>
            <param name="index">The zero-based index at which the sql should be inserted.</param>
            <param name="sql">The string containing sql to insert.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Insert(System.Int32,NHibernate.SqlCommand.Parameter)">
            <summary>
            Insert a Parameter into the SqlStringBuilder at the specified index.
            </summary>
            <param name="index">The zero-based index at which the Parameter should be inserted.</param>
            <param name="param">The Parameter to insert.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.RemoveAt(System.Int32)">
            <summary>
            Removes the string or Parameter at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.ToSqlString">
            <summary>
            Converts the mutable SqlStringBuilder into the immutable SqlString.
            </summary>
            <returns>The SqlString that was built.</returns>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlStringBuilder.Count">
            <summary>
            Gets the number of SqlParts in this SqlStringBuilder.
            </summary>
            <returns>
            The number of SqlParts in this SqlStringBuilder.
            </returns>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlStringBuilder.Item(System.Int32)">
            <summary>
            Gets or Sets the element at the index
            </summary>
            <value>Returns a string or Parameter.</value>
            <remarks></remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlUpdateBuilder">
            <summary>
            A class that builds an <c>UPDATE</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetTableName(System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumn(System.String,System.Object,NHibernate.Type.ILiteralType)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">The value to set for the column.</param>
            <param name="literalType">The NHibernateType to use to convert the value to a sql string.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumn(System.String,System.String)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">A valid sql string to set as the value of the column.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],System.String)">
            <summary>
            Adds columns with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The names of the Column sto add.</param>
            <param name="val">A valid sql string to set as the value of the column.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],NHibernate.Type.IType)">
            <summary>
            Adds the Property's columns to the UPDATE sql
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="propertyType">The IType of the property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>UPDATE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>UPDATE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlUpdateBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddWhereFragment(System.String)">
            <summary>
            Adds a string to the WhereFragement
            </summary>
            <param name="whereSql">A well formed sql string with no parameters.</param>
            <returns>The SqlUpdateBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SubselectClauseExtractor">
            <summary>
            Given an SQL SELECT statement, parse it to extract clauses starting with
            <c>FROM</c>, up to and not including <c>ORDER BY</c> (known collectively
            as a subselect clause).
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.SubselectClauseExtractor.builder">
            <summary>
            Contains the subselect clause as it is being built.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlCommand.SubselectClauseExtractor"/> class.
            </summary>
            <param name="sqlParts">The parts of an <see cref="T:NHibernate.SqlCommand.SqlString"/> to extract the subselect clause from.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.ProcessPartBeforeFrom(System.Object)">
            <summary>
            Looks for a <c>FROM</c> clause in the <paramref name="part"/>
            and adds the clause to the result if found.
            </summary>
            <param name="part">A <see cref="T:System.String"/> or a <see cref="T:NHibernate.SqlCommand.Parameter"/>.</param>
            <returns><see langword="true"/> if the part contained a <c>FROM</c> clause,
            <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.GetSqlString">
            <summary>
            Returns the subselect clause of the statement
            being processed.
            </summary>
            <returns>An <see cref="T:NHibernate.SqlCommand.SqlString"/> containing
            the subselect clause of the original <c>SELECT</c>
            statement.</returns>
        </member>
        <member name="T:NHibernate.SqlCommand.WhereBuilder">
            <summary>
            Allows us to construct SQL WHERE fragments
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.SqlType">
            <summary>
            This is the base class that adds information to the <see cref="P:NHibernate.SqlTypes.SqlType.DbType"/> 
            for the <see cref="T:NHibernate.Driver.IDriver"/> and <see cref="T:NHibernate.Dialect.Dialect"/>
            to use.
            </summary>
            <remarks>
            <p>
            The <see cref="T:NHibernate.Driver.IDriver"/> uses the SqlType to get enough
            information to create an <see cref="T:System.Data.IDbDataParameter"/>.  
            </p>
            <p>
            The <see cref="T:NHibernate.Dialect.Dialect"/> use the SqlType to convert the <see cref="P:NHibernate.SqlTypes.SqlType.DbType"/>
            to the appropriate sql type for SchemaExport.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.AnsiStringSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.AnsiString"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.BinaryBlobSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Binary"/> that is stored in
            a BLOB column with the information required to generate 
            an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            <p>
            This can store the length of the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </p>
            <p>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a 
            BinarySqlType would work just fine.
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.BinarySqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Binary"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.BinarySqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinarySqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.BinarySqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinarySqlType"/> class.
            </summary>
            <param name="length">The length of the binary data the <see cref="T:System.Data.IDbDataParameter"/> should hold</param>
        </member>
        <member name="M:NHibernate.SqlTypes.BinaryBlobSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinaryBlobSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.SqlTypeFactory">
            <summary>
            SqlTypeFactory provides Singleton access to the SqlTypes.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.StringClobSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.String"/> that is stored in
            a CLOB column with the information required to generate 
            an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            <p>
            This can store the length of the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </p>
            <p>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a 
            StringSqlType would work just fine.
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.StringSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.String"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.StringSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="M:NHibernate.SqlTypes.StringClobSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringClobSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringClobSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringClobSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.StringFixedLengthSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.StringFixedLength"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.StringFixedLengthSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringFixedLengthSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringFixedLengthSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringFixedLengthSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.AdoColumn">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoColumn.#ctor(System.Data.DataColumn)">
            <summary>
            
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoColumn.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoColumn.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoColumn.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoColumn.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoColumn.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoColumn.ColumnSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoColumn.IsNullable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.AdoTable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoTable.#ctor(System.Data.DataTable)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoTable.Columns">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.SchemaExport">
            <summary>
            Generates ddl to export table schema for a configured <c>Configuration</c> to the database
            </summary>
            <remarks>
            This Class can be used directly or the command line wrapper NHibernate.Tool.hbm2ddl.exe can be
            used when a dll can not be directly used.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.#ctor(NHibernate.Cfg.Configuration)">
            <summary>
            Create a schema exported for a given Configuration
            </summary>
            <param name="cfg">The NHibernate Configuration to generate the schema from.</param>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.#ctor(NHibernate.Cfg.Configuration,System.Collections.IDictionary)">
            <summary>
            Create a schema exporter for the given Configuration, with the given
            database connection properties
            </summary>
            <param name="cfg">The NHibernate Configuration to generate the schema from.</param>
            <param name="connectionProperties">The Properties to use when connecting to the Database.</param>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.SetOutputFile(System.String)">
            <summary>
            Set the output filename. The generated script will be written to this file
            </summary>
            <param name="filename">The name of the file to output the ddl to.</param>
            <returns>The SchemaExport object.</returns>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.SetDelimiter(System.String)">
            <summary>
            Set the end of statement delimiter 
            </summary>
            <param name="delimiter">The end of statement delimiter.</param>
            <returns>The SchemaExport object.</returns>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Create(System.Boolean,System.Boolean)">
            <summary>
            Run the schema creation script
            </summary>
            <param name="script"><see langword="true"/> if the ddl should be outputted in the Console.</param>
            <param name="export"><see langword="true"/> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> and sets
            the justDrop parameter to false and the format parameter to true.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Drop(System.Boolean,System.Boolean)">
            <summary>
            Run the drop schema script
            </summary>
            <param name="script"><see langword="true"/> if the ddl should be outputted in the Console.</param>
            <param name="export"><see langword="true"/> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> and sets
            the justDrop and format parameter to true.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Data.IDbConnection,System.IO.TextWriter)">
            <summary>
            Executes the Export of the Schema in the given connection
            </summary>
            <param name="script"><see langword="true" /> if the ddl should be outputted in the Console.</param>
            <param name="export"><see langword="true" /> if the ddl should be executed against the Database.</param>
            <param name="justDrop"><see langword="true" /> if only the ddl to drop the Database objects should be executed.</param>
            <param name="format"><see langword="true" /> if the ddl should be nicely formatted instead of one statement per line.</param>
            <param name="connection">
            The connection to use when executing the commands when export is <see langword="true" />.
            Must be an opened connection. The method doesn't close the connection.
            </param>
            <param name="exportOutput">The writer used to output the generated schema</param>
            <remarks>
            This method allows for both the drop and create ddl script to be executed.
            This overload is provided mainly to enable use of in memory databases. 
            It does NOT close the given connection!
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Executes the Export of the Schema.
            </summary>
            <param name="script"><see langword="true" /> if the ddl should be outputted in the Console.</param>
            <param name="export"><see langword="true" /> if the ddl should be executed against the Database.</param>
            <param name="justDrop"><see langword="true" /> if only the ddl to drop the Database objects should be executed.</param>
            <param name="format"><see langword="true" /> if the ddl should be nicely formatted instead of one statement per line.</param>
            <remarks>
            This method allows for both the drop and create ddl script to be executed.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Format(System.String)">
            <summary>
            Format an SQL statement using simple rules
            </summary>
            <param name="sql">The string containing the sql to format.</param>
            <returns>A string that contains formatted sql.</returns>
            <remarks>
            The simple rules to used when formatting are:
            <list type="number">
            	<item>
            		<description>Insert a newline after each comma</description>
            	</item>
            	<item>
            		<description>Indent three spaces after each inserted newline</description>
            	</item>
            	<item>
            		<description>
            		If the statement contains single/double quotes return unchanged because
            		it is too complex and could be broken by simple formatting.
            		</description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Transaction.ITransactionFactory">
            <summary>
            An abstract factory for <c>ITransaction</c> instances.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.ITransactionFactory.Configure(System.Collections.IDictionary)">
            <summary>
            Configure from the given properties
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:NHibernate.Transaction.ITransactionFactory.CreateTransaction(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a new transaction and return it without starting it.
            </summary>
        </member>
        <member name="T:NHibernate.Transaction.AdoTransaction">
            <summary>
            Wraps an ADO.NET <see cref="T:System.Data.IDbTransaction"/> to implement
            the <see cref="T:NHibernate.ITransaction"/> interface.
            </summary>
        </member>
        <member name="T:NHibernate.ITransaction">
            <summary>
            Allows the application to define units of work, while maintaining abstraction from the
            underlying transaction implementation
            </summary>
            <remarks>
            A transaction is associated with a <c>ISession</c> and is usually instanciated by a call to
            <c>ISession.BeginTransaction()</c>. A single session might span multiple transactions since 
            the notion of a session (a conversation between the application and the datastore) is of
            coarser granularity than the notion of a transaction. However, it is intended that there be
            at most one uncommitted <c>ITransaction</c> associated with a particular <c>ISession</c>
            at a time. Implementors are not intended to be threadsafe.
            </remarks>
        </member>
        <member name="M:NHibernate.ITransaction.Begin">
            <summary>
            Begin the transaction with the default isolation level.
            </summary>
        </member>
        <member name="M:NHibernate.ITransaction.Begin(System.Data.IsolationLevel)">
            <summary>
            Begin the transaction with the specified isolation level.
            </summary>
            <param name="isolationLevel">Isolation level of the transaction</param>
        </member>
        <member name="M:NHibernate.ITransaction.Commit">
            <summary>
            Flush the associated <c>ISession</c> and end the unit of work.
            </summary>
            <remarks>
            This method will commit the underlying transaction if and only if the transaction
            was initiated by this object.
            </remarks>
        </member>
        <member name="M:NHibernate.ITransaction.Rollback">
            <summary>
            Force the underlying transaction to roll back.
            </summary>
        </member>
        <member name="M:NHibernate.ITransaction.Enlist(System.Data.IDbCommand)">
            <summary>
            Enlist the <see cref="T:System.Data.IDbCommand"/> in the current Transaction.
            </summary>
            <param name="command">The <see cref="T:System.Data.IDbCommand"/> to enlist.</param>
            <remarks>
            It is okay for this to be a no op implementation.
            </remarks>
        </member>
        <member name="P:NHibernate.ITransaction.IsActive">
            <summary>
            Is the transaction in progress
            </summary>
        </member>
        <member name="P:NHibernate.ITransaction.WasRolledBack">
            <summary>
            Was the transaction rolled back or set to rollback only?
            </summary>
        </member>
        <member name="P:NHibernate.ITransaction.WasCommitted">
            <summary>
            Was the transaction successfully committed?
            </summary>
            <remarks>
            This method could return <see langword="false" /> even after successful invocation of <c>Commit()</c>
            </remarks>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Transaction.AdoTransaction"/> class.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the Transaction is for.</param>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Enlist(System.Data.IDbCommand)">
            <summary>
            Enlist the <see cref="T:System.Data.IDbCommand"/> in the current <see cref="T:NHibernate.ITransaction"/>.
            </summary>
            <param name="command">The <see cref="T:System.Data.IDbCommand"/> to enlist in this Transaction.</param>
            <remarks>
            <para>
            This takes care of making sure the <see cref="T:System.Data.IDbCommand"/>'s Transaction property 
            contains the correct <see cref="T:System.Data.IDbTransaction"/> or <see langword="null"/> if there is no
            Transaction for the ISession - ie <c>BeginTransaction()</c> not called.
            </para>
            <para>
            This method may be called even when the transaction is disposed.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Begin(System.Data.IsolationLevel)">
            <summary>
            Begins the <see cref="T:System.Data.IDbTransaction"/> on the <see cref="T:System.Data.IDbConnection"/>
            used by the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any problems encountered while trying to create
            the <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Commit">
            <summary>
            Commits the <see cref="T:NHibernate.ITransaction"/> by flushing the <see cref="T:NHibernate.ISession"/>
            and committing the <see cref="T:System.Data.IDbTransaction"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any exception while trying to call <c>Commit()</c> on 
            the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Rollback">
            <summary>
            Rolls back the <see cref="T:NHibernate.ITransaction"/> by calling the method <c>Rollback</c> 
            on the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any exception while trying to call <c>Rollback()</c> on 
            the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="F:NHibernate.Transaction.AdoTransaction._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this AdoTransaction is being Disposed of or Finalized.</param>
            <remarks>
            If this AdoTransaction is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this AdoTransaction back to life.
            </remarks>
        </member>
        <member name="P:NHibernate.Transaction.AdoTransaction.WasRolledBack">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the transaction was rolled back.
            </summary>
            <value>
            <see langword="true"/> if the <see cref="T:System.Data.IDbTransaction"/> had <c>Rollback</c> called
            without any exceptions.
            </value>
        </member>
        <member name="P:NHibernate.Transaction.AdoTransaction.WasCommitted">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the transaction was committed.
            </summary>
            <value>
            <see langword="true"/> if the <see cref="T:System.Data.IDbTransaction"/> had <c>Commit</c> called
            without any exceptions.
            </value>
        </member>
        <member name="T:NHibernate.Transform.IResultTransformer">
            <summary>
            Implementors define a strategy for transforming criteria query
            results into the actual application-visible query result list.
            </summary>
            <seealso cref="M:NHibernate.ICriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)"/>
        </member>
        <member name="M:NHibernate.Transform.IResultTransformer.TransformTuple(System.Object[],System.String[])">
            <summary>
            
            </summary>
            <param name="tuple"></param>
            <param name="aliases"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Transform.IResultTransformer.TransformList(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Transform.AliasToBeanResultTransformer">
            <summary>
            Result transformer that allows to transform a result to 
            a user specified class which will be populated via setter  
            methods or fields matching the alias names. 
            </summary>
            <example>
            <code>
            IList resultWithAliasedBean = s.CreateCriteria(typeof(Enrollment))
            			.CreateAlias("Student", "st")
            			.CreateAlias("Course", "co")
            			.SetProjection( Projections.ProjectionList()
            					.Add( Projections.Property("co.Description"), "CourseDescription" )
            			)
            			.SetResultTransformer( new AliasToBeanResultTransformer(typeof(StudentDTO)) )
            			.List();
            
            StudentDTO dto = (StudentDTO)resultWithAliasedBean[0];
            </code>
            </example>
        </member>
        <member name="F:NHibernate.Transform.Transformers.AliasToEntityMap">
            <summary>
            Each row of results is a map (<see cref="T:System.Collections.IDictionary"/>) from alias to values/entities
            </summary>
        </member>
        <member name="M:NHibernate.Transform.Transformers.AliasToBean(System.Type)">
            <summary>
            Creates a resulttransformer that will inject aliased values into instances
            of <paramref name="target"/> via property methods or fields.
            </summary>
        </member>
        <member name="T:NHibernate.Tuple.IdentifierProperty">
            <summary>
            Represents a defined entity identifier property within the Hibernate
            runtime-metamodel.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="T:NHibernate.Tuple.Property">
            <summary>
            Defines the basic contract of a Property within the runtime metamodel.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.Property.#ctor(System.String,System.String,NHibernate.Type.IType)">
            <summary>
            Constructor for Property instances.
            </summary>
            <param name="name">The name by which the property can be referenced within its owner.</param>
            <param name="node">The node name to use for XML-based representation of this property.</param>
            <param name="type">The Hibernate Type of this property.</param>
        </member>
        <member name="M:NHibernate.Tuple.IdentifierProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,NHibernate.Engine.Cascades.IdentifierValue,NHibernate.Id.IIdentifierGenerator)">
            <summary>
            Construct a non-virtual identifier property. 
            </summary>
            <param name="name">The name of the property representing the identifier within
            its owning entity.</param>
            <param name="node">The node name to use for XML-based representation of this
            property.</param>
            <param name="type">The Hibernate Type for the identifier property.</param>
            <param name="embedded">Is this an embedded identifier.</param>
            <param name="unsavedValue">The value which, if found as the value on the identifier
            property, represents new (i.e., un-saved) instances of the owning entity.</param>
            <param name="identifierGenerator">The generator to use for id value generation.</param>
        </member>
        <member name="M:NHibernate.Tuple.IdentifierProperty.#ctor(NHibernate.Type.IType,System.Boolean,NHibernate.Engine.Cascades.IdentifierValue,NHibernate.Id.IIdentifierGenerator)">
            <summary>
            Construct a virtual IdentifierProperty. 
            </summary>
            <param name="type">The Hibernate Type for the identifier property.</param>
            <param name="embedded">Is this an embedded identifier.</param>
            <param name="unsavedValue">The value which, if found as the value on the identifier
            property, represents new (i.e., un-saved) instances of the owning entity.</param>
            <param name="identifierGenerator">The generator to use for id value generation.</param>
        </member>
        <member name="T:NHibernate.Tuple.PropertyFactory">
            <summary>
            Responsible for generation of runtime metamodel <see cref="T:NHibernate.Tuple.Property"/> representations.
            Makes distinction between identifier, version, and other (standard) properties.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.PropertyFactory.BuildIdentifierProperty(NHibernate.Mapping.PersistentClass,NHibernate.Id.IIdentifierGenerator)">
            <summary>
            Generates an IdentifierProperty representation of the for a given entity mapping.
            </summary>
            <param name="mappedEntity">The mapping definition of the entity.</param>
            <param name="generator">The identifier value generator to use for this identifier.</param>
            <returns>The appropriate IdentifierProperty definition.</returns>
        </member>
        <member name="M:NHibernate.Tuple.PropertyFactory.BuildVersionProperty(NHibernate.Mapping.Property,System.Boolean)">
            <summary>
            Generates a VersionProperty representation for an entity mapping given its
            version mapping Property.
            </summary>
            <param name="property">The version mapping Property.</param>
            <param name="lazyAvailable">Is property lazy loading currently available.</param>
            <returns>The appropriate VersionProperty definition.</returns>
        </member>
        <member name="M:NHibernate.Tuple.PropertyFactory.BuildStandardProperty(NHibernate.Mapping.Property,System.Boolean)">
            <summary>
            Generate a "standard" (i.e., non-identifier and non-version) based on the given
            mapped property.
            </summary>
            <param name="property">The mapped property.</param>
            <param name="lazyAvailable">Is property lazy loading currently available.</param>
            <returns>The appropriate StandardProperty definition.</returns>
        </member>
        <member name="T:NHibernate.Tuple.StandardProperty">
            <summary>
            Represents a basic property within the Hibernate runtime-metamodel.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.StandardProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,NHibernate.Engine.Cascades.CascadeStyle)">
            <summary>
            Constructs StandardProperty instances.
            </summary>
            <param name="name">The name by which the property can be referenced within
            its owner.</param>
            <param name="node">The node name to use for XML-based representation of this
            property.</param>
            <param name="type">The Hibernate Type of this property.</param>
            <param name="lazy">Should this property be handled lazily?</param>
            <param name="insertable">Is this property an insertable value?</param>
            <param name="updateable">Is this property an updateable value?</param>
            <param name="insertGenerated">Is this property generated in the database on insert?</param>
            <param name="updateGenerated">Is this property generated in the database on update?</param>
            <param name="nullable">Is this property a nullable value?</param>
            <param name="checkable">Is this property a checkable value?</param>
            <param name="versionable">Is this property a versionable value?</param>
            <param name="cascadeStyle">The cascade style for this property's value.</param>
        </member>
        <member name="T:NHibernate.Tuple.VersionProperty">
            <summary>
            Represents a version property within the Hibernate runtime-metamodel.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.VersionProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,NHibernate.Engine.Cascades.CascadeStyle,NHibernate.Engine.Cascades.VersionValue)">
            <summary>
            Constructs VersionProperty instances.
            </summary>
            <param name="name">The name by which the property can be referenced within
            its owner.</param>
            <param name="node">The node name to use for XML-based representation of this
            property.</param>
            <param name="type">The Hibernate Type of this property.</param>
            <param name="lazy">Should this property be handled lazily?</param>
            <param name="insertable">Is this property an insertable value?</param>
            <param name="updateable">Is this property an updateable value?</param>
            <param name="insertGenerated">Is this property generated in the database on insert?</param>
            <param name="updateGenerated">Is this property generated in the database on update?</param>
            <param name="nullable">Is this property a nullable value?</param>
            <param name="checkable">Is this property a checkable value?</param>
            <param name="versionable">Is this property a versionable value?</param>
            <param name="cascadeStyle">The cascade style for this property's value.</param>
            <param name="unsavedValue">The value which, if found as the value of
            this (i.e., the version) property, represents new (i.e., un-saved)
            instances of the owning entity.</param>
        </member>
        <member name="T:NHibernate.Type.AbstractType">
            <summary>
            The base implementation of the <see cref="T:NHibernate.Type.IType"/> interface.
            Mapping of the built in Type hierarchy.
            </summary>
        </member>
        <member name="T:NHibernate.Type.IType">
            <summary>
			Defines a mapping from a .NET <see cref="T:System.Type"/> to a SQL datatype.
			This interface is intended to be implemented by applications that need custom types.
		</summary><remarks>
			Implementors should usually be immutable and MUST definately be threadsafe.
		</remarks>
        </member>
        <member name="M:NHibernate.Type.IType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="T:NHibernate.SqlTypes.SqlType"/>s.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns how many columns are used to persist this type.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>The number of columns this IType spans.</returns><exception cref="T:NHibernate.MappingException">MappingException</exception> 
        </member>
        <member name="M:NHibernate.Type.IType.Equals(System.Object,System.Object)">
            <summary>
		When implemented by a class, compare two instances of the class mapped by this 
		IType for persistence "equality" - ie. Equality of persistent state.
		</summary><param name="x">The left hand side object.</param><param name="y">The right hand side object.</param><returns>True if the two objects contain the same values.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.GetHashCode(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Get a hashcode, consistent with persistence "equality"
            </summary>
        </member>
        <member name="M:NHibernate.Type.IType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, should the parent be considered dirty, 
		given both the old and current field or element value?
		</summary><param name="old">The old value</param><param name="current">The current value</param><param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> </param><returns>true if the field is dirty</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object mapped by 
		this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementors should handle possibility of null values.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object 
		mapped by this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="name">The name of the column in the <see cref="T:System.Data.IDataReader"/> that contains the 
		value to populate the IType with.</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementations should handle possibility of null values.
		This method might be called if the IType is known to be a single-column type.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param><param name="value">The object that contains the values.</param><param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param><param name="session"></param><param name="settable">Indicates which columns are to be set.</param><remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">
			The <see cref="T:System.Data.IDbCommand"/> to put the values into.
		</param><param name="value">The object that contains the values.</param><param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.
		</param><param name="session"></param><remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.FromString(System.String)">
            <summary>
		Parse the XML representation of an instance
		</summary><param name="xml"></param><returns>an instance of the type</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.DeepCopy(System.Object)">
            <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary><param name="val">A Collection element or Entity field</param><returns>A deep copy of the object.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, retrives an instance of the mapped class, 
		or the identifier of an entity or collection from a <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values.</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session">the session</param><param name="owner">The parent Entity</param><returns>An identifier or actual object mapped by this IType.</returns><remarks>
		<para>
		This is useful for 2-phase property initialization - the second phase is a call to
		<c>ResolveIdentifier()</c>
		</para>
		<para>
		Most implementors of this method will just pass the call to <c>NullSafeGet()</c>.
		</para>
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, maps identifiers to Entities or Collections. 
		</summary><param name="value">An identifier or value returned by <c>Hydrate()</c></param><param name="session">The session</param><param name="owner">The parent Entity</param><returns>The Entity or Collection referenced by this Identifier.</returns><remarks>
		This is the second phase of 2-phase property initialization.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.SemiResolve(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Given a hydrated, but unresolved value, return a value that may be used to
            reconstruct property-ref associations.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.Copy&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.IType.IsDatabaseNull(System.Object)">
            <summary>
            Determines whether the specified value is represented as <see langword="null" /> in the database.
            </summary>
            <param name="value">The value, may be <see langword="null" />.</param>
            <returns>
            <see langword="true" /> if the specified value is represented as <see langword="null" /> in the database;
            otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="P:NHibernate.Type.IType.IsAssociationType">
            <summary>
			When implemented by a class, gets a value indicating if the implementor is castable to an an <see cref="T:NHibernate.Type.IAssociationType"/>
		</summary><value>true if this is an Association</value><remarks>This does not necessarily imply that the type actually represents an association.</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.IsCollectionType">
            <summary>
			When implemented by a class, gets a value indicating if the implementor is a collection type
		</summary><value>true if this is a <see cref="T:NHibernate.Type.CollectionType"/>.</value> 
        </member>
        <member name="P:NHibernate.Type.IType.IsComponentType">
            <summary>
		When implemented by a class, gets a value indicating if the implementor 
		is an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
		</summary><value>true if this is an <see cref="T:NHibernate.Type.IAbstractComponentType"/></value><remarks>
		If true, the implementation must be castable to <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
		A component type may own collections or associations and hence must provide certain extra functionality.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.IsEntityType">
            <summary>
		When implemented by a class, gets a value indicating if the implementor 
		extends <see cref="T:NHibernate.Type.EntityType"/>
		</summary><value>true if this is an <see cref="T:NHibernate.Type.EntityType"/></value> 
        </member>
        <member name="P:NHibernate.Type.IType.IsAnyType">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;P:IType.IsAnyType&quot;]/*"/> 
        </member>
        <member name="P:NHibernate.Type.IType.ReturnedClass">
            <summary>
		When implemented by a class, gets the <see cref="T:System.Type"/> returned 
		by the <c>NullSafeGet()</c> methods.
		</summary><value>
		The <see cref="T:System.Type"/> from the .NET framework.
		</value><remarks>
		This is used to establish the class of an array of this Itype
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.Name">
            <summary>
		When implemented by a class, gets the abbreviated name of the type.
		</summary><value>The NHibernate type name.</value> 
        </member>
        <member name="P:NHibernate.Type.IType.IsMutable">
            <summary>
		When implemented by a class, gets the value indicating if the objects 
		of this IType are mutable.
		</summary><value>true if the objects mapped by this IType are mutable.</value><remarks>
		With respect to the referencing object...
		Entities and Collections are considered immutable because they manage their own internal state.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.HasNiceEquals">
            <summary>
		When implemented by a class, gets whether or not this IType contains 
		<see cref="T:System.Type"/>s that implement well-behaived <c>Equals()</c> method.
		</summary><value>true if a well-behaived <c>Equals()</c> is implemented.</value><remarks>
		<para>
		Strickly, if this method returns <c>true</c> then <c>x.Equals(y)</c> implies
		<c>IType.Equals(x, y)</c> and also <c>IType.Equals(x, y)</c> implies that
		probably <c>x.Equals(y)</c>
		</para>
		<para>
		In the default implementations <see cref="T:NHibernate.Type.ImmutableType"/>s are assumed to have
		HaveNiceEquals==true and <see cref="T:NHibernate.Type.MutableType"/>s are assumed to have 
		HaveNiceEquals==false.
		</para>
		<para>
		This code doesn't look like it is used anywhere internally because I did a search
		on ".HasNiceEquals" and found no results.  So it looks like it is used for a description
		of the IType only.
		</para>
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Disassembles the object into a cacheable representation.
            </summary>
            <param name="value">The value to disassemble.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <returns>The disassembled, deep cloned state of the object</returns>
            <remarks>
            This method calls DeepCopy if the value is not null.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Reconstructs the object from its cached "disassembled" state.
            </summary>
            <param name="cached">The disassembled state from the cache</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <param name="owner">The parent Entity object is not used by this method</param>
            <returns>The assembled object.</returns>
            <remarks>
            This method calls DeepCopy if the value is not null.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Should the parent be considered dirty, given both the old and current 
            field or element value?
            </summary>
            <param name="old">The old value</param>
            <param name="current">The current value</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <returns>true if the field is dirty</returns>
            <remarks>This method uses <c>IType.Equals(object, object)</c> to determine the value of IsDirty.</remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Retrives an instance of the mapped class, or the identifier of an entity 
            or collection from a <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values.</param>
            <param name="names">
            The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
            value to populate the IType with.
            </param>
            <param name="session">the session</param>
            <param name="owner">The parent Entity</param>
            <returns>An identifier or actual object mapped by this IType.</returns>
            <remarks>
            This method uses the <c>IType.NullSafeGet(IDataReader, string[], ISessionImplementor, object)</c> method
            to Hydrate this <see cref="T:NHibernate.Type.AbstractType"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Maps identifiers to Entities or Collections. 
            </summary>
            <param name="value">An identifier or value returned by <c>Hydrate()</c></param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <param name="owner">The parent Entity is not used by this method.</param>
            <returns>The value.</returns>
            <remarks>
            There is nothing done in this method other than return the value parameter passed in.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.IsModified(System.Object,System.Object,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Says whether the value has been modified
            </summary>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="original"></param>
            <param name="current"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <param name="copiedAlready"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AbstractType.DeepCopy(System.Object)">
            <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary><param name="val">A Collection element or Entity field</param><returns>A deep copy of the object.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="T:NHibernate.SqlTypes.SqlType"/>s.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns how many columns are used to persist this type.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>The number of columns this IType spans.</returns><exception cref="T:NHibernate.MappingException">MappingException</exception> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.Equals(System.Object,System.Object)">
            <summary>
		When implemented by a class, compare two instances of the class mapped by this 
		IType for persistence "equality" - ie. Equality of persistent state.
		</summary><param name="x">The left hand side object.</param><param name="y">The right hand side object.</param><returns>True if the two objects contain the same values.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.IsDatabaseNull(System.Object)">
            <summary>
            Determines whether the specified value is represented as <see langword="null" /> in the database.
            </summary>
            <param name="value">The value, may be <see langword="null" />.</param>
            <returns>
            <see langword="true" /> if the specified value is <see langword="null" />; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.NullSafeGet(IDataReader, string[], ISessionImplementor, object)&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.NullSafeGet(IDataReader, string, ISessionImplementor, object)&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param><param name="value">The object that contains the values.</param><param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param><param name="session"></param><param name="settable">Indicates which columns are to be set.</param><remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">
			The <see cref="T:System.Data.IDbCommand"/> to put the values into.
		</param><param name="value">The object that contains the values.</param><param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.
		</param><param name="session"></param><remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.FromString(System.String)">
            <summary>
		Parse the XML representation of an instance
		</summary><param name="xml"></param><returns>an instance of the type</returns> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsAssociationType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is an <see cref="T:NHibernate.Type.IAssociationType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not an <see cref="T:NHibernate.Type.IAssociationType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsCollectionType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is a <see cref="T:NHibernate.Type.CollectionType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a <see cref="T:NHibernate.Type.CollectionType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsComponentType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsEntityType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is a <see cref="T:NHibernate.Type.EntityType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a <see cref="T:NHibernate.Type.EntityType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsAnyType">
             <summary>
            Gets a value indicating if the implementation is an "object" type
             </summary>
             <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a "object" type.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsMutable">
            <summary>
		When implemented by a class, gets the value indicating if the objects 
		of this IType are mutable.
		</summary><value>true if the objects mapped by this IType are mutable.</value><remarks>
		With respect to the referencing object...
		Entities and Collections are considered immutable because they manage their own internal state.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.Name">
            <summary>
		When implemented by a class, gets the abbreviated name of the type.
		</summary><value>The NHibernate type name.</value> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.HasNiceEquals">
            <summary>
		When implemented by a class, gets whether or not this IType contains 
		<see cref="T:System.Type"/>s that implement well-behaived <c>Equals()</c> method.
		</summary><value>true if a well-behaived <c>Equals()</c> is implemented.</value><remarks>
		<para>
		Strickly, if this method returns <c>true</c> then <c>x.Equals(y)</c> implies
		<c>IType.Equals(x, y)</c> and also <c>IType.Equals(x, y)</c> implies that
		probably <c>x.Equals(y)</c>
		</para>
		<para>
		In the default implementations <see cref="T:NHibernate.Type.ImmutableType"/>s are assumed to have
		HaveNiceEquals==true and <see cref="T:NHibernate.Type.MutableType"/>s are assumed to have 
		HaveNiceEquals==false.
		</para>
		<para>
		This code doesn't look like it is used anywhere internally because I did a search
		on ".HasNiceEquals" and found no results.  So it looks like it is used for a description
		of the IType only.
		</para>
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.ReturnedClass">
            <summary>
		When implemented by a class, gets the <see cref="T:System.Type"/> returned 
		by the <c>NullSafeGet()</c> methods.
		</summary><value>
		The <see cref="T:System.Type"/> from the .NET framework.
		</value><remarks>
		This is used to establish the class of an array of this Itype
		</remarks> 
        </member>
        <member name="T:NHibernate.Type.AnsiCharType">
            <summary>
            Maps a <see cref="T:System.Char"/> Property 
            to a <c>DbType.AnsiStringFixedLength</c> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.BaseCharType">
            <summary>
            Common base class for <see cref="T:NHibernate.Type.CharType"/> and <see cref="T:NHibernate.Type.AnsiCharType"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Type.ValueTypeType">
            <summary>
            Superclass of <see cref="T:System.ValueType"/> types.
            </summary>
        </member>
        <member name="T:NHibernate.Type.ImmutableType">
            <summary>
            Superclass of nullable immutable types.
            </summary>
        </member>
        <member name="T:NHibernate.Type.NullableType">
            <summary>
            Superclass of single-column nullable types.
            </summary>
            <remarks>
            Maps the Property to a single column that is capable of storing nulls in it. If a .net Struct is
            used it will be created with its unitialized value and then on Update the uninitialized value of
            the Struct will be written to the column - not <see langword="null" />. 
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the NullableType class using a 
            <see cref="P:NHibernate.Type.NullableType.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/>.</param>
            <remarks>This is used when the Property is mapped to a single column.</remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            When implemented by a class, put the value from the mapped 
            Property into to the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the value into.</param>
            <param name="value">The object that contains the value.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param>
            <remarks>
            Implementors do not need to handle possibility of null values because this will
            only be called from <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/> after 
            it has checked for nulls.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            When implemented by a class, gets the object in the 
            <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="index">The index of the field to get the value from.</param>
            <returns>An object with the value from the database.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.String)">
            <summary>
            When implemented by a class, gets the object in the 
            <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>An object with the value from the database.</returns>
            <remarks>
            Most implementors just call the <see cref="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)"/> 
            overload of this method.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="val">The object that contains the values.
            </param>
            <returns>An Xml formatted string.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
            <remarks>
            <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.ToString(System.Object)"/> if the parameter 
            value is not null.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.ToString(System.Object)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.FromStringValue(System.String)">
            <summary>
            Parse the XML representation of an instance
            </summary>
            <param name="xml">XML string to parse, guaranteed to be non-empty</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.FromString(System.String)">
            <summary>
		Parse the XML representation of an instance
		</summary><param name="xml"></param><returns>an instance of the type</returns> 
            <remarks>
            <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.FromStringValue(System.String)"/> if the parameter
            value is not empty.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.FromStringValue(System.String)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">
			The <see cref="T:System.Data.IDbCommand"/> to put the values into.
		</param><param name="value">The object that contains the values.</param><param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.
		</param><param name="session"></param><remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
            <remarks>
            <para>
            This implemenation forwards the call to <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Puts the value from the mapped class into the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param>
            <param name="value">The object that contains the values.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to write the value to.</param>
            <remarks>
            <para>
            This method checks to see if value is null, if it is then the value of 
            <see cref="T:System.DBNull"/> is written to the <see cref="T:System.Data.IDbCommand"/>.
            </para>
            <para>
            If the value is not null, then the method <see cref="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)"/> 
            is called and that method is responsible for setting the value.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object mapped by 
		this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementors should handle possibility of null values.
		</remarks> 
            <remarks>
            This has been sealed because no other class should override it.  This 
            method calls <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/> for a single value.  
            It only takes the first name from the string[] names parameter - that is a 
            safe thing to do because a Nullable Type only has one field.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String[])">
            <summary>
            Extracts the values of the fields from the DataReader
            </summary>
            <param name="rs">The DataReader positioned on the correct record</param>
            <param name="names">An array of field names.</param>
            <returns>The value off the field from the DataReader</returns>
            <remarks>
            In this class this just ends up passing the first name to the NullSafeGet method
            that takes a string, not a string[].
            
            I don't know why this method is in here - it doesn't look like anybody that inherits
            from NullableType overrides this...
            
            TODO: determine if this is needed
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)">
            <summary>
            Gets the value of the field from the <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> positioned on the correct record.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para>
            This method checks to see if value is null, if it is then the null is returned
            from this method.
            </para>
            <para>
            If the value is not null, then the method <see cref="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)"/> 
            is called and that method is responsible for retreiving the value.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object 
		mapped by this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="name">The name of the column in the <see cref="T:System.Data.IDataReader"/> that contains the 
		value to populate the IType with.</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementations should handle possibility of null values.
		This method might be called if the IType is known to be a single-column type.
		</remarks> 
            <remarks>
            <para>
            This implemenation forwards the call to <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="P:NHibernate.Type.NullableType.SqlType"/>s.</returns> 
            <remarks>
            <para>
            This implemenation forwards the call to <see cref="P:NHibernate.Type.NullableType.SqlType"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method because they map to a single
            column.  All of their implementation should be in <see cref="P:NHibernate.Type.NullableType.SqlType"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            Returns the number of columns spanned by this <see cref="T:NHibernate.Type.NullableType"/>
            </summary>
            <returns>A <see cref="T:NHibernate.Type.NullableType"/> always returns 1.</returns>
            <remarks>
            This has the hard coding of 1 in there because, by definition of this class, 
            a NullableType can only map to one column in a table.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.DeepCopyNotNull(System.Object)">
            <summary>
            When implemented by a class, returns a deep copy of the persistent state.
            </summary>
            <param name="val">The value to deep copy.</param>
            <returns>A deep copy of the object.</returns>
            <remarks>
            Most of the built in NullableTypes will just return the same object
            passed into it.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.DeepCopy(System.Object)">
            <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary><param name="val">A Collection element or Entity field</param><returns>A deep copy of the object.</returns> 
            <remarks>
            <para>
            This implemenation forwards the call to <see cref="M:NHibernate.Type.NullableType.DeepCopyNotNull(System.Object)"/> if the parameter 
            value is not null.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.DeepCopyNotNull(System.Object)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this
            <see cref="T:NHibernate.Type.NullableType"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this NullableType.</param>
            <returns>true if the SqlType and Name properties are the same.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:NHibernate.Type.NullableType"/>, 
            suitable for use in hashing algorithms and data structures like a hash table.
            </summary>
            <returns>
            A hash code that is based on the <see cref="P:NHibernate.Type.NullableType.SqlType"/>'s 
            hash code and the <see cref="P:NHibernate.Type.AbstractType.Name"/>'s hash code.</returns>
        </member>
        <member name="P:NHibernate.Type.NullableType.SqlType">
            <summary>
            Gets the underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/> for 
            the column mapped by this <see cref="T:NHibernate.Type.NullableType"/>.
            </summary>
            <value>The underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/>.</value>
            <remarks>
            This implementation should be suitable for all subclasses unless they need to
            do some special things to get the value.  There are no built in <see cref="T:NHibernate.Type.NullableType"/>s
            that override this Property.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ImmutableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the ImmutableType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="M:NHibernate.Type.ImmutableType.DeepCopyNotNull(System.Object)">
            <summary>
            Returns a deep copy of the persistent state.
            </summary>
            <param name="val">The value to deep copy.</param>
            <returns>A deep copy of the object.</returns>
            <remarks>
            A <see cref="T:System.ValueType"/> is considered immutable because a boxed version
            of the <see cref="T:System.ValueType"/> is being stored by NHibernate.  So any changes
            made to it would require the <see cref="T:System.ValueType"/> to be unboxed and
            then reboxed.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.ImmutableType.IsMutable">
            <summary>
            Gets the value indicating if this IType is mutable.
            </summary>
            <value>false - an <see cref="T:NHibernate.Type.ImmutableType"/> is not mutable.</value>
            <remarks>
            This has been "sealed" because any subclasses are expected to be immutable.  If
            the type is mutable then they should inherit from <see cref="T:NHibernate.Type.MutableType"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.ImmutableType.HasNiceEquals">
            <summary>
            Gets whether or not this IType contains 
            <see cref="T:System.Type"/>s that implement well-behaived <c>Equals()</c> method.
            </summary>
            <value>
            true - it is assumed that a ImmutableType implements a 
            well-behaived <c>Equals()</c>.
            </value>
            <remarks>
            There is no concrete rule that <see cref="T:NHibernate.Type.ImmutableType"/>s implement
            a well-behaived <c>Equals()</c>.  If the <see cref="T:NHibernate.Type.ImmutableType"/> does 
            not implement the <c>Equals()</c> then set this to <see langword="false"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.ILiteralType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may appear as an SQL literal
            </summary>
        </member>
        <member name="M:NHibernate.Type.ILiteralType.ObjectToSQLString(System.Object)">
            <summary>
            When implemented by a class, return a <see cref="T:System.String"/> representation 
            of the value, suitable for embedding in an SQL statement
            </summary>
            <param name="value">The object to convert to a string for the SQL statement.</param>
            <returns>A string that containts a well formed SQL Statement.</returns>
        </member>
        <member name="M:NHibernate.Type.ValueTypeType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the ValueTypeType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="M:NHibernate.Type.ValueTypeType.Equals(System.Object,System.Object)">
            <summary>
            Compare two instances of the class mapped by this 
            IType for persistence "equality" - ie. Equality of persistent state.
            </summary>
            <param name="x">The left hand side object.</param>
            <param name="y">The right hand side object.</param>
            <returns>True if the two objects contain the same values.</returns>
        </member>
        <member name="M:NHibernate.Type.ValueTypeType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="val">The object that contains the values.
            </param>
            <returns>An Xml formatted string.</returns>
            <remarks>
            This just calls <see cref="M:System.Object.ToString"/> so if there is 
            a possibility of this PrimitiveType having any characters
            that need to be encoded then this method should be overridden.
            
            TODO: figure out if this is used to build Xml strings or will have encoding
            done automattically.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ValueTypeType.ObjectToSQLString(System.Object)">
            <summary>
            When implemented by a class, return a <see cref="T:System.String"/> representation 
            of the value, suitable for embedding in an SQL statement
            </summary>
            <param name="val">The object to convert to a string for the SQL statement.</param>
            <returns>A string that containts a well formed SQL Statement.</returns>
        </member>
        <member name="T:NHibernate.Type.IDiscriminatorType">
            <summary>
            An IType that may be used for a discriminator column.
            </summary>
            <remarks>
            This interface contains no new methods but does require that an
            <see cref="T:NHibernate.Type.IType"/> that will be used in a discriminator column must implement
            both the <see cref="T:NHibernate.Type.IIdentifierType"/> and <see cref="T:NHibernate.Type.ILiteralType"/> interfaces.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.IIdentifierType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may be used as an identifier.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IIdentifierType.StringToObject(System.String)">
            <summary>
            When implemented by a class, converts the xml string from the 
            mapping file to the .NET object.
            </summary>
            <param name="xml">The value of <c>discriminator-value</c> or <c>unsaved-value</c> attribute.</param>
            <returns>The string converted to the object.</returns>
            <remarks>
            This method needs to be able to handle any string.  It should not just 
            call System.Type.Parse without verifying that it is a parsable value
            for the System.Type.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.AnsiStringType">
            <summary>
            Maps a <see cref="T:System.String"/> Property 
            to a <see cref="F:System.Data.DbType.AnsiString"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.#ctor(NHibernate.SqlTypes.AnsiStringSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.AnsiStringType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.AnsiStringType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.AnyType">
            <summary>
            	Handles "any" mappings and the old deprecated "object" type.
            </summary>
            <remarks>
            	The identifierType is any NHibernate IType that can be serailized by default.
            	For example, you can specify the identifierType as an Int32 or a custom identifier
            	type that you built.  The identifierType matches to one or many columns.
            	
            	The metaType maps to a single column.  By default it stores the name of the Type
            	that the Identifier identifies.  
            	
            	For example, we can store a link to any table.  It will have the results
            	class_name					id_col1
            	========================================
            	Simple, AssemblyName			5
            	DiffClass, AssemblyName			5
            	Simple, AssemblyName			4
            	
            	You can also provide you own type that might map the name of the class to a table
            	with a giant switch statemet or a good naming convention for your class->table.  The
            	data stored might look like
            	class_name					id_col1
            	========================================
            	simple_table					5
            	diff_table						5
            	simple_table					4
            	
            </remarks>
        </member>
        <member name="T:NHibernate.Type.IAbstractComponentType">
            <summary>
            Enables other Component-like types to hold collections and have cascades, etc.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the values of the component properties of 
            a component instance
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValues(System.Object)">
            <summary>
            Optional Operation
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Optional operation
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAbstractComponentType.Subtypes">
            <summary>Get the types of the component properties</summary>
        </member>
        <member name="P:NHibernate.Type.IAbstractComponentType.PropertyNames">
            <summary>Get the names of the component properties</summary>
        </member>
        <member name="P:NHibernate.Type.IAbstractComponentType.PropertyNullability">
            <summary>
            Optional operation
            </summary>
            <value>nullability of component properties</value>
        </member>
        <member name="T:NHibernate.Type.IAssociationType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that represents some kind of association between entities.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetAssociatedJoinable(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Get the "persister" for this association - a class or collection persister
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetAssociatedClass(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetOnCondition(System.String,NHibernate.Engine.ISessionFactoryImplementor,System.Collections.IDictionary)">
            <summary>
            Get the "filtering" SQL fragment that is applied in the
            SQL on clause, in addition to the usual join condition.
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.ForeignKeyDirection">
            <summary>
            When implemented by a class, gets the type of foreign key directionality 
            of this association.
            </summary>
            <value>The <see cref="P:NHibernate.Type.IAssociationType.ForeignKeyDirection"/> of this association.</value>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.UseLHSPrimaryKey">
            <summary>
            Is the primary key of the owning entity table
            to be used in the join?
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.LHSPropertyName">
            <summary>
            Get the name of the property in the owning entity
            that provides the join key (null if the identifier)
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.RHSUniqueKeyPropertyName">
            <summary>
            The name of a unique property of the associated entity 
            that provides the join key (null if the identifier of
            an entity, or key of a collection)
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.IsAlwaysDirtyChecked">
            <summary>
            Do we dirty check this association, even when there are
            no columns to be updated.
            </summary>
        </member>
        <member name="M:NHibernate.Type.AnyType.#ctor(NHibernate.Type.IType,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="metaType"></param>
            <param name="identifierType"></param>
        </member>
        <member name="M:NHibernate.Type.AnyType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.AnyType.DeepCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnyType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnyType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.AnyType.UseLHSPrimaryKey">
            <summary>
            Not really relevant to AnyType, since it cannot be "joined"
            </summary>
        </member>
        <member name="T:NHibernate.Type.ArrayType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Array"/> collection
            to the database.
            </summary>
        </member>
        <member name="T:NHibernate.Type.CollectionType">
            <summary>
            The base class for an <see cref="T:NHibernate.Type.IType"/> that maps collections
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.CollectionType.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.CollectionType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="foreignKeyPropertyName">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.CollectionType.GetElementsCollection(System.Object)">
            <summary>
            Returns a reference to the elements in the collection.  
            </summary>
            <param name="collection">The object that holds the ICollection.</param>
            <returns>An ICollection of the Elements(classes) in the Collection.</returns>
            <remarks>
            By default the parameter <c>collection</c> is just cast to an ICollection.  Collections
            such as Maps and Sets should override this so that the Elements are returned - not a
            DictionaryEntry.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.CollectionType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps a collection from System.Collections or Iesi.Collections inside one of the 
            NHibernate collections.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped collection.</param>
            <returns>
            A subclass of <see cref="T:NHibernate.Collection.IPersistentCollection"/> that wraps the non NHibernate collection.
            </returns>
        </member>
        <member name="M:NHibernate.Type.CollectionType.GetKeyOfOwner(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the key value from the owning entity instance, usually the identifier, but might be some
            other unique key, in the case of property-ref
            </summary>
        </member>
        <member name="M:NHibernate.Type.CollectionType.Instantiate">
            <summary>
            Instantiate an empty instance of the "underlying" collection (not a wrapper)
            </summary>
        </member>
        <member name="P:NHibernate.Type.CollectionType.IsAlwaysDirtyChecked">
            <summary>
            We always need to dirty check the collection because we sometimes 
            need to incremement version number of owner and also because of 
            how assemble/disassemble is implemented for uks
            </summary>
        </member>
        <member name="M:NHibernate.Type.ArrayType.#ctor(System.String,System.String,System.Type)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.ArrayType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="elementClass">The <see cref="T:System.Type"/> of the element contained in the array.</param>
            <remarks>
            This creates a bag that is non-generic.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ArrayType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ArrayType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.ArrayType.GetElementsCollection(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ArrayType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ArrayType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps a <see cref="T:System.Array"/> in a <see cref="T:NHibernate.Collection.PersistentArrayHolder"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="array">The unwrapped array.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.PersistentArrayHolder"/> that wraps the non NHibernate <see cref="T:System.Array"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.ArrayType.ReturnedClass">
            <summary>
            The <see cref="T:System.Array"/> for the element.
            </summary>
        </member>
        <member name="P:NHibernate.Type.ArrayType.IsArrayType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BagType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.IList"/> collection
            using bag semantics to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.BagType.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.BagType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.BagType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the bag.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the bag.</param>
            <param name="persister"></param>
            <returns>A new <see cref="T:NHibernate.Collection.PersistentBag"/>.</returns>
        </member>
        <member name="M:NHibernate.Type.BagType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.IList"/> in a NHibernate <see cref="T:NHibernate.Collection.PersistentBag"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.IList"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.PersistentBag"/> that wraps the non NHibernate <see cref="T:System.Collections.IList"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.BagType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BinaryBlobType">
            <summary>
            Maps a System.Byte[] Property to an column that can store a BLOB.
            </summary>
            <remarks>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a BinaryType
            would work just fine.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.BinaryType">
            <summary>
            BinaryType.
            </summary>
        </member>
        <member name="T:NHibernate.Type.MutableType">
            <summary>
            Superclass for mutable nullable types.
            </summary>
        </member>
        <member name="M:NHibernate.Type.MutableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the MutableType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="P:NHibernate.Type.MutableType.IsMutable">
            <summary>
            Gets the value indicating if this IType is mutable.
            </summary>
            <value>true - a <see cref="T:NHibernate.Type.MutableType"/> is mutable.</value>
            <remarks>
            This has been "sealed" because any subclasses are expected to be mutable.  If
            the type is immutable then they should inherit from <see cref="T:NHibernate.Type.ImmutableType"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.MutableType.HasNiceEquals">
            <summary>
            Gets whether or not this IType contains 
            <see cref="T:System.Type"/>s that implement well-behaived <c>Equals()</c> method.
            </summary>
            <value>
            false - it is assumed that a MutableType does not implement a 
            well-behaved <c>Equals()</c>.
            </value>
            <remarks>
            There is no concrete rule that <see cref="T:NHibernate.Type.MutableType"/>s don't implement
            a well-behaved <c>Equals()</c>.  If the <see cref="T:NHibernate.Type.MutableType"/> does implement
            the <c>Equals()</c> then set this to <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.BinaryType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.BinaryType.#ctor(NHibernate.SqlTypes.BinarySqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.BinaryType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.BinaryType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BinaryType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BinaryType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BinaryType.DeepCopyNotNull(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BinaryType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.BinaryType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.BinaryBlobType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.BinaryBlobType.#ctor(NHibernate.SqlTypes.BinarySqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="P:NHibernate.Type.BinaryBlobType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BooleanType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> Property 
            to a <see cref="F:System.Data.DbType.Boolean"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.BooleanType.#ctor">
            <summary>
            Initialize a new instance of the BooleanType
            </summary>
            <remarks>This is used when the Property is mapped to a native boolean type.</remarks>
        </member>
        <member name="M:NHibernate.Type.BooleanType.#ctor(NHibernate.SqlTypes.AnsiStringFixedLengthSqlType)">
            <summary>
            Initialize a new instance of the BooleanType class using a
            <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/>.
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
            <remarks>
            This is used when the Property is mapped to a string column
            that stores true or false as a string.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.ByteType">
            <summary>
            Maps a <see cref="T:System.Byte"/> property 
            to a <see cref="F:System.Data.DbType.Byte"/> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.IVersionType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may be used to version data.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IVersionType.Next(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            When implemented by a class, increments the version.
            </summary>
            <param name="current">The current version</param>
            <param name="session">The current session, if available.</param>
            <returns>an instance of the <see cref="T:NHibernate.Type.IType"/> that has been incremented.</returns>
        </member>
        <member name="M:NHibernate.Type.IVersionType.Seed(NHibernate.Engine.ISessionImplementor)">
            <summary>
            When implemented by a class, gets an initial version.
            </summary>
            <param name="session">The current session, if available.</param>
            <value>Returns an instance of the <see cref="T:NHibernate.Type.IType"/></value>
        </member>
        <member name="M:NHibernate.Type.IVersionType.StringToObject(System.String)">
            <summary>
            When implemented by a class, converts the xml string from the 
            mapping file to the .NET object.
            </summary>
            <param name="xml">The value of <c>discriminator-value</c> or <c>unsaved-value</c> attribute.</param>
            <returns>The string converted to the object.</returns>
            <remarks>
            This method needs to be able to handle any string.  It should not just 
            call System.Type.Parse without verifying that it is a parsable value
            for the System.Type.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.IVersionType.Comparator">
            <summary>
            Get a comparator for the version numbers
            </summary>
        </member>
        <member name="T:NHibernate.Type.CharBooleanType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> Property 
            to a <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.#ctor(NHibernate.SqlTypes.AnsiStringFixedLengthSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CharBooleanType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CharBooleanType.FalseString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CharType">
            <summary>
            Maps a <see cref="T:System.Char"/> Property 
            to a <c>DbType.StringFixedLength</c> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="begin"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.ComponentType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetPropertyValue(System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="i"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetPropertyValues(System.Object)">
            <remarks>
            Use the access optimizer if available
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ComponentType.SetPropertyValues(System.Object,System.Object[])">
            <remarks>
            Use the access optimizer if available
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ComponentType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.FromString(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.DeepCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Instantiate">
            <remarks>
            This method does not populate the component parent
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetCascadeStyle(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetFetchMode(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="names"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsCollectionType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsComponentType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsEntityType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.Subtypes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.PropertyNames">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsMutable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CompositeCustomType">
            <summary>
            Summary description for CompositeCustomType.
            </summary>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.GetPropertyValue(System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="i"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.GetCascadeStyle(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.GetFetchMode(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="cached"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.DeepCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="names"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.FromString(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.Subtypes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.PropertyNames">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.IsComponentType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.IsMutable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CultureInfoType">
            <summary>
            Maps a <see cref="T:System.Globalization.CultureInfo"/> Property 
            to a <see cref="F:System.Data.DbType.String"/> column.
            </summary>
            <remarks>
            CultureInfoType stores the culture name (not the Culture ID) of the 
            <see cref="T:System.Globalization.CultureInfo"/> in the DB.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CultureInfoType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CultureInfoType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CustomCollectionType">
            <summary>
            A custom type for mapping user-written classes that implement
            <see cref="T:NHibernate.Collection.IPersistentCollection"/>.
            </summary>
            <seealso cref="T:NHibernate.Collection.IPersistentCollection"/>
            <seealso cref="T:NHibernate.UserTypes.IUserCollectionType"/>
        </member>
        <member name="T:NHibernate.Type.CustomType">
            <summary>
            Adapts IUserType to the generic IType interface.
            <seealso cref="T:NHibernate.UserTypes.IUserType"/>
            </summary>
        </member>
        <member name="M:NHibernate.Type.CustomType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="names"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="settable"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.CustomType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.CustomType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.FromString(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.DeepCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CustomType.UserType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.IsMutable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DateTimeType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to a <see cref="F:System.Data.DbType.DateTime"/> column that 
            stores date &amp; time down to the accuracy of a second.
            </summary>
            <remarks>
            This only stores down to a second, so if you are looking for the most accurate
            date and time storage your provider can give you use the <see cref="T:NHibernate.Type.TimestampType"/>. 
            or the <see cref="T:NHibernate.Type.TicksType"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.DateTimeType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateTimeType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateTimeType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DateType">
            <summary>
            Maps the Year, Month, and Day of a <see cref="T:System.DateTime"/> Property to a 
            <see cref="F:System.Data.DbType.Date"/> column
            </summary>
        </member>
        <member name="M:NHibernate.Type.DateType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.DateType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.DateType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.DateType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DecimalType">
            <summary>
            Maps a <see cref="T:System.Decimal"/> Property 
            to a <see cref="F:System.Data.DbType.Decimal"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.DecimalType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DecimalType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DecimalType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.DecimalType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DecimalType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DecimalType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.DecimalType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DecimalType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DoubleType">
            <summary>
            Maps a <see cref="T:System.Double"/> Property 
            to a <see cref="F:System.Data.DbType.Double"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.DoubleType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.DoubleType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.DoubleType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DoubleType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DynamicComponentType">
            <summary>
            Handles "dynamic" components, represented as <c>&lt;map&gt;</c>s
            </summary>
        </member>
        <member name="T:NHibernate.Type.EntityType">
            <summary>
            A reference to an entity class
            </summary>
        </member>
        <member name="M:NHibernate.Type.EntityType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Converts the id contained in the <see cref="T:System.Data.IDataReader"/> to an object.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the query results.</param>
            <param name="names">A string array of column names that contain the id.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this is occurring in.</param>
            <param name="owner">The object that this Entity will be a part of.</param>
            <returns>
            An instance of the object or <see langword="null"/> if the identifer was null.
            </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Resolves the identifier to the actual object.
            </summary>
        </member>
        <member name="M:NHibernate.Type.EntityType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Resolve an identifier or unique key value
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.EntityType.IsMutable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.EntityType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.EntityType.IsAssociationType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.EntityType.ForeignKeyDirection">
            <summary>
            When implemented by a class, gets the type of foreign key directionality 
            of this association.
            </summary>
            <value>The <see cref="P:NHibernate.Type.EntityType.ForeignKeyDirection"/> of this association.</value>
        </member>
        <member name="P:NHibernate.Type.EntityType.UseLHSPrimaryKey">
            <summary>
            Is the foreign key the primary key of the table?
            </summary>
        </member>
        <member name="T:NHibernate.Type.EnumStringType">
            <summary>
            Maps a <see cref="T:System.Enum"/> to a 
            <see cref="F:System.Data.DbType.String">DbType.String</see>.
            </summary>
            <remarks>
            If your database should store the <see cref="T:System.Enum"/>
            using the named values in the enum instead of the underlying values
            then subclass this <see cref="T:NHibernate.Type.IType"/>.
            
            <para>
            All that needs to be done is to provide a default constructor that
            NHibernate can use to create the specific type.  For example, if 
            you had an enum defined as.
            </para>
            
            <code>
            public enum MyEnum 
            {
            	On,
            	Off,
            	Dimmed
            }
            </code>
            
            <para>
            all that needs to be written for your enum string type is:
            </para>
            
            <code>
            public class MyEnumStringType : NHibernate.Type.EnumStringType
            {
            	public MyEnumStringType()
            		: base( typeof( MyEnum ) )
            	{
            	}
            }
            </code>
            
            <para>
            The mapping would look like:
            </para>
            
            <code>
            ...
            	&lt;property name="Status" type="MyEnumStringType, AssemblyContaining" /&gt;
            ...
            </code>
            
            <para>
            The TestFixture that shows the working code can be seen
            in <c>NHibernate.Test.TypesTest.EnumStringTypeFixture.cs</c>
            , <c>NHibernate.Test.TypesTest.EnumStringClass.cs</c>
            , and <c>NHibernate.Test.TypesTest.EnumStringClass.hbm.xml</c>
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.Type.EnumStringType.MaxLengthForEnumString">
            <summary>
            Hardcoding of <c>255</c> for the maximum length
            of the Enum name that will be saved to the db.
            </summary>
            <value>
            <c>255</c> because that matches the default length that hbm2ddl will
            use to create the column.
            </value>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.#ctor(System.Type)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Type.EnumStringType"/>.
            </summary>
            <param name="enumClass">The <see cref="T:System.Type"/> of the Enum.</param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.#ctor(System.Type,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Type.EnumStringType"/>.
            </summary>
            <param name="enumClass">The <see cref="T:System.Type"/> of the Enum.</param>
            <param name="length">The length of the string that can be written to the column.</param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.GetInstance(System.Object)">
            <summary>
            
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.GetValue(System.Object)">
            <summary>
            
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="cached"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.EnumStringType.ReturnedClass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Type.EnumStringType.Name">
            <summary>
            
            </summary>
            <remarks>
            This appends <c>enumstring - </c> to the beginning of the underlying
            enums name so that <see cref="T:System.Enum"/> could still be stored
            using the underlying value through the <see cref="T:NHibernate.Type.PersistentEnumType"/>
            also.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.ForeignKeyDirection">
            <summary>
            Represents directionality of the foreign key constraint
            </summary>
        </member>
        <member name="M:NHibernate.Type.ForeignKeyDirection.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.ForeignKeyDirection.CascadeNow(NHibernate.Engine.CascadePoint)">
            <summary>
            Should we cascade at this cascade point?
            </summary>
        </member>
        <member name="F:NHibernate.Type.ForeignKeyDirection.ForeignKeyToParent">
            <summary>
            A foreign key from child to parent
            </summary>
        </member>
        <member name="F:NHibernate.Type.ForeignKeyDirection.ForeignKeyFromParent">
            <summary>
            A foreign key from parent to child
            </summary>
        </member>
        <member name="T:NHibernate.Type.GenericBagType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.Generic.IList`1"/> collection
            to the database using bag semantics.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericBagType`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericBagType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericBagType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the bag.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the bag.</param>
            <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for the bag.</param>
        </member>
        <member name="M:NHibernate.Type.GenericBagType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.IdentifierBagType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.IList"/> collection
            using bag semantics with an identifier to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IdentifierBagType.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.IdentifierBagType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.IdentifierBagType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the identifier bag.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the identifier bag.</param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IdentifierBagType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.IList"/> in a <see cref="T:NHibernate.Collection.PersistentIdentifierBag"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.IList"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.PersistentIdentifierBag"/> that wraps the non NHibernate <see cref="T:System.Collections.IList"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.IdentifierBagType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.GenericListType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.Generic.IList`1"/> collection
            to the database using list semantics.
            </summary>
        </member>
        <member name="T:NHibernate.Type.ListType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.IList"/> collection
            using list semantics to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.ListType.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.ListType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.ListType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the bag.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the bag.</param>
            <param name="persister"></param>
            <returns>A new <see cref="T:NHibernate.Collection.PersistentList"/>.</returns>
        </member>
        <member name="M:NHibernate.Type.ListType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an exist <see cref="T:System.Collections.IList"/> in a NHibernate <see cref="T:NHibernate.Collection.PersistentList"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.IList"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.PersistentList"/> that wraps the non NHibernate <see cref="T:System.Collections.IList"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.ListType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.GenericListType`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericListType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericListType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the list.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the list.</param>
            <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for the list.</param>
        </member>
        <member name="M:NHibernate.Type.GenericListType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1"/> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.GenericMapType`2">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.Generic.IDictionary`2"/> collection
            to the database.
            </summary>
        </member>
        <member name="T:NHibernate.Type.MapType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.IDictionary"/> collection
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.MapType.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.MapType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.MapType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the map.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the map.</param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.MapType.GetElementsCollection(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.MapType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.IDictionary"/> in a <see cref="T:NHibernate.Collection.PersistentMap"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.IDictionary"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.PersistentMap"/> that wraps the non NHibernate <see cref="T:System.Collections.IDictionary"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.MapType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.GenericMapType`2.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericMapType`2"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericMapType`2.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the map.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the map.</param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GenericMapType`2.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IDictionary`2"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericMap`2"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericMap`2"/> that wraps the 
            non NHibernate <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.GenericSetType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:Iesi.Collections.Generic.ISet`1"/> collection
            to the database.
            </summary>
        </member>
        <member name="T:NHibernate.Type.SetType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:Iesi.Collections.ISet"/> collection
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SetType.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.SetType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.SetType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the set.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the set.</param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SetType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:Iesi.Collections.ISet"/> in a <see cref="T:NHibernate.Collection.PersistentSet"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:Iesi.Collections.ISet"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.PersistentSet"/> that wraps the non NHibernate <see cref="T:Iesi.Collections.ISet"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Type.SetType.GetElementsCollection(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SetType.ReturnedClass">
            <summary>
            <see cref="P:NHibernate.Type.AbstractType.ReturnedClass"/>
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericSetType`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericSetType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericSetType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the set.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the set.</param>
            <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for the set.</param>
        </member>
        <member name="M:NHibernate.Type.GenericSetType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericSet`1"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericSet`1"/> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.GenericSortedSetType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps a sorted <see cref="T:Iesi.Collections.Generic.ISet`1"/> collection
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericSortedSetType`1.#ctor(System.String,System.String,System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericSortedSetType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use to compare
            set elements.</param>
        </member>
        <member name="T:NHibernate.Type.GuidType">
            <summary>
            Maps a <see cref="T:System.Guid"/> Property 
            to a <see cref="F:System.Data.DbType.Guid"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GuidType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.GuidType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GuidType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GuidType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.GuidType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GuidType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.GuidType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.GuidType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int16Type">
            <summary>
            Maps a <see cref="T:System.Int16"/> Property 
            to a <see cref="F:System.Data.DbType.Int16"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int16Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.Int16Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.Int16Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.Int16Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int16Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int32Type">
            <summary>
            Maps a <see cref="T:System.Int32"/> Property 
            to a <see cref="F:System.Data.DbType.Int32"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int32Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.Int32Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int32Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int32Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.Int32Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int32Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.Int32Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int32Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int64Type">
            <summary>
            Maps a <see cref="T:System.Int64"/> Property 
            to a <see cref="F:System.Data.DbType.Int64"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int64Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.Int64Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int64Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int64Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.Int64Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int64Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.Int64Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int64Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.ManyToOneType">
            <summary>
            A many-to-one association to an entity
            </summary>
        </member>
        <member name="M:NHibernate.Type.ManyToOneType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Hydrates the Identifier from <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the query results.</param>
            <param name="names">A string array of column names to read from.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this is occuring in.</param>
            <param name="owner">The object that this Entity will be a part of.</param>
            <returns>
            An instantiated object that used as the identifier of the type.
            </returns>
        </member>
        <member name="T:NHibernate.Type.OneToOneType">
            <summary>
            A one-to-one association to an entity
            </summary>
        </member>
        <member name="P:NHibernate.Type.OneToOneType.IsAlwaysDirtyChecked">
            <summary>
            We don't need to dirty check one-to-one because of how 
            assemble/disassemble is implemented and because a one-to-one 
            association is never dirty
            </summary>
        </member>
        <member name="T:NHibernate.Type.OrderedMapType">
            <summary>
            A <see cref="T:NHibernate.Type.MapType"/> implemented using a collection that maintains
            the order in which elements are inserted into it.
            </summary>
        </member>
        <member name="M:NHibernate.Type.OrderedMapType.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.OrderedMapType"/> class.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef"></param>
        </member>
        <member name="T:NHibernate.Type.OrderedSetType">
            <summary>
            A <see cref="T:NHibernate.Type.SetType"/> implemented using a collection that maintains
            the order in which elements are inserted into it.
            </summary>
        </member>
        <member name="M:NHibernate.Type.OrderedSetType.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.OrderedSetType"/> class
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef"></param>
        </member>
        <member name="T:NHibernate.Type.PersistentEnumType">
            <summary>
            PersistentEnumType
            </summary>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="enumClass"></param>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.GetUnderlyingSqlType(System.Type)">
            <summary>
            Determines what the NHibernate SqlType should be based on the 
            values contain in the Enum
            </summary>
            <param name="enumClass">The Enumeration class to get the values from.</param>
            <returns>The SqlType for this EnumClass</returns>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.GetInstance(System.Object)">
            <summary>
            Gets an instance of the Enum
            </summary>
            <param name="code">The underlying value of an item in the Enum.</param>
            <returns>
            An instance of the Enum set to the <c>code</c> value.
            </returns>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.GetValue(System.Object)">
            <summary>
            Gets the correct value for the Enum.
            </summary>
            <param name="code">The value to convert.</param>
            <returns>A boxed version of the code converted to the correct type.</returns>
            <remarks>
            This handles situations where the DataProvider returns the value of the Enum
            from the db in the wrong underlying type.  It uses <see cref="T:System.Convert"/> to 
            convert it to the correct type.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.PersistentEnumType.Name">
            <summary></summary> 
        </member>
        <member name="T:NHibernate.Type.SByteType">
            <summary>
            Maps a <see cref="T:System.SByte"/> Property 
            to a <see cref="F:System.Data.DbType.SByte"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SByteType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.SByteType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SByteType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SByteType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.SByteType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SByteType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SByteType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SByteType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.SByteType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SerializableType">
            <summary>
            Maps an instance of a <see cref="T:System.Object"/> that has the <see cref="T:System.SerializableAttribute"/>
            to a <see cref="F:System.Data.DbType.Binary"/> column.  
            </summary>
            <remarks>
            <para>
            The SerializableType should be used when you know that Bytes are 
            not going to be greater than 8,000.
            </para>
            <para>
            The base class is <see cref="T:NHibernate.Type.MutableType"/> because the data is stored in 
            a byte[].  The System.Array does not have a nice "equals" method so we must
            do a custom implementation.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.SerializableType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.DeepCopyNotNull(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.FromBytes(System.Byte[])">
            <summary>
            
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="cached"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SerializableType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SerializationException">
            <summary>
            Thrown when a property cannot be serialized/deserialized
            </summary>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="e">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Type.SingleType">
            <summary>
            Maps a <see cref="T:System.Single"/> Property to an 
            <see cref="F:System.Data.DbType.Single"/> column.
            </summary>
            <remarks>
            Verify through your database's documentation if there is a column type that
            matches up with the capabilities of <see cref="T:System.Single"/>  
            </remarks>
        </member>
        <member name="M:NHibernate.Type.SingleType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.SingleType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SingleType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SingleType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.SingleType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SingleType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.SingleType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SortedMapType">
            <summary>
            Extends the <see cref="T:NHibernate.Type.MapType"/> to provide sorting.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SortedMapType.#ctor(System.String,System.String,System.Collections.IComparer)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.SortedMapType"/> class for
            a specific role using the <see cref="T:System.Collections.IComparer"/> to do the sorting.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> to use for the sorting.</param>
        </member>
        <member name="T:NHibernate.Type.SortedSetType">
            <summary>
            Extends the <see cref="T:NHibernate.Type.SetType"/> to provide sorting.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SortedSetType.#ctor(System.String,System.String,System.Collections.IComparer)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.SortedSetType"/> class for
            a specific role using the <see cref="T:System.Collections.IComparer"/> to do the sorting.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> to use for the sorting.</param>
        </member>
        <member name="T:NHibernate.Type.StringClobType">
            <summary>
            Maps a <see cref="T:System.String"/> Property to an 
            <see cref="T:System.String"/> column that can store a CLOB.
            </summary>
            <remarks>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a StringType
            would work just fine.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.StringType">
            <summary>
            Maps a <see cref="T:System.String"/> to a <see cref="F:System.Data.DbType.String"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.StringType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.StringType.#ctor(NHibernate.SqlTypes.StringSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.StringType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.StringType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.StringType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.StringType.Name">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.StringClobType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.StringClobType.#ctor(NHibernate.SqlTypes.StringSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="P:NHibernate.Type.StringClobType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TicksType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to an <see cref="F:System.Data.DbType.Int64"/> column 
            that stores the DateTime using the Ticks property.
            </summary>
            <remarks>
            This is the recommended way to "timestamp" a column.  The System.DateTime.Ticks 
            is accurate to 100-nanosecond intervals. 
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TicksType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TicksType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.TicksType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TicksType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TicksType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TicksType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TimeSpanType">
            <summary>
            Maps a <see cref="T:System.TimeSpan"/> Property to an <see cref="F:System.Data.DbType.Int64"/> column 
            </summary>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Seed(NHibernate.Engine.ISessionImplementor)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TimestampType">
            <summary>
            This is almost the exact same type as the DateTime except it can be used
            in the version column, stores it to the accuracy the database supports, 
            and will default to the value of DateTime.Now if the value is null.
            </summary>
            <remarks>
            <p>
            The value stored in the database depends on what your data provider is capable
            of storing.  So there is a possibility that the DateTime you save will not be
            the same DateTime you get back when you check DateTime.Equals(DateTime) because
            they will have their milliseconds off.
            </p>  
            <p>
            For example - SQL Server 2000 is only accurate to 3.33 milliseconds.  So if 
            NHibernate writes a value of <c>01/01/98 23:59:59.995</c> to the Prepared Command, MsSql
            will store it as <c>1998-01-01 23:59:59.997</c>.
            </p>
            <p>
            Please review the documentation of your Database server.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TimestampType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Sets the value of this Type in the IDbCommand.
            </summary>
            <param name="st">The IDbCommand to add the Type's value to.</param>
            <param name="value">The value of the Type.</param>
            <param name="index">The index of the IDataParameter in the IDbCommand.</param>
            <remarks>
            No null values will be written to the IDbCommand for this Type. 
            </remarks>
        </member>
        <member name="T:NHibernate.Type.TimeType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to an DateTime column that only stores the 
            Hours, Minutes, and Seconds of the DateTime as significant.
            </summary>
            <remarks>
            <para>
            This defaults the Date to "1753-01-01" - that should not matter because
            using this Type indicates that you don't care about the Date portion of the DateTime.
            </para>
            <para>
            A more appropriate choice to store the duration/time is the <see cref="T:NHibernate.Type.TimeSpanType"/>.
            The underlying <see cref="F:System.Data.DbType.Time"/> tends to be handled diffently by different
            DataProviders.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TimeType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TimeType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.TimeType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TimeType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TrueFalseType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> to a 1 char <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column 
            that stores a <code>'T'/'F'</code> to indicate <code>true/false</code>.
            </summary>
            <remarks>
            If you are using schema-export to generate your tables then you need
            to set the column attributes: <c>length=1</c> or <c>sql-type="char(1)"</c>.
            
            This needs to be done because in Java's JDBC there is a type for CHAR and 
            in ADO.NET there is not one specifically for char, so you need to tell schema
            export to create a char(1) column.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TrueFalseType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.FalseString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TypeFactory">
            <summary>
            Used internally to obtain instances of IType.
            </summary>
            <remarks>
            Applications should use static methods and constants on NHibernate.NHibernateUtil if the default
            IType is good enough.  For example, the TypeFactory should only be used when the String needs
            to have a length of 300 instead of 255.  At this point NHibernate.String does not get you the 
            correct IType.  Instead use TypeFactory.GetString(300) and keep a local variable that holds
            a reference to the IType.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetTypeClassification(System.String)">
            <summary>
            Gets the classification of the Type based on the string.
            </summary>
            <param name="typeName">The name of the Type to get the classification for.</param>
            <returns>The Type of Classification</returns>
            <remarks>
            This parses through the string and makes the assumption that no class
            name and no assembly name will contain the <c>"("</c>.  
            <para>
            If it finds 
            the <c>"("</c> and then finds a <c>","</c> afterwards then it is a 
            <c>TypeClassification.PrecisionScale</c>.  
            </para>
            <para>
            If it finds the <c>"("</c>
            and doesn't find a <c>","</c> afterwards, then it is a 
            <c>TypeClassification.Length</c>.
            </para>
            <para>
            If it doesn't find the <c>"("</c> then it assumes that it is a
            <c>TypeClassification.Plain</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Basic(System.String)">
            <summary>
            Given the name of a Hibernate type such as Decimal, Decimal(19,0)
            , Int32, or even NHibernate.Type.DecimalType, NHibernate.Type.DecimalType(19,0), 
            NHibernate.Type.Int32Type, then return an instance of NHibernate.Type.IType
            </summary>
            <param name="name">The name of the type.</param>
            <returns>The instance of the IType that the string represents.</returns>
            <remarks>
            This method will return null if the name is not found in the basicNameMap.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.HeuristicType(System.String)">
            <summary>
            Uses heuristics to deduce a NHibernate type given a string naming the 
            type. 
            </summary>
            <param name="typeName"></param>
            <returns>An instance of <c>NHibernate.Type.IType</c></returns>
            <remarks>
            When looking for the NHibernate type it will look in the cache of the Basic types first.
            If it doesn't find it in the cache then it uses the typeName to get a reference to the
            Class (Type in .NET).  Once we get the reference to the .NET class we check to see if it
            implements IType, ICompositeUserType, IUserType, ILifecycle (Association), or 
            IPersistentEnum.  If none of those are implemented then we will serialize the Type to the
            database using NHibernate.Type.SerializableType(typeName)  
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.HeuristicType(System.String,System.Collections.IDictionary)">
            <summary>
            Uses heuristics to deduce a NHibernate type given a string naming the 
            type. 
            </summary>
            <param name="typeName">the type name</param>
            <param name="parameters">parameters for the type</param>
            <returns>An instance of <c>NHibernate.Type.IType</c></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetAnsiStringType(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetBinaryType(System.Int32)">
            <summary>
            Gets the BinaryType with the specified length.
            </summary>
            <param name="length">The length of the data to store in the database.</param>
            <returns>A BinaryType</returns>
            <remarks>
            In addition to returning the BinaryType it will also ensure that it has
            been added to the basicNameMap with the keys <c>Byte[](length)</c> and 
            <c>NHibernate.Type.BinaryType(length)</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type)">
            <summary>
            Gets the SerializableType for the specified Type
            </summary>
            <param name="serializableType">The Type that will be Serialized to the database.</param>
            <returns>A SerializableType</returns>
            <remarks>
            <para>
            In addition to returning the SerializableType it will also ensure that it has
            been added to the basicNameMap with the keys <c>Type.FullName</c> (the result
            of <c>IType.Name</c> and <c>Type.AssemblyQualifiedName</c>.  This is different 
            from the other items put in the basicNameMap because it is uses the AQN and the
            FQN as opposed to the short name used in the maps and the FQN.
            </para>
            <para>
            Since this method calls the method
            <see cref="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type,System.Int32)">GetSerializableType(System.Type, Int32)</see>
            with the default length, those keys will also be added.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type,System.Int32)">
            <summary>
            
            </summary>
            <param name="serializableType"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetStringType(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetTypeType(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.OneToOne(System.Type,NHibernate.Type.ForeignKeyDirection,System.String,System.Boolean)">
            <summary>
            A one-to-one association type for the given class and cascade style.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.Type)">
            <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.Type,System.Boolean)">
            <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Array(System.String,System.String,System.Type)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Array"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="elementClass">The <see cref="T:System.Type"/> to use to create the array.</param>
            <returns>
            An <see cref="T:NHibernate.Type.ArrayType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.List(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <returns>
            A <see cref="T:NHibernate.Type.ListType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Bag(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Collections.IList"/>
            with bag semantics.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <returns>
            A <see cref="T:NHibernate.Type.BagType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.IdBag(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Collections.IList"/>
            with id-bag semantics.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <returns>
            A <see cref="T:NHibernate.Type.IdentifierBagType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Map(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Collections.IDictionary"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <returns>
            A <see cref="T:NHibernate.Type.MapType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Set(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:Iesi.Collections.ISet"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <returns>
            A <see cref="T:NHibernate.Type.SetType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.SortedMap(System.String,System.String,System.Collections.IComparer)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Collections.IDictionary"/>
            that is sorted by an <see cref="T:System.Collections.IComparer"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> that does the sorting.</param>
            <returns>
            A <see cref="T:NHibernate.Type.SortedMapType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.OrderedMap(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Collections.IDictionary"/>
            that maintains insertion order of elements.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <returns>
            A <see cref="T:NHibernate.Type.OrderedMapType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.SortedSet(System.String,System.String,System.Collections.IComparer)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:Iesi.Collections.ISet"/>
            that is sorted by an <see cref="T:System.Collections.IComparer"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> that does the sorting.</param>
            <returns>
            A <see cref="T:NHibernate.Type.SortedSetType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GenericBag(System.String,System.String,System.Type)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an 
            <see cref="T:System.Collections.Generic.IList`1"/> with bag semantics.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="elementClass">
            The <see cref="T:System.Type"/> to use to create the 
            <see cref="T:System.Collections.Generic.IList`1"/> with.
            </param>
            <returns>
            A <see cref="T:NHibernate.Type.GenericBagType`1"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GenericIdBag(System.String,System.String,System.Type)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an 
            <see cref="T:System.Collections.Generic.IList`1"/> with identifier
            bag semantics.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="elementClass">
            The <see cref="T:System.Type"/> to use to create the 
            <see cref="T:System.Collections.Generic.IList`1"/> with.
            </param>
            <returns>
            A <see cref="T:NHibernate.Type.GenericIdentifierBagType`1"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GenericList(System.String,System.String,System.Type)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an 
            <see cref="T:System.Collections.Generic.IList`1"/> with list 
            semantics.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="elementClass">
            The <see cref="T:System.Type"/> to use to create the 
            <see cref="T:System.Collections.Generic.IList`1"/> with.
            </param>
            <returns>
            A <see cref="T:NHibernate.Type.ListType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GenericMap(System.String,System.String,System.Type,System.Type)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an 
            <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="indexClass">
            The <see cref="T:System.Type"/> to use as the <c>TKey</c> to create the
            <see cref="T:System.Collections.Generic.IDictionary`2"/> with.
            </param>
            <param name="elementClass">
            The <see cref="T:System.Type"/> to use as the <c>TValue</c> to create the 
             <see cref="T:System.Collections.Generic.IDictionary`2"/> with.
            </param>
            <returns>
            A <see cref="T:NHibernate.Type.MapType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GenericSet(System.String,System.String,System.Type)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:Iesi.Collections.Generic.ISet`1"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="elementClass">The type of the set elements.</param>
            <returns>A <see cref="T:NHibernate.Type.GenericSetType`1"/> for the specified role.</returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GenericSortedSet(System.String,System.String,System.Object,System.Type)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for a sorted <see cref="T:Iesi.Collections.Generic.ISet`1"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the set.</param>
            <param name="elementType">The type of the elements in the set.</param>
            <returns>A <see cref="T:NHibernate.Type.GenericSetType`1"/> for the specified role.</returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.DeepCopy(System.Object[],NHibernate.Type.IType[],System.Boolean[],System.Object[])">
            <summary>
            Deep copy values in the first array into the second
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.FindDirty(NHibernate.Tuple.StandardProperty[],System.Object[],System.Object[],System.Boolean[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine if any of the given field values are dirty,
            returning an array containing indexes of
            the dirty fields or null if no fields are dirty.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.FindModified(NHibernate.Tuple.StandardProperty[],System.Object[],System.Object[],System.Boolean[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine if any of the given field values are modified,
            returning an array containing indexes of
            the dirty fields or null if no fields are modified.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Assemble(System.Object[],NHibernate.Type.ICacheAssembler[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="row"></param>
            <param name="types"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Disassemble(System.Object[],NHibernate.Type.ICacheAssembler[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="row"></param>
            <param name="types"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Replace(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="original"></param>
            <param name="target"></param>
            <param name="types"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <param name="copiedAlready"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Type.TypeType">
            <summary>
            Maps the Assembly Qualified Name of a <see cref="T:System.Type"/> to a 
            <see cref="F:System.Data.DbType.String"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TypeType.#ctor(NHibernate.SqlTypes.StringSqlType)">
            <summary>
            Initialize a new instance of the TypeType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            Gets the <see cref="T:System.Type"/> in the <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="index">The index of the field to get the value from.</param>
            <returns>The <see cref="T:System.Type"/> from the database.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown when the value in the database can not be loaded as a <see cref="T:System.Type"/>
            </exception>
        </member>
        <member name="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.String)">
            <summary>
            Gets the <see cref="T:System.Type"/> in the <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>The <see cref="T:System.Type"/> from the database.</returns>
            <remarks>
            This just calls gets the index of the name in the IDataReader
            and calls the overloaded version <see cref="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.Int32)"/>
            (IDataReader, Int32). 
            </remarks>
            <exception cref="T:System.TypeLoadException">
            Thrown when the value in the database can not be loaded as a <see cref="T:System.Type"/>
            </exception>
        </member>
        <member name="M:NHibernate.Type.TypeType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Puts the Assembly Qualified Name of the <see cref="T:System.Type"/> 
            Property into to the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the value into.</param>
            <param name="value">The <see cref="T:System.Type"/> that contains the value.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the value to.</param>
            <remarks>
            This uses the <see cref="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)"/> method of the 
            <see cref="F:NHibernate.NHibernateUtil.String"/> object to do the work.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="value">The <see cref="T:System.Type"/> that contains the values.
            </param>
            <returns>An Xml formatted string that contains the Assembly Qualified Name.</returns>
        </member>
        <member name="M:NHibernate.Type.TypeType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TypeType.ReturnedClass">
            <summary>
            Gets the <see cref="T:System.Type"/> that will be returned 
            by the <c>NullSafeGet()</c> methods.
            </summary>
            <value>
            A <see cref="T:System.Type"/> from the .NET framework.
            </value>
        </member>
        <member name="P:NHibernate.Type.TypeType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt16Type">
            <summary>
            Maps a <see cref="T:System.UInt16"/> Property 
            to a <see cref="F:System.Data.DbType.UInt16"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.UInt16Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt16Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt32Type">
            <summary>
            Maps a <see cref="T:System.UInt32"/> Property 
            to a <see cref="F:System.Data.DbType.UInt32"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.UInt32Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt32Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt64Type">
            <summary>
            Maps a <see cref="T:System.UInt64"/> Property 
            to a <see cref="F:System.Data.DbType.UInt64"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.#ctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.YesNoType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> to a 1 char <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column 
            that stores a <code>'Y'/'N'</code> to indicate <code>true/false</code>.
            </summary>
            <remarks>
            If you are using schema-export to generate your tables then you need
            to set the column attributes: <c>length=1</c> or <c>sql-type="char(1)"</c>.
            
            This needs to be done because in Java's JDBC there is a type for CHAR and 
            in ADO.NET there is not one specifically for char, so you need to tell schema
            export to create a char(1) column.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.YesNoType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.FalseString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.UserTypes.ICompositeUserType">
            <summary>
            A UserType that may be dereferenced in a query.
            This interface allows a custom type to define "properties".
            These need not necessarily correspond to physical .NET style properties.
            
            A ICompositeUserType may be used in almost every way 
            that a component may be used. It may even contain many-to-one
            associations.
            
            Implementors must be immutable and must declare a public
            default constructor.
            
            Unlike UserType, cacheability does not depend upon
            serializability. Instead, Assemble() and 
            Disassemble() provide conversion to/from a cacheable
            representation.
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            Get the value of a property
            </summary>
            <param name="component">an instance of class mapped by this "type"</param>
            <param name="property"></param>
            <returns>the property value</returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary>
            Set the value of a property
            </summary>
            <param name="component">an instance of class mapped by this "type"</param>
            <param name="property"></param>
            <param name="value">the value to set</param>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.Equals(System.Object,System.Object)">
            <summary>
            Compare two instances of the class mapped by this type for persistence
            "equality", ie. equality of persistent state.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.GetHashCode(System.Object)">
            <summary>
            Get a hashcode for the instance, consistent with persistence "equality"
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Retrieve an instance of the mapped class from a IDataReader. Implementors
            should handle possibility of null values.
            </summary>
            <param name="dr">IDataReader</param>
            <param name="names">the column names</param>
            <param name="session"></param>
            <param name="owner">the containing entity</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Write an instance of the mapped class to a prepared statement.
            Implementors should handle possibility of null values.
            A multi-column type should be written to parameters starting from index.
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.DeepCopy(System.Object)">
            <summary>
            Return a deep copy of the persistent state, stopping at entities and at collections.
            </summary>
            <param name="value">generally a collection element or entity field</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Transform the object into its cacheable representation.
            At the very least this method should perform a deep copy.
            That may not be enough for some implementations, method should perform a deep copy. That may not be enough for some implementations, however; for example, associations must be cached as identifier values. (optional operation)
            </summary>
            <param name="value">the object to be cached</param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Reconstruct an object from the cacheable representation.
            At the very least this method should perform a deep copy. (optional operation)
            </summary>
            <param name="cached">the object to be cached</param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            During merge, replace the existing (target) value in the entity we are merging to
            with a new (original) value from the detached entity we are merging. For immutable
            objects, or null values, it is safe to simply return the first parameter. For
            mutable objects, it is safe to return a copy of the first parameter. However, since
            composite user types often define component values, it might make sense to recursively 
            replace component values in the target object.
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.ICompositeUserType.PropertyNames">
            <summary>
            Get the "property names" that may be used in a query. 
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.ICompositeUserType.PropertyTypes">
            <summary>
            Get the corresponding "property types"
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.ICompositeUserType.ReturnedClass">
            <summary>
            The class returned by NullSafeGet().
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.ICompositeUserType.IsMutable">
            <summary>
            Are objects of this type mutable?
            </summary>
        </member>
        <member name="T:NHibernate.UserTypes.IEnhancedUserType">
            <summary>
            A custom type that may function as an identifier or discriminator
            type, or may be marshalled to and from an XML document.
            </summary>
        </member>
        <member name="T:NHibernate.UserTypes.IUserType">
            <summary>
            The inteface to be implemented by user-defined types.
            </summary>
            <remarks>
            <para>
            The inteface abstracts user code from future changes to the <see cref="T:NHibernate.Type.IType"/> inteface,
            simplifies the implementation of custom types and hides certain "internal interfaces from
            user code.
            </para>
            <para>
            Implemenators must be immutable and must declare a public default constructor.
            </para>
            <para>
            The actual class mapped by a <c>IUserType</c> may be just about anything. However, if it is to
            be cacheble by a persistent cache, it must be serializable.
            </para>
            <para>
            Alternatively, custom types could implement <see cref="T:NHibernate.Type.IType"/> directly or extend one of the
            abstract classes in <c>NHibernate.Type</c>. This approach risks future incompatible changes
            to classes or intefaces in the package.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.Equals(System.Object,System.Object)">
            <summary>
            Compare two instances of the class mapped by this type for persistent "equality"
            ie. equality of persistent state
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.GetHashCode(System.Object)">
            <summary>
            Get a hashcode for the instance, consistent with persistence "equality"
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.NullSafeGet(System.Data.IDataReader,System.String[],System.Object)">
            <summary>
            Retrieve an instance of the mapped class from a JDBC resultset.
            Implementors should handle possibility of null values.
            </summary>
            <param name="rs">a IDataReader</param>
            <param name="names">column names</param>
            <param name="owner">the containing entity</param>
            <returns></returns>
            <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Write an instance of the mapped class to a prepared statement.
            Implementors should handle possibility of null values.
            A multi-column type should be written to parameters starting from index.
            </summary>
            <param name="cmd">a IDbCommand</param>
            <param name="value">the object to write</param>
            <param name="index">command parameter index</param>
            <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.DeepCopy(System.Object)">
            <summary>
            Return a deep copy of the persistent state, stopping at entities and at collections.
            </summary>
            <param name="value">generally a collection element or entity field</param>
            <returns>a copy</returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.Replace(System.Object,System.Object,System.Object)">
            <summary>
            During merge, replace the existing (<paramref name="target" />) value in the entity
            we are merging to with a new (<paramref name="original" />) value from the detached
            entity we are merging. For immutable objects, or null values, it is safe to simply
            return the first parameter. For mutable objects, it is safe to return a copy of the
            first parameter. For objects with component values, it might make sense to
            recursively replace component values.
            </summary>
            <param name="original">the value from the detached entity being merged</param>
            <param name="target">the value in the managed entity</param>
            <param name="owner">the managed entity</param>
            <returns>the value to be merged</returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.Assemble(System.Object,System.Object)">
            <summary>
            Reconstruct an object from the cacheable representation. At the very least this
            method should perform a deep copy if the type is mutable. (optional operation)
            </summary>
            <param name="cached">the object to be cached</param>
            <param name="owner">the owner of the cached object</param>
            <returns>a reconstructed object from the cachable representation</returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.Disassemble(System.Object)">
            <summary>
            Transform the object into its cacheable representation. At the very least this
            method should perform a deep copy if the type is mutable. That may not be enough
            for some implementations, however; for example, associations must be cached as
            identifier values. (optional operation)
            </summary>
            <param name="value">the object to be cached</param>
            <returns>a cacheable representation of the object</returns>
        </member>
        <member name="P:NHibernate.UserTypes.IUserType.SqlTypes">
            <summary>
            The SQL types for the columns mapped by this type. 
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.IUserType.ReturnedType">
            <summary>
            The type returned by <c>NullSafeGet()</c>
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.IUserType.IsMutable">
            <summary>
            Are objects of this type mutable?
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IEnhancedUserType.FromXMLString(System.String)">
            <summary>
            Parse a string representation of this value, as it appears
            in an XML document.
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IEnhancedUserType.ObjectToSQLString(System.Object)">
            <summary>
            Return an SQL literal representation of the value
            </summary>
        </member>
        <member name="T:NHibernate.UserTypes.INullableUserType">
            <summary>
            A custom type with certain not-<see langword="null" /> values represented as <see langword="null" />
            in the database.
            </summary>
            <remarks>Implementing this interface is useful if a property of the type
            is used in a class with <c>dynamic-update</c> or <c>dynamic-insert</c>
            set to <see langword="true" />.
            </remarks>
        </member>
        <member name="M:NHibernate.UserTypes.INullableUserType.IsDatabaseNull(System.Object)">
            <summary>
            Determines whether the specified value is represented as <see langword="null" /> in the database.
            </summary>
            <param name="value">The value, may be <see langword="null" />.</param>
            <returns>
            <see langword="true" /> if the specified value is represented as <see langword="null" /> in the database;
            otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="T:NHibernate.UserTypes.IParameterizedType">
            <summary>
            Support for parameterizable types. A UserType or CustomUserType may be
            made parameterizable by implementing this interface. Parameters for a
            type may be set by using a nested type element for the property element
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IParameterizedType.SetParameterValues(System.Collections.IDictionary)">
            <summary>
            Gets called by Hibernate to pass the configured type parameters to 
            the implementation.
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiate an uninitialized instance of the collection wrapper
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wrap an instance of a collection
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.GetElements(System.Object)">
            <summary>
            Return an <see cref="T:System.Collections.IEnumerable"/> over the elements of this collection - the passed collection
            instance may or may not be a wrapper
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.Contains(System.Object,System.Object)">
            <summary>
            Optional operation. Does the collection contain the entity instance?
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.IndexOf(System.Object,System.Object)">
            <summary>
            Optional operation. Return the index of the entity in the collection.
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.ReplaceElements(System.Object,System.Object,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Replace the elements of a collection with the elements of another collection
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.Instantiate">
            <summary>
            Instantiate an empty instance of the "underlying" collection (not a wrapper)
            </summary>
        </member>
        <member name="T:NHibernate.UserTypes.IUserVersionType">
            <summary>
            A user type that may be used for a version property.
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserVersionType.Seed(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Generate an initial version.
            </summary>
            <param name="session">The session from which this request originates.  May be
            null; currently this only happens during startup when trying to determine
            the "unsaved value" of entities.</param>
            <returns>an instance of the type</returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserVersionType.Next(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Increment the version.
            </summary>
            <param name="current">The session from which this request originates.</param>
            <param name="session">the current version</param>
            <returns>an instance of the type</returns>
        </member>
        <member name="T:NHibernate.Util.ArrayHelper">
            <summary>
            Helper class that contains common array functions and 
            data structures used through out NHibernate.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.SafeSetValue(System.Collections.IList,System.Int32,System.Object)">
            <summary>
            Sets <paramref name="list" /> item at position <paramref name="index" /> to <paramref name="value" />.
            Expands the list by adding <see langword="null" /> values, if needed.
            </summary>
        </member>
        <member name="M:NHibernate.Util.CollectionHelper.GetHashCode(System.Collections.ICollection)">
            <summary>
            Computes a hash code for <paramref name="coll"/>.
            </summary>
            <remarks>The hash code is computed as the sum of hash codes of
            individual elements, so that the value is independent of the
            collection iteration order.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.CollectionHelper.CreateCaseInsensitiveHashtable">
            <summary>
            Creates a <see cref="T:System.Collections.Hashtable"/> that uses case-insensitive string comparison
            associated with invariant culture.
            </summary>
            <remarks>
            This is different from the method in <see cref="T:System.Collections.Specialized.CollectionsUtil"/>
            in that the latter uses the current culture and is thus vulnerable to the "Turkish I" problem.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.CollectionHelper.CreateCaseInsensitiveHashtable(System.Collections.IDictionary)">
            <summary>
            Creates a <see cref="T:System.Collections.Hashtable"/> that uses case-insensitive string comparison
            associated with invariant culture.
            </summary>
            <remarks>
            This is different from the method in <see cref="T:System.Collections.Specialized.CollectionsUtil"/>
            in that the latter uses the current culture and is thus vulnerable to the "Turkish I" problem.
            </remarks>
        </member>
        <member name="T:NHibernate.Util.CollectionHelper.EmptyMapClass">
            <summary>
            A read-only dictionary that is always empty and permits lookup by <see langword="null" /> key.
            </summary>
        </member>
        <member name="T:NHibernate.Util.CollectionPrinter">
            <summary>
            Utility class implementing ToString for collections. All <c>ToString</c>
            overloads call <c>element.ToString()</c>.
            </summary>
            <remarks>
            To print collections of entities or typed values, use
            <see cref="T:NHibernate.Impl.Printer"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.Util.FilterHelper">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Util.IdentityMap">
            <summary>
            An <see cref="T:System.Collections.IDictionary"/> where keys are compared by object identity, rather than <c>equals</c>.
            
            All external users of this class need to have no knowledge of the IdentityKey - it is all
            hidden by this class.
            </summary>
            <remarks>
            <para>
            Do NOT use a System.Value type as the key for this Hashtable - only classes.  See
            the <a href="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;threadm=bds2rm%24ruc%241%40charly.heeg.de&amp;rnum=1&amp;prev=/groups%3Fhl%3Den%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26q%3DSystem.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%26sa%3DN%26tab%3Dwg">google thread</a>
            about why using System.Value is a bad thing.
            </para>
            <para>
            If I understand it correctly, the first call to get an object defined by a DateTime("2003-01-01")
            would box the DateTime and return the identity key for the box.  If you were to get that Key and
            unbox it into a DateTime struct, then the next time you passed it in as the Key the IdentityMap
            would box it again (into a different box) and it would have a different IdentityKey - so you would
            not get the same value for the same DateTime value. 
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Instantiate(System.Int32)">
            <summary>
            Create a new instance of the IdentityMap that has no 
            iteration order.
            </summary>
            <returns>A new IdentityMap based on a Hashtable.</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.InstantiateSequenced(System.Int32)">
            <summary>
            Create a new instance of the IdentityMap that has an 
            iteration order of the order the objects were added
            to the Map.
            </summary>
            <returns>A new IdentityMap based on ListDictionary.</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.ConcurrentEntries(System.Collections.IDictionary)">
            <summary>
            Return the Dictionary Entries (as instances of <c>DictionaryEntry</c> in a collection
            that is safe from concurrent modification).  Ie - we may safely add new instances
            to the underlying <c>IDictionary</c> during enumeration of the <c>Values</c>.
            </summary>
            <param name="map">The IDictionary to get the enumeration safe list.</param>
            <returns>A Collection of DictionaryEntries</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.#ctor(System.Collections.IDictionary)">
            <summary>
            Create the IdentityMap class with the correct class for the IDictionary.
            Unsorted = Hashtable
            Sorted = ListDictionary
            </summary>
            <param name="underlyingMap">A class that implements the IDictionary for storing the objects.</param>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Add(System.Object,System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Clear">
            <summary>
            <see cref="M:System.Collections.IDictionary.Clear"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Contains(System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Contains(System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IDictionary.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Remove(System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Remove(System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.CopyTo(System.Array,System.Int32)">
            <summary>
            <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
            <param name="array"></param>
            <param name="i"></param>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.VerifyValidKey(System.Object)">
            <summary>
            Verifies that we are not using a System.ValueType as the Key in the Dictionary
            </summary>
            <param name="obj">The object that will be the key.</param>
            <returns>An object that is safe to be a key.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the obj is a System.ValueType</exception>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Count">
            <summary>
            <see cref="P:System.Collections.ICollection.Count"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.ICollection.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.SyncRoot">
            <summary>
            <see cref="P:System.Collections.ICollection.SyncRoot"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsFixedSize">
            <summary>
            <see cref="P:System.Collections.IDictionary.IsFixedSize"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsReadOnly">
            <summary>
            <see cref="P:System.Collections.IDictionary.IsReadOnly"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Keys">
            <summary>
            Returns the Keys used in this IdentityMap
            <see cref="P:System.Collections.IDictionary.IsReadOnly"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Item(System.Object)">
            <summary>
            <see cref="P:System.Collections.IDictionary.Item(System.Object)"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Values">
            <summary>
            <see cref="P:System.Collections.IDictionary.Values"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.EntryList">
            <summary>
            Provides a snapshot VIEW in the form of a List of the contents of the IdentityMap.
            You can safely iterate over this VIEW and modify the actual IdentityMap because the
            VIEW is a copy of the contents, not a reference to the existing Map.
            
            Contains a copy (not that actual instance stored) of the DictionaryEntries in a List.
            </summary>
        </member>
        <member name="T:NHibernate.Util.IdentityMap.IdentityComparer">
            <summary>
            Compares two objects for Equality using "==" instead of Object.Equals
            </summary>
            <remarks>
            Only for use in IdentityMap.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.IdentityComparer.Compare(System.Object,System.Object)">
            <summary>
            Performs a null safe comparison using "==" instead of Object.Equals()
            </summary>
            <param name="x">First object to compare.</param>
            <param name="y">Second object to compare.</param>
            <remarks>
            This is Lazy collection safe since it uses <c>==</c>, unlike <c>Object.Equals()</c> 
            which currently causes NHibernate to load up the collection.  This behaivior of 
            Collections is likely to change because Java's collections override Equals() and 
            .net's collections don't.  So in .net there is no need to override Equals() and 
            GetHashCode() on the NHibernate Collection implementations.
            </remarks>
            <returns>
            Unlike the standard IComparer interface this will not return a <c>1</c> or <c>-1</c>
            to indicate which is Greater Than or Less Than.  It always returns <c>-1</c> to 
            indicate the two are not Equal.
            </returns>
        </member>
        <member name="T:NHibernate.Util.JoinedEnumerable">
            <summary>
            Combines multiple objects implementing <see cref="T:System.Collections.IEnumerable"/> into one.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.#ctor(System.Collections.IEnumerable[])">
            <summary>
            Creates an IEnumerable object from multiple IEnumerables.
            </summary>
            <param name="enumerables">The IEnumerables to join together.</param>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.MoveNext">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.Reset">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.GetEnumerator">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.JoinedEnumerable._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this JoinedEnumerable is being Disposed of or Finalized.</param>
            <remarks>
            The command is closed and the reader is disposed.  This allows other ADO.NET
            related actions to occur without needing to move all the way through the
            EnumerableImpl.
            </remarks>
        </member>
        <member name="P:NHibernate.Util.JoinedEnumerable.Current">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Util.ObjectUtils">
            <summary>
            Summary description for ObjectUtils.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ObjectUtils.DefaultIfNull(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ObjectUtils.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ObjectUtils.IdentityToString(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Util.ObjectUtils.Null">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Util.PropertiesHelper">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetBoolean(System.String,System.Collections.IDictionary,System.Boolean)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetBoolean(System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetInt32(System.String,System.Collections.IDictionary,System.Int32)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetInt64(System.String,System.Collections.IDictionary,System.Int64)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetString(System.String,System.Collections.IDictionary,System.String)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.ToDictionary(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="delim"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.ToStringArray(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="delim"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.ToStringArray(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propValue"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="F:NHibernate.Util.PropertiesHelper.TagParam">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.PropertiesHelper.AttrValue">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.PropertiesHelper.AttrName">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetParams(System.Xml.XmlElement)">
            <summary>
            Extracts a set of param child nodes from the specified node
            &lt;param name="theName" value="theValue"/&gt;
            </summary>
            <param name="node">Parent element.</param>
            <returns>null if no parameters are found</returns>
        </member>
        <member name="T:NHibernate.Util.ReflectHelper">
            <summary>
            Helper class for Reflection related code.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.OverridesEquals(System.Type)">
            <summary>
            Determine if the specified <see cref="T:System.Type"/> overrides the
            implementation of Equals from <see cref="T:System.Object"/>
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to reflect.</param>
            <returns><see langword="true"/> if any type in the hierarchy overrides Equals(object).</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.OverridesGetHashCode(System.Type)">
            <summary>
            Determine if the specified <see cref="T:System.Type"/> overrides the
            implementation of GetHashCode from <see cref="T:System.Object"/>
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to reflect.</param>
            <returns><see langword="true"/> if any type in the hierarchy overrides GetHashCode().</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetGetter(System.Type,System.String,System.String)">
            <summary>
            Finds the <see cref="T:NHibernate.Property.IGetter"/> for the property in the <see cref="T:System.Type"/>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the property in.</param>
            <param name="propertyName">The name of the Property to find.</param>
            <param name="propertyAccessorName">The name of the property access strategy.</param>
            <returns>The <see cref="T:NHibernate.Property.IGetter"/> to get the value of the Property.</returns>
            <remarks>
            This one takes a propertyAccessor name as we might know the correct strategy by now so we avoid Exceptions which are costly
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyType(System.Type,System.String,System.String)">
            <summary>
            Get the NHibernate <see cref="T:NHibernate.Type.IType"/> for the named property of the <see cref="T:System.Type"/>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="name">The name of the property/field to find in the class.</param>
            <param name="access">The name of the property accessor for the property.</param>
            <returns>
            The NHibernate <see cref="T:NHibernate.Type.IType"/> for the named property.
            </returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyClass(System.Type,System.String,System.String)">
            <summary>
            Get the <see cref="T:System.Type"/> for the named property of a type.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the property in.</param>
            <param name="name">The name of the property/field to find in the class.</param>
            <param name="access">The name of the property accessor for the property.</param>
            <returns>The <see cref="T:System.Type"/> for the named property.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ClassForName(System.String)">
            <summary>
            Returns a reference to the Type.
            </summary>
            <param name="name">The name of the class or a fully qualified name.</param>
            <returns>The Type for the Class.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.TypeFromAssembly(NHibernate.Util.AssemblyQualifiedTypeName,System.Boolean)">
            <summary>
            Returns a <see cref="T:System.Type"/> from an already loaded Assembly or an
            Assembly that is loaded with a partial name.
            </summary>
            <param name="name">An <see cref="T:NHibernate.Util.AssemblyQualifiedTypeName"/>.</param>
            <param name="throwOnError"><see langword="true"/> if an exception should be thrown
            in case of an error, <see langword="false"/> otherwise.</param>
            <returns>
            A <see cref="T:System.Type"/> object that represents the specified type,
            or <see langword="null"/> if the type cannot be loaded.
            </returns>
            <remarks>
            Attempts to get a reference to the type from an already loaded assembly.  If the 
            type cannot be found then the assembly is loaded using
            <see cref="M:System.Reflection.Assembly.Load(System.String)"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetConstantValue(System.Type,System.String)">
            <summary>
            Returns the value of the static field <paramref name="fieldName"/> of <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> .</param>
            <param name="fieldName">The name of the field in the <paramref name="type"/>.</param>
            <returns>The value contained in the field, or <see langword="null"/> if the type or the field does not exist.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetDefaultConstructor(System.Type)">
            <summary>
            Gets the default no arg constructor for the <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the constructor for.</param>
            <returns>
            The <see cref="T:System.Reflection.ConstructorInfo"/> for the no argument constructor, or <see langword="null"/> if the
            <c>type</c> is an abstract class.
            </returns>
            <exception cref="T:NHibernate.InstantiationException">
            Thrown when there is a problem calling the method GetConstructor on <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetConstructor(System.Type,NHibernate.Type.IType[])">
            <summary>
            Finds the constructor that takes the parameters.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the constructor in.</param>
            <param name="types">The <see cref="T:NHibernate.Type.IType"/> objects to use to find the appropriate constructor.</param>
            <returns>
            An <see cref="T:System.Reflection.ConstructorInfo"/> that can be used to create the type with
            the specified parameters.
            </returns>
            <exception cref="T:NHibernate.InstantiationException">
            Thrown when no constructor with the correct signature can be found.
            </exception>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.IsAbstractClass(System.Type)">
            <summary>
            Determines if the <see cref="T:System.Type"/> is a non creatable class.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to check.</param>
            <returns><see langword="true"/> if the <see cref="T:System.Type"/> is an Abstract Class or an Interface.</returns>
        </member>
        <member name="T:NHibernate.Util.SequencedHashMap">
            <summary>
            A map of objects whose mapping entries are sequenced based on the order in which they were
            added. This data structure has fast <c>O(1)</c> search time, deletion time, and insertion time
            </summary>
            <remarks>
            This class is not thread safe.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.CreateSentinel">
            <summary>
            Construct an empty sentinel used to hold the head (sentinel.next) and the tail (sentinal.prev)
            of the list. The sentinal has a <see langword="null" /> key and value
            </summary>
            <returns></returns>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._sentinel">
            <summary>
            Sentinel used to hold the head and tail of the list of entries
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._entries">
            <summary>
            Map of keys to entries
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._modCount">
            <summary>
            Holds the number of modifications that have occurred to the map, excluding modifications
            made through a collection view's iterator.
            </summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor">
            <summary>
            Construct a new sequenced hash map with default initial size and load factor
            </summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32)">
            <summary>
            Construct a new sequenced hash map with the specified initial size and default load factor
            </summary>
            <param name="capacity">the initial size for the hash table</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Single)">
            <summary>
            Construct a new sequenced hash map with the specified initial size and load factor
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="loadFactor">the load factor for the hash table</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Construct a new sequenced hash map with the specified initial size, hash code provider
            and comparer
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="hcp"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Creates an empty Hashtable with the default initial capacity and using the default load factor, 
            the specified hash code provider and the specified comparer
            </summary>
            <param name="hcp"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Creates an empty Hashtable with the default initial capacity and using the default load factor, 
            the specified hash code provider and the specified comparer
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="loadFactor">the load factor for the hash table</param>
            <param name="hcp"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.RemoveEntry(NHibernate.Util.SequencedHashMap.Entry)">
            <summary>
            Removes an internal entry from the linked list. THis does not remove it from the underlying
            map.
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.InsertEntry(NHibernate.Util.SequencedHashMap.Entry)">
            <summary>
            Inserts a new internal entry to the tail of the linked list. This does not add the 
            entry to the underlying map.
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Add(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Contains(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Remove(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.System#Collections#IEnumerable#GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ContainsKey(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ContainsValue(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.RemoveImpl(System.Object)">
            <summary>
            Remove the Entry identified by the Key if it exists.
            </summary>
            <param name="key">The Key to remove.</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsFixedSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsReadOnly">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Item(System.Object)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Keys">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Values">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Count">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsSynchronized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.SyncRoot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.FirstKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.FirstValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.LastKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.LastValue">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnKey">
            <summary>
            Return only the Key of the DictionaryEntry
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnValue">
            <summary>
            Return only the Value of the DictionaryEntry
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnEntry">
            <summary>
            Return the full DictionaryEntry
            </summary>
        </member>
        <member name="T:NHibernate.Util.StringHelper">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Dot">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Underscore">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.CommaSpace">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Comma">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.OpenParen">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.ClosedParen">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.SingleQuote">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.NamePrefix">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.SqlParameter">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Repeat(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Replace(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="placeholder"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.ReplaceOnce(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="placeholder"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Split(System.String,System.String)">
            <summary>
            Just a façade for calling string.Split()
            We don't use our StringTokenizer because string.Split() is
            more efficient (but it only works when we don't want to retrieve the delimiters)
            </summary>
            <param name="separators">separators for the tokens of the list</param>
            <param name="list">the string that will be broken into tokens</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Split(System.String,System.String,System.Boolean)">
            <summary>
            Splits the String using the StringTokenizer.  
            </summary>
            <param name="separators">separators for the tokens of the list</param>
            <param name="list">the string that will be broken into tokens</param>
            <param name="include">true to include the seperators in the tokens.</param>
            <returns></returns>
            <remarks>
            This is more powerful than Split because you have the option of including or 
            not including the seperators in the tokens.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Unqualify(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Unqualify(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <param name="seperator"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.GetFullClassname(System.String)">
            <summary>
            Takes a fully qualified type name and returns the full name of the 
            Class - includes namespaces.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.GetClassname(System.String)">
            <summary>
            Takes a fully qualifed type name (can include the assembly) and just returns
            the name of the Class.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Qualifier(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Suffix(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="columns"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Suffix(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Prefix(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="columns"></param>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Root(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.BooleanValue(System.String)">
            <summary>
            Converts a <see cref="T:System.String"/> in the format of "true", "t", "false", or "f" to
            a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="value">The string to convert.</param>
            <returns>
            The <c>value</c> converted to a <see cref="T:System.Boolean"/> .
            </returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.ToString(System.Object[])">
            <summary>
            
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Multiply(System.String,System.Collections.IEnumerator,System.Collections.IEnumerator)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="placeholders"></param>
            <param name="replacements"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Multiply(System.String[],System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="strings"></param>
            <param name="placeholder"></param>
            <param name="replacements"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.CountUnquoted(System.String,System.Char)">
            <summary>
            Counts the unquoted instances of the character.
            </summary>
            <param name="str"></param>
            <param name="character"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Qualify(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="prefix"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.GenerateAlias(System.String,System.Int32)">
            <summary>
            Generate a nice alias for the given class name or collection role
            name and unique integer. Subclasses do <em>not</em> have to use
            aliases of this form.
            </summary>
            <returns>an alias of the form <c>foo1_</c></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.InternedIfPossible(System.String)">
            <summary>
            Returns the interned string equal to <paramref name="str"/> if there is one, or <paramref name="str"/>
            otherwise.
            </summary>
            <param name="str">A <see cref="T:System.String"/></param>
            <returns>A <see cref="T:System.String"/></returns>
        </member>
        <member name="T:NHibernate.Util.StringTokenizer">
            <summary>
            A StringTokenizer java like object 
            </summary>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="delim"></param>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="delim"></param>
            <param name="returnDelims"></param>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.GetEnumerator">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.WeakHashtable.Count">
            <summary>
            Count of elements in the collection. Unreliable!
            </summary>
        </member>
        <member name="T:NHibernate.ADOException">
            <summary>
            Wraps exceptions that occur during ADO.NET calls.
            </summary>
            <remarks>
            Exceptions thrown by various ADO.NET providers are not derived from
            a common base class (<c>SQLException</c> in Java), so <see cref="T:System.Exception"/>
            is used instead in NHibernate.
            </remarks>
        </member>
        <member name="M:NHibernate.ADOException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ADOException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.ADOException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ADOException"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.AssertionFailure">
            <summary>
            Indicates failure of an assertion: a possible bug in NHibernate
            </summary>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.CallbackException">
            <summary></summary>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.CriteriaUtil">
            <summary>
            Contains static declarations from Criteria interface in Hibernate.
            </summary>
        </member>
        <member name="F:NHibernate.CriteriaUtil.RootAlias">
            <summary>
            The alias that refers to the "root" entity of the criteria query.
            </summary>
        </member>
        <member name="F:NHibernate.CriteriaUtil.AliasToEntityMap">
            <summary>
            Each row of results is an <c>IDictionary</c> from alias to entity instance
            </summary>
        </member>
        <member name="F:NHibernate.CriteriaUtil.RootEntity">
            <summary>
            Each row of results is an instance of the root entity
            </summary>
        </member>
        <member name="F:NHibernate.CriteriaUtil.DistinctRootEntity">
            <summary>
            Each row of results is a distinct instance of the root entity
            </summary>
        </member>
        <member name="T:NHibernate.MappingException">
            <summary>
            An exception that usually occurs at configuration time, rather than runtime, as a result of
            something screwy in the O-R mappings
            </summary>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.DuplicateMappingException.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="customMessage">The message that describes the error. </param>
            <param name="name">The name of the duplicate object</param>
            <param name="type">The type of the duplicate object</param>
        </member>
        <member name="M:NHibernate.DuplicateMappingException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="name">The name of the duplicate object</param>
            <param name="type">The type of the duplicate object</param>
        </member>
        <member name="M:NHibernate.DuplicateMappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.DuplicateMappingException.Type">
            <summary>
            The type of the duplicated object
            </summary>
        </member>
        <member name="P:NHibernate.DuplicateMappingException.Name">
            <summary>
            The name of the duplicated object
            </summary>
        </member>
        <member name="T:NHibernate.IInterceptor">
            <summary>
            Allows user code to inspect and/or change property values before they are written and after they
            are read from the database
            </summary>
            <remarks>
            <para>
            There might be a single instance of <c>IInterceptor</c> for a <c>SessionFactory</c>, or a new
            instance might be specified for each <c>ISession</c>. Whichever approach is used, the interceptor
            must be serializable if the <c>ISession</c> is to be serializable. This means that <c>SessionFactory</c>
            -scoped interceptors should implement <c>ReadResolve()</c>.
            </para>
            <para>
            The <c>ISession</c> may not be invoked from a callback (nor may a callback cause a collection or
            proxy to be lazily initialized).
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IInterceptor.OnLoad(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called just before an object is initialized
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may change the <c>state</c>, which will be propagated to the persistent
            object. Note that when this method is called, <c>entity</c> will be an empty
            uninitialized instance of the class.</remarks>
            <returns><see langword="true" /> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnFlushDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called when an object is detected to be dirty, during a flush.
            </summary>
            <param name="currentState"></param>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the detected <c>currentState</c>, which will be propagated to
            both the database and the persistent object. Note that all flushes end in an actual
            synchronization with the database, in which as the new <c>currentState</c> will be propagated
            to the object, but not necessarily (immediately) to the database. It is strongly recommended
            that the interceptor <b>not</b> modify the <c>previousState</c>.
            </remarks>
            <returns><see langword="true" /> if the user modified the <c>currentState</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnSave(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is saved
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
            and propagated to the persistent object
            </remarks>
            <returns><see langword="true" /> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnDelete(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is deleted
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            It is not recommended that the interceptor modify the <c>state</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.IInterceptor.PreFlush(System.Collections.ICollection)">
            <summary>
            Called before a flush
            </summary>
            <param name="entities">The entities</param>
        </member>
        <member name="M:NHibernate.IInterceptor.PostFlush(System.Collections.ICollection)">
            <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
            <param name="entities">The entitites</param>
        </member>
        <member name="M:NHibernate.IInterceptor.IsUnsaved(System.Object)">
            <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
            <remarks>
            The return value determines if the object is saved
            <list>
            	<item><see langword="true" /> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item>
            	<item><see langword="false" /> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item>
            	<item><see langword="null" /> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item>
            </list>
            </remarks>
            <param name="entity">A transient entity</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IInterceptor.FindDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
            <remarks>
            	<list>
            		<item>an array of property indicies - the entity is dirty</item>
            		<item>an empty array - the entity is not dirty</item>
            		<item><see langword="null" /> - use Hibernate's default dirty-checking algorithm</item>
            	</list>
            </remarks>
            <param name="entity">A persistent entity</param>
            <param name="currentState"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <returns>An array of dirty property indicies or <see langword="null" /> to choose default behavior</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.Instantiate(System.Type,System.Object)">
            <summary>
            Instantiate the entity class. Return <see langword="null" /> to indicate that Hibernate should use the default
            constructor of the class
            </summary>
            <param name="type">A mapped type</param>
            <param name="id">The identifier of the new instance</param>
            <returns>An instance of the class, or <see langword="null" /> to choose default behaviour</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.AfterTransactionBegin(NHibernate.ITransaction)">
            <summary>
            Called when a NHibernate transaction is begun via the NHibernate <see cref="T:NHibernate.ITransaction"/>
            API. Will not be called if transactions are being controlled via some other mechanism.
            </summary>
        </member>
        <member name="M:NHibernate.IInterceptor.BeforeTransactionCompletion(NHibernate.ITransaction)">
            <summary>
            Called before a transaction is committed (but not before rollback).
            </summary>
        </member>
        <member name="M:NHibernate.IInterceptor.AfterTransactionCompletion(NHibernate.ITransaction)">
            <summary>
            Called after a transaction is committed or rolled back.
            </summary>
        </member>
        <member name="M:NHibernate.IInterceptor.SetSession(NHibernate.ISession)">
            <summary>
            Called when a session-scoped (and <b>only</b> session scoped) interceptor is attached
            to a session
            </summary>
        </member>
        <member name="T:NHibernate.FetchMode">
            <summary>
            Represents a fetching strategy.
            </summary>
            <remarks>
            This is used together with the <see cref="T:NHibernate.ICriteria"/> API to specify
            runtime fetching strategies.
            <para>
            For Hql queries, use the <c>FETCH</c> keyword instead.
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.FetchMode.Default">
            <summary>
            Default to the setting configured in the mapping file.
            </summary>
        </member>
        <member name="F:NHibernate.FetchMode.Select">
            <summary>
            Fetch eagerly, using a separate select. Equivalent to
            <c>fetch="select"</c> (and <c>outer-join="false"</c>)
            </summary>
        </member>
        <member name="F:NHibernate.FetchMode.Join">
            <summary>
            Fetch using an outer join.  Equivalent to
            <c>fetch="join"</c> (and <c>outer-join="true"</c>)
            </summary>
        </member>
        <member name="T:NHibernate.FlushMode">
            <summary>
            Represents a flushing strategy.
            </summary>
            <remarks>
            The flush process synchronizes database state with session state by detecting state
            changes and executing SQL statements
            </remarks>
        </member>
        <member name="F:NHibernate.FlushMode.Unspecified">
            <summary>
            Special value for unspecified flush mode (like <see langword="null" /> in Java).
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Never">
            <summary>
            The <c>ISession</c> is never flushed unless <c>Flush()</c> is explicitly
            called by the application. This mode is very efficient for read only
            transactions
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Commit">
            <summary>
            The <c>ISession</c> is flushed when <c>Transaction.Commit()</c> is called
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Auto">
            <summary>
            The <c>ISession</c> is sometimes flushed before query execution in order to
            ensure that queries never return stale state. This is the default flush mode.
            </summary>
        </member>
        <member name="T:NHibernate.IDatabinder">
            <summary>
            Provides XML marshalling for classes registered with a <c>SessionFactory</c>
            </summary>
            <remarks>
            <para>
            Hibernate defines a generic XML format that may be used to represent any class
            (<c>hibernate-generic.dtd</c>). The user configures an XSLT stylesheet for marshalling
            data from this generic format to an application and/or user readable format. By default,
            Hibernate will use <c>hibernate-default.xslt</c> which maps data to a useful human-
            readable format.
            </para>
            <para>
            The property <c>hibernate.xml.output_stylesheet</c> specifies a user-written stylesheet.
            Hibernate will attempt to load the stylesheet from the classpath first and if not found,
            will attempt to load it as a file
            </para>
            <para>
            It is not intended that implementors be threadsafe
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IDatabinder.Bind(System.Object)">
            <summary>
            Add an object to the output document.
            </summary>
            <param name="obj">A transient or persistent instance</param>
            <returns>Databinder</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.BindAll(System.Collections.ICollection)">
            <summary>
            Add a collection of objects to the output document
            </summary>
            <param name="objs">A collection of transient or persistent instance</param>
            <returns>Databinder</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToGenericXml">
            <summary>
            Output the generic XML representation of the bound objects
            </summary>
            <returns>Generic Xml representation</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToGenericXmlDocument">
            <summary>
            Output the generic XML Representation of the bound objects
            to a <c>XmlDocument</c>
            </summary>
            <returns>A generic Xml tree</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToXML">
            <summary>
            Output the custom XML representation of the bound objects
            </summary>
            <returns>Custom Xml representation</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToXmlDocument">
            <summary>
            Output the custom XML representation of the bound objects as
            an <c>XmlDocument</c>
            </summary>
            <returns>A custom Xml Tree</returns>
        </member>
        <member name="P:NHibernate.IDatabinder.InitializeLazy">
            <summary>
            Controls whether bound objects (and their associated objects) that are lazily instanciated
            are explicityl initialized or left as they are
            </summary>
            <value>True to explicitly initilize lazy objects, false to leave them in the state they are in</value>
        </member>
        <member name="T:NHibernate.InstantiationException">
            <summary>
            Thrown if Hibernate can't instantiate an entity or component class at runtime.
            </summary>
        </member>
        <member name="M:NHibernate.InstantiationException.#ctor(System.String,System.Exception,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.InstantiationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
            <param name="type">The <see cref="T:System.Type"/> that NHibernate was trying to instantiate.</param>
        </member>
        <member name="M:NHibernate.InstantiationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.InstantiationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.InstantiationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.InstantiationException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.InstantiationException.PersistentType">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was trying to instantiate.
            </summary>
        </member>
        <member name="P:NHibernate.InstantiationException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.InstantiationException"/>.
            </summary>
            <value>
            The error message that explains the reason for this exception and the Type that
            was trying to be instantiated.
            </value>
        </member>
        <member name="T:NHibernate.InvalidProxyTypeException">
            <summary>
            Thrown when an invalid type is specified as a proxy for a class.
            The exception is also thrown when a class is specified as lazy,
            but cannot be used as a proxy for itself.
            </summary>
        </member>
        <member name="T:NHibernate.LazyInitializationException">
            <summary>
            A problem occurred trying to lazily initialize a collection or proxy (for example the session
            was closed) or iterate query results.
            </summary>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.LockMode">
            <summary>
            Instances represent a lock mode for a row of a relational database table.
            </summary>
            <remarks>
            It is not intended that users spend much time worrying about locking since Hibernate
            usually obtains exactly the right lock level automatically. Some "advanced" users may
            wish to explicitly specify lock levels.
            </remarks>
        </member>
        <member name="M:NHibernate.LockMode.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <param name="name"></param>
        </member>
        <member name="M:NHibernate.LockMode.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.LockMode.GreaterThan(NHibernate.LockMode)">
            <summary>
            Is this lock mode more restrictive than the given lock mode?
            </summary>
            <param name="mode"></param>
        </member>
        <member name="M:NHibernate.LockMode.LessThan(NHibernate.LockMode)">
            <summary>
            Is this lock mode less restrictive than the given lock mode?
            </summary>
            <param name="mode"></param>
        </member>
        <member name="F:NHibernate.LockMode.None">
            <summary>
            No lock required. 
            </summary>
            <remarks>
            If an object is requested with this lock mode, a <c>Read</c> lock
            might be obtained if necessary.
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Read">
            <summary>
            A shared lock. 
            </summary>
            <remarks>
            Objects are loaded in <c>Read</c> mode by default
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Upgrade">
            <summary>
            An upgrade lock. 
            </summary>
            <remarks>
            Objects loaded in this lock mode are materialized using an
            SQL <c>SELECT ... FOR UPDATE</c>
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.UpgradeNoWait">
            <summary>
            Attempty to obtain an upgrade lock, using an Oracle-style
            <c>SELECT ... FOR UPGRADE NOWAIT</c>. 
            </summary>
            <remarks>
            The semantics of this lock mode, once obtained, are the same as <c>Upgrade</c>
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Write">
            <summary>
            A <c>Write</c> lock is obtained when an object is updated or inserted.
            </summary>
            <remarks>
            This is not a valid mode for <c>Load()</c> or <c>Lock()</c>.
            </remarks>
        </member>
        <member name="T:NHibernate.NHibernateUtil">
            <summary>
            Provides access to the full range of NHibernate built-in types.
            IType instances may be used to bind values to query parameters.
            Also a factory for new Blobs and Clobs.
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.AnsiString">
            <summary>
            NHibernate Ansi String type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Binary">
            <summary>
            NHibernate binary type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.BinaryBlob">
            <summary>
            NHibernate binary blob type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Boolean">
            <summary>
            NHibernate boolean type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Byte">
            <summary>
            NHibernate byte type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Character">
            <summary>
            NHibernate character type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.CultureInfo">
            <summary>
            NHibernate Culture Info type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.DateTime">
            <summary>
            NHibernate date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Date">
            <summary>
            NHibernate date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Decimal">
            <summary>
            NHibernate decimal type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Double">
            <summary>
            NHibernate double type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Guid">
            <summary>
            NHibernate Guid type.
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int16">
            <summary>
            NHibernate System.Int16 (short in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int32">
            <summary>
            NHibernate System.Int32 (int in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int64">
            <summary>
            NHibernate System.Int64 (long in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.SByte">
            <summary>
            NHibernate System.SByte type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt16">
            <summary>
            NHibernate System.UInt16 (ushort in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt32">
            <summary>
            NHibernate System.UInt32 (uint in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt64">
            <summary>
            NHibernate System.UInt64 (ulong in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Single">
            <summary>
            NHIbernate System.Single (float in C#) Type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.String">
            <summary>
            NHibernate String type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.StringClob">
            <summary>
            NHibernate string clob type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Time">
            <summary>
            NHibernate Time type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Ticks">
            <summary>
            NHibernate Ticks type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.TimeSpan">
            <summary>
            NHibernate Ticks type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Timestamp">
            <summary>
            NHibernate Timestamp type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.TrueFalse">
            <summary>
            NHibernate TrueFalse type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.YesNo">
            <summary>
            NHibernate YesNo type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Class">
            <summary>
            NHibernate class type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Serializable">
            <summary>
            NHibernate serializable type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Object">
            <summary>
            NHibernate System.Object type
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.#ctor">
            <summary>
            Cannot be instantiated.
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Enum(System.Type)">
            <summary>
            A NHibernate persistent enum type
            </summary>
            <param name="enumClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.GetSerializable(System.Type)">
            <summary>
            A NHibernate serializable type
            </summary>
            <param name="serializableClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Any(NHibernate.Type.IType,NHibernate.Type.IType)">
            <summary>
            A NHibernate serializable type
            </summary>
            <param name="metaType">a type mapping <see cref="T:NHibernate.Type.IType"/> to a single column</param>
            <param name="identifierType">the entity identifier type</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Association(System.Type)">
            <summary>
            A NHibernate persistent object (entity) type
            </summary>
            <param name="persistentClass">a mapped entity class</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Entity(System.Type)">
            <summary>
            A NHibernate persistent object (entity) type
            </summary>
            <param name="persistentClass">a mapped entity class</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Custom(System.Type)">
            <summary>
            A NHibernate custom type
            </summary>
            <param name="userTypeClass">a class that implements UserType</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Initialize(System.Object)">
            <summary>
            Force initialization of a proxy or persistent collection.
            </summary>
            <param name="proxy">a persistable object, proxy, persistent collection or null</param>
            <exception cref="T:NHibernate.HibernateException">if we can't initialize the proxy at this time, eg. the Session was closed</exception>
        </member>
        <member name="M:NHibernate.NHibernateUtil.IsInitialized(System.Object)">
            <summary>
            Is the proxy or persistent collection initialized?
            </summary>
            <param name="proxy">a persistable object, proxy, persistent collection or null</param>
            <returns>true if the argument is already initialized, or is not a proxy or collection</returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.GetClass(System.Object)">
            <summary>
            Get the true, underlying class of a proxied persistent class. This operation
            will initialize a proxy by side-effect.
            </summary>
            <param name="proxy">a persistable object or proxy</param>
            <returns>the true class of the instance</returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Close(System.Collections.IEnumerator)">
            <summary>
            Close an <see cref="T:System.Collections.IEnumerator"/> obtained from an <see cref="T:System.Collections.IEnumerable"/>
            returned by NHibernate immediately, instead of waiting until the session is
            closed or disconnected.
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Close(System.Collections.IEnumerable)">
            <summary>
            Close an <see cref="T:System.Collections.IEnumerable"/> returned by NHibernate immediately,
            instead of waiting until the session is closed or disconnected.
            </summary>
        </member>
        <member name="T:NHibernate.NonUniqueObjectException">
            <summary>
            This exception is thrown when an operation would
            break session-scoped identity. This occurs if the
            user tries to associate two different instances of
            the same class with a particular identifier,
            in the scope of a single <see cref="T:NHibernate.ISession"/>.
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="id">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
            <param name="id">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.InstantiationException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.NonUniqueResultException">
            <summary>
            Thrown when the application calls <see cref="M:NHibernate.IQuery.UniqueResult">IQuery.UniqueResult()</see> 
            and the query returned more than one result. Unlike all other NHibernate 
            exceptions, this one is recoverable!
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueResultException.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueResultException"/> class.
            </summary>
            <param name="resultCount">The number of items in the result.</param>
        </member>
        <member name="M:NHibernate.NonUniqueResultException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueResultException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ObjectDeletedException">
            <summary>
            Thrown when the user tries to pass a deleted object to the <c>ISession</c>.
            </summary>
        </member>
        <member name="T:NHibernate.UnresolvableObjectException">
            <summary>
            Thrown when Hibernate could not resolve an object by id, especially when
            loading an association.
            </summary>
        </member>
        <member name="M:NHibernate.UnresolvableObjectException.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.UnresolvableObjectException"/> class.
            </summary>
            <param name="identifier">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.UnresolvableObjectException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.UnresolvableObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="identifier">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.ObjectDeletedException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectDeletedException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.ObjectDeletedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectDeletedException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ObjectNotFoundException">
            <summary>
            Thrown when <c>ISession.Load()</c> fails to select a row with
            the given primary key (identifier value). This exception might not
            be thrown when <c>Load()</c> is called, even if there was no
            row on the database, because <c>Load()</c> returns a proxy if
            possible. Applications should use <c>ISession.Get()</c> to test if 
            a row exists in the database.
            </summary>
        </member>
        <member name="M:NHibernate.ObjectNotFoundException.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectNotFoundException"/> class.
            </summary>
            <param name="identifier">The identifier of the object that was attempting to be loaded.</param>
            <param name="type">The <see cref="T:System.Type"/> that NHibernate was trying to find a row for in the database.</param>
        </member>
        <member name="M:NHibernate.ObjectNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectNotFoundException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.PersistentObjectException">
            <summary>
            Thrown when the user passes a persistent instance to a <c>ISession</c> method that expects a
            transient instance
            </summary>
        </member>
        <member name="M:NHibernate.PersistentObjectException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PersistentObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.PersistentObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PersistentObjectException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.PropertyAccessException">
            <summary>
            A problem occurred accessing a property of an instance of a persistent class by reflection
            </summary>
        </member>
        <member name="M:NHibernate.PropertyAccessException.#ctor(System.Exception,System.String,System.Boolean,System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyAccessException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
            <param name="wasSetter">A <see cref="T:System.Boolean"/> indicating if this was a "setter" operation.</param>
            <param name="persistentType">The <see cref="T:System.Type"/> that NHibernate was trying find the Property or Field in.</param>
            <param name="propertyName">The mapped property name that was trying to be accessed.</param>
        </member>
        <member name="M:NHibernate.PropertyAccessException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyAccessException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyAccessException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.PropertyAccessException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.PropertyAccessException.PersistentType">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was trying find the Property or Field in.
            </summary>
        </member>
        <member name="P:NHibernate.PropertyAccessException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.PropertyAccessException"/>.
            </summary>
            <value>
            The error message that explains the reason for this exception and 
            information about the mapped property and its usage.
            </value>
        </member>
        <member name="T:NHibernate.PropertyNotFoundException">
            <summary>
            Indicates that an expected getter or setter method could not be found on a class
            </summary>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Type,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class,
            used when a property get/set accessor is missing.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> that is missing the property</param>
            <param name="propertyName">The name of the missing property</param>
            <param name="accessorType">The type of the missing accessor
            ("getter" or "setter")</param>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class,
            used when a field is missing.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> that is missing the field</param>
            <param name="fieldName">The name of the missing property</param>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyValueException.#ctor(System.String,System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyValueException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="persistentClass">The <see cref="T:System.Type"/> that NHibernate was trying to access.</param>
            <param name="propertyName">The name of the Property that was being get/set.</param>
        </member>
        <member name="M:NHibernate.PropertyValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyValueException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyValueException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.PropertyValueException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ReplicationMode">
            <summary>
            Represents a replication strategy
            </summary>
        </member>
        <member name="M:NHibernate.ReplicationMode.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <param name="name"></param>
        </member>
        <member name="M:NHibernate.ReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="F:NHibernate.ReplicationMode.Exception">
            <summary></summary>
        </member>
        <member name="F:NHibernate.ReplicationMode.Ignore">
            <summary></summary>
        </member>
        <member name="F:NHibernate.ReplicationMode.Overwrite">
            <summary></summary>
        </member>
        <member name="F:NHibernate.ReplicationMode.LatestVersion">
            <summary></summary>
        </member>
        <member name="M:NHibernate.ReplicationMode.ExceptionReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Throw an exception when a row already exists
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ReplicationMode.IgnoreReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Ignore replicated entities when a row already exists
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ReplicationMode.OverwriteReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Overwrite existing rows when a row already exists
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ReplicationMode.LatestVersionReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            When a row already exists, choose the latest version
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.StaleObjectStateException">
            <summary>
            Thrown when a version number check failed, indicating that the 
            <see cref="T:NHibernate.ISession"/> contained stale data (when using long transactions with
            versioning).
            </summary>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.#ctor(System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.StaleObjectStateException"/> class.
            </summary>
            <param name="persistentType">The <see cref="T:System.Type"/> that NHibernate was trying to update in the database.</param>
            <param name="identifier">The identifier of the object that is stale.</param>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.StaleObjectStateException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.StaleObjectStateException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.PersistentType">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was trying to update in the database.
            </summary>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.Identifier">
            <summary>
            Gets the identifier of the object that is stale.
            </summary>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.StaleObjectStateException"/>.
            </summary>
            <value>The error message that explains the reason for this exception.</value>
        </member>
        <member name="T:NHibernate.TransactionException">
            <summary>
            Indicated that a transaction could not be begun, committed, or rolled back
            </summary>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.TransientObjectException">
            <summary>
            Throw when the user passes a transient instance to a <c>ISession</c> method that expects
            a persistent instance
            </summary>
        </member>
        <member name="M:NHibernate.TransientObjectException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransientObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.TransientObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransientObjectException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.WrongClassException">
            <summary>
            Thrown when <c>ISession.Load()</c> selects a row with the given primary key (identifier value)
            but the row's discriminator value specifies a different subclass from the one requested
            </summary>
        </member>
        <member name="M:NHibernate.WrongClassException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.WrongClassException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="identifier">The identifier of the object that was being loaded.</param>
            <param name="type">The <see cref="T:System.Type"/> that NHibernate was told to load.</param>
        </member>
        <member name="M:NHibernate.WrongClassException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.WrongClassException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.WrongClassException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.WrongClassException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.WrongClassException.Identifier">
            <summary>
            Gets the identifier of the object that was being loaded.
            </summary>
        </member>
        <member name="P:NHibernate.WrongClassException.Type">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was told to load.
            </summary>
        </member>
        <member name="P:NHibernate.WrongClassException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.WrongClassException"/>.
            </summary>
            <value>The error message that explains the reason for this exception.</value>
        </member>
    </members>
</doc>
