// Copyright 2004-2008 Castle Project - http://www.castleproject.org/
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */

namespace NVelocity.Runtime.Parser
{
	using System;
	using System.Collections;
	using System.Diagnostics;
	using System.IO;
	using Directive;
	using Node;

	/// <summary> This class is responsible for parsing a Velocity
	/// template. This class was generated by JavaCC using
	/// the JJTree extension to produce an Abstract
	/// Syntax Tree (AST) of the template.
	///
	/// Please look at the Parser.jjt file which is
	/// what controls the generation of this class.
	/// </summary>
	public class Parser
	{
		public ParserTokenManager token_source;
		public Token token, jj_nt;
		//UPGRADE_NOTE: Field jj_ntk was renamed. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1029"'
		private int jj_ntk_Renamed_Field;
		private Token jj_scanpos, jj_lastpos;
		private int jj_la;
		public bool lookingAhead = false;
		private int jj_gen;
		//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
		//UPGRADE_NOTE: The initialization of  'jj_la1' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private int[] jj_la1;
		//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1_0 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
		private int[] jj_la1_0 =
			new int[]
				{
					0x13f0360, 0x0, 0x13f0360, 0x380000, 0x1000000, 0x6800002, 0x800000, 0x7800002, 0x13f0360, 0x8, 0x7800002, 0x800000
					, 0x0, 0x800000, 0x800000, 0x0, 0x800000, 0x800000, 0x1000000, 0x6000002, 0x800000, 0x8, 0x7800002, 0x0, 0x0, 0x0,
					0x1060060, 0x800000, 0x13f0360, 0x0, 0x0, 0x0, 0x13f0360, 0x800000, 0x13f0360, 0x8000000, 0x7800022, 0x0, 0x0, 0x0,
					0x0, 0x0, 0x0, 0x30000000, 0x30000000, (int) (- (0x100000000 - 0xc0000000)), (int) (- (0x100000000 - 0xc0000000)),
					0x800000, 0x7800022, 0x800000, 0x1000000, 0x6000022, 0x800000
				};

		//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1_1 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
		private int[] jj_la1_1 =
			new int[]
				{
					0xf129000, 0x9000, 0xe120000, 0x0, 0x5120000, 0x0, 0x0, 0x5120000, 0xf129000, 0x0, 0x5020000, 0x0, 0x5020000, 0x0,
					0x0, 0x5020000, 0x0, 0x0, 0x0, 0x5020000, 0x0, 0x0, 0x5020000, 0x1000000, 0x1000000, 0x5000000, 0xe020000, 0x0,
					0xf129000, 0x2000, 0x2000, 0x4000, 0xf129000, 0x0, 0xf129000, 0x0, 0x5020200, 0x4, 0x2, 0x180, 0x180, 0x78, 0x78,
					0x0, 0x0, 0x1, 0x1, 0x0, 0x5020000, 0x0, 0x5020000, 0x0, 0x0
				};

		//UPGRADE_NOTE: Final was removed from the declaration of 'callsArray '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
		//UPGRADE_NOTE: The initialization of  'callsArray' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private Calls[] callsArray;
		private bool jj_rescan = false;
		private int jj_gc = 0;

		//UPGRADE_NOTE: The initialization of  'expEntries' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private ArrayList expEntries;
		private int[] jj_expEntry;
		private int jj_kind = -1;
		//UPGRADE_NOTE: The initialization of  'lastTokens' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private int[] lastTokens;
		private int endPosition;

		internal ParserState nodeTree;

		/// <summary>  This Hashtable contains a list of all of the dynamic directives.
		/// </summary>
		//UPGRADE_NOTE: The initialization of  'directives' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private IDirectiveManager directives;

		/// <summary>  Name of current template we are parsing.  Passed to us in parse()
		/// </summary>
		internal String currentTemplateName = string.Empty;

		internal VelocityCharStream velcharstream = null;

		private IRuntimeServices runtimeServices = null;

		protected Stack directiveStack = new Stack();

		/// <summary> 
		/// This constructor was added to allow the re-use of parsers.
		/// The normal constructor takes a single argument which
		/// an InputStream. This simply creates a re-usable parser
		/// object, we satisfy the requirement of an InputStream
		/// by using a newline character as an input stream.
		/// </summary>
		public Parser(IRuntimeServices rs)
			: this(new VelocityCharStream(new StringReader("\n"), 1, 1))
		{
			InitBlock();

			/*
			* now setup a VCS for later use
			*/
			velcharstream = new VelocityCharStream(new StringReader("\n"), 1, 1);

			/*
			*  and save the RuntimeServices
			*/
			runtimeServices = rs;
		}

		private void InitBlock()
		{
			nodeTree = new ParserState();
			directives = null;
			jj_la1 = new int[53];
			callsArray = new Calls[12];
			expEntries = new ArrayList();
			lastTokens = new int[100];
		}

		public IDirectiveManager Directives
		{
			set { directives = value; }
		}

		public Token NextToken
		{
			get
			{
				if (token.Next != null)
				{
					token = token.Next;
				}
				else
				{
					token = token.Next = token_source.NextToken;
				}
				jj_ntk_Renamed_Field = -1;
				jj_gen++;
				return token;
			}
		}

		///
		/// <summary> This was also added to allow parsers to be
		/// re-usable. Normal JavaCC use entails passing an
		/// input stream to the constructor and the parsing
		/// process is carried out once. We want to be able
		/// to re-use parsers: we do this by adding this
		/// method and re-initializing the lexer with
		/// the new stream that we want parsed.
		/// </summary>
		public SimpleNode Parse(TextReader reader, String templateName)
		{
			SimpleNode sn = null;

			currentTemplateName = templateName;

			try
			{
				token_source.ClearStateVars();

				/*
				*  reinitialize the VelocityCharStream
				*  with the new reader
				*/
				velcharstream.ReInit(reader, 1, 1);

				/*
				* now reinit the Parser with this CharStream
				*/
				ReInit(velcharstream);

				sn = Process();
			}
			catch(ParseException pe)
			{
				//				runtimeServices.Error("Parser Exception: " + templateName + " : " + StringUtils.StackTrace(pe));
				throw (pe.currentToken == null) ? pe : new ParseException(pe.currentToken, pe.expectedTokenSequences, pe.tokenImage);
			}
			catch(TokenMgrError tme)
			{
				throw new ParseException(string.Format("Lexical error: {0}", tme));
			}
			catch(Exception)
			{
				//				runtimeServices.Error("Parser Error: " + templateName + " : " + StringUtils.StackTrace(e));
			}

			currentTemplateName = string.Empty;

			return sn;
		}

		/// <summary>  This method finds out of the directive exists in the directives
		/// Hashtable.
		/// </summary>
		public bool IsDirective(String directive)
		{
			return (directives.Contains(directive));
		}

		/// <summary> Produces a processed output for an escaped control or
		/// pluggable directive
		/// </summary>
		private String EscapedDirective(String strImage)
		{
			int iLast = strImage.LastIndexOf("\\");

			String strDirective = strImage.Substring(iLast + 1);

			bool bRecognizedDirective = false;
			string name = strDirective.Substring(1);

			if (IsDirective(name))
			{
				bRecognizedDirective = true;
			}
			else if (runtimeServices.IsVelocimacro(name, currentTemplateName))
			{
				bRecognizedDirective = true;
			}
			else
			{
				/* order for speed? */

				switch(name)
				{
					case "if":
					case "end":
					case "set":
					case "else":
					case "elseif":
					case "stop":
						bRecognizedDirective = true;
						break;
				}
			}

			/*
	    *  if so, make the proper prefix string (let the escapes do their thing..)
	    *  otherwise, just return what it is..
	    */

			if (bRecognizedDirective)
				return (strImage.Substring(0, (iLast / 2) - (0)) + strDirective);
			else
				return (strImage);
		}

		/// <summary> This method is what starts the whole parsing
		/// process. After the parsing is complete and
		/// the template has been turned into an AST,
		/// this method returns the root of AST which
		/// can subsequently be traversed by a visitor
		/// which implements the ParserVisitor interface
		/// which is generated automatically by JavaCC
		/// </summary>
		public SimpleNode Process()
		{
			/*@bgen(jjtree) process */
			ASTprocess jjtn000 = new ASTprocess(this, ParserTreeConstants.PROCESS);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				while(true)
				{
					switch(GetCurrentTokenKind())
					{
						case ParserConstants.LPAREN:
						case ParserConstants.RPAREN:
						case ParserConstants.ESCAPE_DIRECTIVE:
						case ParserConstants.SET_DIRECTIVE:
						case ParserConstants.DOUBLE_ESCAPE:
						case ParserConstants.ESCAPE:
						case ParserConstants.TEXT:
						case ParserConstants.SINGLE_LINE_COMMENT:
						case ParserConstants.FORMAL_COMMENT:
						case ParserConstants.MULTI_LINE_COMMENT:
						case ParserConstants.STRING_LITERAL:
						case ParserConstants.IF_DIRECTIVE:
						case ParserConstants.STOP_DIRECTIVE:
						case ParserConstants.NUMBER_LITERAL:
						case ParserConstants.WORD:
						case ParserConstants.IDENTIFIER:
						case ParserConstants.DOT:
						case ParserConstants.LCURLY:
						case ParserConstants.RCURLY:
							break;

						default:
							jj_la1[0] = jj_gen;
							//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
							goto label_1_brk;
					}
					Statement();
				}
				//UPGRADE_NOTE: Label 'label_1_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
				label_1_brk:
				;

				ConsumeToken(0);
				nodeTree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				if (true)
					return jjtn000;
			}
			catch(Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					throw;
				}
				if (jjte000 is ParseException)
				{
					throw;
				}

				throw;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
			//throw new ApplicationException("Missing return statement in function");
		}

		/// <summary> These are the types of statements that
		/// are acceptable in Velocity templates.
		/// </summary>
		public void Statement()
		{
			int kind = GetCurrentTokenKind();
			switch(kind)
			{
				case ParserConstants.IF_DIRECTIVE:
					IfStatement();
					break;

				case ParserConstants.STOP_DIRECTIVE:
					StopStatement();
					break;

				default:
					jj_la1[1] = jj_gen;
					if (jj_2_1(2))
					{
						Reference();
					}
					else
					{
						int kind2 = GetCurrentTokenKind();
						switch(kind2)
						{
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
								Comment();
								break;

							case ParserConstants.SET_DIRECTIVE:
								SetDirective();
								break;

							case ParserConstants.ESCAPE_DIRECTIVE:
								EscapedDirective();
								break;

							case ParserConstants.DOUBLE_ESCAPE:
								Escape();
								break;

							case ParserConstants.WORD:
								Directive();
								break;

							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								Text();
								break;

							default:
								jj_la1[2] = jj_gen;
								ConsumeToken(-1);
								throw new ParseException();
						}
					}
					break;
			}
		}

		/// <summary>  used to separate the notion of a valid directive that has been
		/// escaped, versus something that looks like a directive and
		/// is just schmoo.  This is important to do as a separate production
		/// that creates a node, because we want this, in either case, to stop
		/// the further parsing of the Directive() tree.
		/// </summary>
		public void EscapedDirective()
		{
			/*@bgen(jjtree) EscapedDirective */
			ASTEscapedDirective jjtn000 = new ASTEscapedDirective(this, ParserTreeConstants.ESCAPED_DIRECTIVE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				Token t = ConsumeToken(ParserConstants.ESCAPE_DIRECTIVE);
				nodeTree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				/*
				*  churn and burn..
				*/
				t.Image = EscapedDirective(t.Image);
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary>  Used to catch and process escape sequences in grammatical constructs
		/// as escapes outside of VTL are just characters.  Right now we have both
		/// this and the EscapeDirective() construction because in the EscapeDirective()
		/// case, we want to suck in the #&lt;directive&gt; and here we don't.  We just want
		/// the escapes to render correctly
		/// </summary>
		public void Escape()
		{
			/*@bgen(jjtree) Escape */
			ASTEscape jjtn000 = new ASTEscape(this, ParserTreeConstants.ESCAPE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				Token t;
				int count = 0;
				bool control = false;
				while(true)
				{
					t = ConsumeToken(ParserConstants.DOUBLE_ESCAPE);
					count++;
					if (jj_2_2(2))
					{
						;
					}
					else
					{
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_2_brk;
					}
				}
				//UPGRADE_NOTE: Label 'label_2_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
				label_2_brk:
				;

				nodeTree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				/*
				* first, check to see if we have a control directive
				*/
				switch(t.Next.Kind)
				{
					case ParserConstants.IF_DIRECTIVE:
					case ParserConstants.ELSE_DIRECTIVE:
					case ParserConstants.ELSEIF_DIRECTIVE:
					case ParserConstants.END:
					case ParserConstants.STOP_DIRECTIVE:
						control = true;
						break;
				}

				/*
				* if that failed, lets lookahead to see if we matched a PD or a VM
				*/

				if (IsDirective(t.Next.Image.Substring(1)))
					control = true;
				else if (runtimeServices.IsVelocimacro(t.Next.Image.Substring(1), currentTemplateName))
					control = true;

				t.Image = string.Empty;

				for(int i = 0; i < count; i++)
					t.Image += (control ? "\\" : "\\\\");
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void Comment()
		{
			/*@bgen(jjtree) Comment */
			ASTComment jjtn000 = new ASTComment(this, ParserTreeConstants.COMMENT);
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.SINGLE_LINE_COMMENT:
						ConsumeToken(ParserConstants.SINGLE_LINE_COMMENT);
						break;

					case ParserConstants.MULTI_LINE_COMMENT:
						ConsumeToken(ParserConstants.MULTI_LINE_COMMENT);
						break;

					case ParserConstants.FORMAL_COMMENT:
						ConsumeToken(ParserConstants.FORMAL_COMMENT);
						break;

					default:
						jj_la1[3] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
			}
			finally
			{
				nodeTree.CloseNodeScope(jjtn000, true);
			}
		}

		public void NumberLiteral()
		{
			/*@bgen(jjtree) NumberLiteral */
			ASTNumberLiteral jjtn000 = new ASTNumberLiteral(this, ParserTreeConstants.NUMBER_LITERAL);
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.NUMBER_LITERAL);
			}
			finally
			{
				nodeTree.CloseNodeScope(jjtn000, true);
			}
		}

		public void StringLiteral()
		{
			/*@bgen(jjtree) StringLiteral */
			ASTStringLiteral jjtn000 = new ASTStringLiteral(this, ParserTreeConstants.STRING_LITERAL);
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.STRING_LITERAL);
			}
			finally
			{
				nodeTree.CloseNodeScope(jjtn000, true);
			}
		}

		/// <summary> This method corresponds to variable
		/// references in Velocity templates.
		/// The following are examples of variable
		/// references that may be found in a
		/// template:
		/// *
		/// $foo
		/// $bar
		/// *
		/// </summary>
		public void Identifier()
		{
			/*@bgen(jjtree) Identifier */
			ASTIdentifier jjtn000 = new ASTIdentifier(this, ParserTreeConstants.IDENTIFIER);
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.IDENTIFIER);
			}
			finally
			{
				nodeTree.CloseNodeScope(jjtn000, true);
			}
		}

		public void Word()
		{
			/*@bgen(jjtree) Word */
			ASTWord jjtn000 = new ASTWord(this, ParserTreeConstants.WORD);
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.WORD);
			}
			finally
			{
				nodeTree.CloseNodeScope(jjtn000, true);
			}
		}

		/// <summary>   Supports the arguments for the Pluggable Directives
		/// We add whitespace in here as a token so the VMs can
		/// easily reconstruct a macro body from the token stream
		/// See Directive()
		/// </summary>
		public void DirectiveArg()
		{
			switch(GetCurrentTokenKind())
			{
				case ParserConstants.IDENTIFIER:
				case ParserConstants.LCURLY:
					Reference();
					break;

				case ParserConstants.WORD:
					Word();
					break;

				case ParserConstants.STRING_LITERAL:
					StringLiteral();
					break;

				case ParserConstants.NUMBER_LITERAL:
					NumberLiteral();
					break;

				default:
					jj_la1[4] = jj_gen;
					if (jj_2_3(2147483647))
					{
						IntegerRange();
					}
					else
					{
						switch(GetCurrentTokenKind())
						{
							case ParserConstants.LBRACKET:
								ObjectArray();
								break;

							case ParserConstants.TRUE:
								True();
								break;

							case ParserConstants.FALSE:
								False();
								break;

							case ParserConstants.WHITESPACE:
								ConsumeToken(ParserConstants.WHITESPACE);
								break;

							default:
								jj_la1[5] = jj_gen;
								ConsumeToken(-1);
								throw new ParseException();
						}
					}
					break;
			}
		}

		/// <summary>   Supports the Pluggable Directives
		/// #foo( arg+ )
		/// </summary>
		public SimpleNode Directive()
		{
			ASTDirective directiveNode = new ASTDirective(this, ParserTreeConstants.DIRECTIVE);

			bool isNodeScopeOpen = true;
			nodeTree.OpenNodeScope(directiveNode);
			Token token;
			Directive directive;
			bool doItNow = false;

			try
			{
				/*
				* note that if we were escaped, that is now handled by 
				* EscapedDirective()
				*/
				token = ConsumeToken(ParserConstants.WORD);
				String directiveName = token.Image.Substring(1);

				directive = directives.Create(directiveName, directiveStack);

				Debug.Assert(directiveNode != null);

				directiveNode.Directive = directive;

				/*
				*  Velocimacro support : if the directive is macro directive
				*   then set the flag so after the block parsing, we add the VM
				*   right then. (So available if used w/in the current template )
				*/

				if (directiveName.Equals("macro"))
				{
					doItNow = true;
				}

				/*
				* set the directive name from here.  No reason for the thing to know 
				* about parser tokens
				*/

				directiveNode.DirectiveName = directiveName;

				DirectiveType directiveType;
				if (directive == null)
				{
					// if null, then not a real directive, but maybe a Velocimacro

					//d  =  (Directive) runtimeServices.getVelocimacro( directiveName, currentTemplateName );

					// TODO: adding a null check since RuntimeServices is not finished
					// since the parser can be created without RuntimeServices - this may actually be needed here and in the orgiginal source as well.
					if (runtimeServices != null)
					{
						if (!runtimeServices.IsVelocimacro(directiveName, currentTemplateName))
						{
							token_source.StateStackPop();
							token_source.inDirective = false;
							if (true)
								return directiveNode;
						}
					}

					/*
					 *  Currently, all VMs are LINE directives
					 */
					directiveType = DirectiveType.LINE;
				}
				else
				{
					directiveType = directive.Type;
				}

				/*
				*  now, switch us out of PRE_DIRECTIVE
				*/

				token_source.SwitchTo(ParserConstants.DIRECTIVE);

				ConsumeWhiteSpaces();

				if (directive != null && !directive.AcceptParams)
				{
					int curToken = GetCurrentTokenKind();

					if (curToken == ParserConstants.NEWLINE)
					{
						ConsumeToken(ParserConstants.NEWLINE);
					}
					else
					{
						throw new ParseException(
							"Foreach directives must be the only items on the line (comments or contents are not allowed)");
					}
				}

				if (directive == null || directive.AcceptParams)
				{
					ConsumeToken(ParserConstants.LPAREN);

					while(true)
					{
						switch(GetCurrentTokenKind())
						{
							case ParserConstants.LBRACKET:
							case ParserConstants.WHITESPACE:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.TRUE:
							case ParserConstants.FALSE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.LCURLY:
								;
								break;

							default:
								jj_la1[7] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_3_brk;
						}
						DirectiveArg();
					}
					//UPGRADE_NOTE: Label 'label_3_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_3_brk:
					;

					ConsumeToken(ParserConstants.RPAREN);
				}

				if (directiveType == DirectiveType.LINE)
				{
					return directiveNode;
				}

				directiveStack.Push(directive);

				ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.BLOCK);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);

				try
				{
					while(true)
					{
						Statement();
						int kind = GetCurrentTokenKind();
						switch(kind)
						{
							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE_DIRECTIVE:
							case ParserConstants.SET_DIRECTIVE:
							case ParserConstants.DOUBLE_ESCAPE:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.IF_DIRECTIVE:
							case ParserConstants.STOP_DIRECTIVE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								break;

							default:
								jj_la1[8] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_4_brk;
						}
					}
					//UPGRADE_NOTE: Label 'label_4_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_4_brk:
					;
				}
				catch(Exception jjte001)
				{
					nodeTree.ClearNodeScope(jjtn001);
					jjtc001 = false;
					if (jjte001 is SystemException)
					{
						throw;
					}
					if (jjte001 is ParseException)
					{
						throw;
					}
					throw (ApplicationException) jjte001;
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, true);
					}

					directiveStack.Pop();
				}
				ConsumeToken(ParserConstants.END);
				nodeTree.CloseNodeScope(directiveNode, true);
				isNodeScopeOpen = false;
				/*
				 *  VM : if we are processing a #macro directive, we need to 
				 *     process the block.  In truth, I can just register the name
				 *     and do the work later when init-ing.  That would work
				 *     as long as things were always defined before use.  This way
				 *     we don't have to worry about forward references and such...
				 */

				if (doItNow)
				{
					Macro.processAndRegister(runtimeServices, directiveNode, currentTemplateName);
				}

				return directiveNode;
			}
			catch(Exception jjte000)
			{
				if (isNodeScopeOpen)
				{
					nodeTree.ClearNodeScope(directiveNode);
					isNodeScopeOpen = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					throw;
				}
				if (jjte000 is ParseException)
				{
					throw;
				}
				throw (ApplicationException) jjte000;
			}
			finally
			{
				if (isNodeScopeOpen)
				{
					nodeTree.CloseNodeScope(directiveNode, true);
				}
			}
		}

		private int GetCurrentTokenKind()
		{
			if (jj_ntk_Renamed_Field == -1)
			{
				return jj_ntk();
			}
			else
			{
				return jj_ntk_Renamed_Field;
			}
		}

		private void ConsumeWhiteSpaces()
		{
			switch(GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[6] = jj_gen;
					break;
			}
		}

		public void ObjectArray()
		{
			/*@bgen(jjtree) ObjectArray */
			ASTObjectArray jjtn000 = new ASTObjectArray(this, ParserTreeConstants.OBJECT_ARRAY);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.LBRACKET);
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.LBRACKET:
					case ParserConstants.WHITESPACE:
					case ParserConstants.STRING_LITERAL:
					case ParserConstants.TRUE:
					case ParserConstants.FALSE:
					case ParserConstants.NUMBER_LITERAL:
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						Parameter();
						while(true)
						{
							switch(GetCurrentTokenKind())
							{
								case ParserConstants.COMMA:
									;
									break;

								default:
									jj_la1[9] = jj_gen;
									//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
									goto label_5_brk;
							}
							ConsumeToken(ParserConstants.COMMA);
							Parameter();
						}
						//UPGRADE_NOTE: Label 'label_5_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_5_brk:
						;

						break;

					default:
						jj_la1[10] = jj_gen;
						;
						break;
				}
				ConsumeToken(ParserConstants.RBRACKET);
			}
			catch(Exception jjte000)
			{
				nodeTree.ClearNodeScope(jjtn000);
				jjtc000 = false;
				if (jjte000 is SystemException)
				{
					throw;
				}
				if (jjte000 is ParseException)
				{
					throw;
				}
				throw (ApplicationException) jjte000;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary>  supports the [n..m] vector generator for use in
		/// the #foreach() to generate measured ranges w/o
		/// needing explicit support from the app/servlet
		/// </summary>
		public void IntegerRange()
		{
			/*@bgen(jjtree) IntegerRange */
			ASTIntegerRange jjtn000 = new ASTIntegerRange(this, ParserTreeConstants.INTEGER_RANGE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.LBRACKET);
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[11] = jj_gen;
						;
						break;
				}
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						Reference();
						break;

					case ParserConstants.NUMBER_LITERAL:
						NumberLiteral();
						break;

					default:
						jj_la1[12] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[13] = jj_gen;
						break;
				}
				ConsumeToken(ParserConstants.DOUBLEDOT);
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[14] = jj_gen;
						break;
				}
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						Reference();
						break;

					case ParserConstants.NUMBER_LITERAL:
						NumberLiteral();
						break;

					default:
						jj_la1[15] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[16] = jj_gen;
						break;
				}
				ConsumeToken(ParserConstants.RBRACKET);
			}
			catch(Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					throw;
				}
				if (jjte000 is ParseException)
				{
					throw;
				}
				throw (ApplicationException) jjte000;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary> This method has yet to be fully implemented
		/// but will allow arbitrarily nested method
		/// calls
		/// </summary>
		public void Parameter()
		{
			switch(GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[17] = jj_gen;
					;
					break;
			}
			switch(GetCurrentTokenKind())
			{
				case ParserConstants.STRING_LITERAL:
					StringLiteral();
					break;

				default:
					jj_la1[18] = jj_gen;
					if (jj_2_4(2147483647))
					{
						IntegerRange();
					}
					else
					{
						switch(GetCurrentTokenKind())
						{
							case ParserConstants.LBRACKET:
								ObjectArray();
								break;

							case ParserConstants.TRUE:
								True();
								break;

							case ParserConstants.FALSE:
								False();
								break;

							case ParserConstants.IDENTIFIER:
							case ParserConstants.LCURLY:
								Reference();
								break;

							case ParserConstants.NUMBER_LITERAL:
								NumberLiteral();
								break;

							default:
								jj_la1[19] = jj_gen;
								ConsumeToken(-1);
								throw new ParseException();
						}
					}
					break;
			}
			switch(GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[20] = jj_gen;
					;
					break;
			}
		}

		/// <summary> This method has yet to be fully implemented
		/// but will allow arbitrarily nested method
		/// calls
		/// </summary>
		public void Method()
		{
			/*@bgen(jjtree) Method */
			ASTMethod jjtn000 = new ASTMethod(this, ParserTreeConstants.METHOD);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				Identifier();
				ConsumeToken(ParserConstants.LPAREN);
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.LBRACKET:
					case ParserConstants.WHITESPACE:
					case ParserConstants.STRING_LITERAL:
					case ParserConstants.TRUE:
					case ParserConstants.FALSE:
					case ParserConstants.NUMBER_LITERAL:
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						Parameter();
						while(true)
						{
							switch(GetCurrentTokenKind())
							{
								case ParserConstants.COMMA:
									break;
								default:
									jj_la1[21] = jj_gen;
									//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
									goto label_6_brk;
							}
							ConsumeToken(ParserConstants.COMMA);
							Parameter();
						}
						//UPGRADE_NOTE: Label 'label_6_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_6_brk:
						;

						break;

					default:
						jj_la1[22] = jj_gen;
						;
						break;
				}
				ConsumeToken(ParserConstants.REFMOD2_RPAREN);
			}
			catch(Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					throw;
				}
				if (jjte000 is ParseException)
				{
					throw;
				}
				throw (ApplicationException) jjte000;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void Reference()
		{
			/*@bgen(jjtree) Reference */
			ASTReference jjtn000 = new ASTReference(this, ParserTreeConstants.REFERENCE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.IDENTIFIER:
						ConsumeToken(ParserConstants.IDENTIFIER);
						while(true)
						{
							if (jj_2_5(2))
							{
								;
							}
							else
							{
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_7_brk;
							}
							ConsumeToken(ParserConstants.DOT);
							if (jj_2_6(3))
							{
								Method();
							}
							else
							{
								switch(GetCurrentTokenKind())
								{
									case ParserConstants.IDENTIFIER:
										Identifier();
										break;

									default:
										jj_la1[23] = jj_gen;
										ConsumeToken(-1);
										throw new ParseException();
								}
							}
						}
						//UPGRADE_NOTE: Label 'label_7_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_7_brk:
						;

						break;

					case ParserConstants.LCURLY:
						ConsumeToken(ParserConstants.LCURLY);
						ConsumeToken(ParserConstants.IDENTIFIER);
						while(true)
						{
							if (!jj_2_7(2))
							{
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_8_brk;
							}
							ConsumeToken(ParserConstants.DOT);
							if (jj_2_8(3))
							{
								Method();
							}
							else
							{
								switch(GetCurrentTokenKind())
								{
									case ParserConstants.IDENTIFIER:
										Identifier();
										break;

									default:
										jj_la1[24] = jj_gen;
										ConsumeToken(-1);
										throw new ParseException();
								}
							}
						}
						//UPGRADE_NOTE: Label 'label_8_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_8_brk:
						;

						ConsumeToken(ParserConstants.RCURLY);
						break;

					default:
						jj_la1[25] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
			}
			catch(Exception exception)
			{
				nodeTree.ClearNodeScope(jjtn000);
				jjtc000 = false;
				if (exception is SystemException)
				{
					throw;
				}
				if (exception is ParseException)
				{
					throw;
				}
				throw (ApplicationException) exception;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void True()
		{
			/*@bgen(jjtree) True */
			ASTTrue jjtn000 = new ASTTrue(this, ParserTreeConstants.TRUE);
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.TRUE);
			}
			finally
			{
				nodeTree.CloseNodeScope(jjtn000, true);
			}
		}

		public void False()
		{
			/*@bgen(jjtree) False */
			ASTFalse jjtn000 = new ASTFalse(this, ParserTreeConstants.FALSE);
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.FALSE);
			}
			finally
			{
				nodeTree.CloseNodeScope(jjtn000, true);
			}
		}

		/// <summary> This method is responsible for allowing
		/// all non-grammar text to pass through
		/// unscathed.
		/// </summary>
		public void Text()
		{
			/*@bgen(jjtree) Text */
			ASTText jjtn000 = new ASTText(this, ParserTreeConstants.TEXT);
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.TEXT:
						ConsumeToken(ParserConstants.TEXT);
						break;

					case ParserConstants.DOT:
						ConsumeToken(ParserConstants.DOT);
						break;

					case ParserConstants.RPAREN:
						ConsumeToken(ParserConstants.RPAREN);
						break;

					case ParserConstants.LPAREN:
						ConsumeToken(ParserConstants.LPAREN);
						break;

					case ParserConstants.NUMBER_LITERAL:
						ConsumeToken(ParserConstants.NUMBER_LITERAL);
						break;

					case ParserConstants.STRING_LITERAL:
						ConsumeToken(ParserConstants.STRING_LITERAL);
						break;

					case ParserConstants.ESCAPE:
						ConsumeToken(ParserConstants.ESCAPE);
						break;

					case ParserConstants.LCURLY:
						ConsumeToken(ParserConstants.LCURLY);
						break;

					case ParserConstants.RCURLY:
						ConsumeToken(ParserConstants.RCURLY);
						break;

					default:
						jj_la1[26] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
			}
			finally
			{
				nodeTree.CloseNodeScope(jjtn000, true);
			}
		}

		/* -----------------------------------------------------------------------
		* 
		*  Defined Directive Syntax
		* 
		* ----------------------------------------------------------------------*/

		public void IfStatement()
		{
			/*@bgen(jjtree) IfStatement */
			ASTIfStatement jjtn000 = new ASTIfStatement(this, ParserTreeConstants.IF_STATEMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.IF_DIRECTIVE);
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[27] = jj_gen;
						;
						break;
				}
				ConsumeToken(ParserConstants.LPAREN);
				Expression();
				ConsumeToken(ParserConstants.RPAREN);
				ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.BLOCK);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					while(true)
					{
						Statement();
						switch(GetCurrentTokenKind())
						{
							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE_DIRECTIVE:
							case ParserConstants.SET_DIRECTIVE:
							case ParserConstants.DOUBLE_ESCAPE:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.IF_DIRECTIVE:
							case ParserConstants.STOP_DIRECTIVE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								;
								break;

							default:
								jj_la1[28] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_9_brk;
						}
					}
					//UPGRADE_NOTE: Label 'label_9_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_9_brk:
					;
				}
				catch(Exception exception)
				{
					nodeTree.ClearNodeScope(jjtn001);
					jjtc001 = false;
					if (exception is SystemException)
					{
						throw;
					}
					if (exception is ParseException)
					{
						throw;
					}
					throw (ApplicationException) exception;
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, true);
					}
				}

				switch(GetCurrentTokenKind())
				{
					case ParserConstants.ELSEIF_DIRECTIVE:
						while(true)
						{
							ElseIfStatement();
							switch(GetCurrentTokenKind())
							{
								case ParserConstants.ELSEIF_DIRECTIVE:
									;
									break;

								default:
									jj_la1[29] = jj_gen;
									//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
									goto label_10_brk;
							}
						}
						//UPGRADE_NOTE: Label 'label_10_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_10_brk:

						break;

					default:
						jj_la1[30] = jj_gen;
						break;
				}

				switch(GetCurrentTokenKind())
				{
					case ParserConstants.ELSE_DIRECTIVE:
						ElseStatement();
						break;
					default:
						jj_la1[31] = jj_gen;
						break;
				}
				ConsumeToken(ParserConstants.END);
			}
			catch(Exception exception)
			{
				nodeTree.ClearNodeScope(jjtn000);
				jjtc000 = false;
				if (exception is SystemException)
				{
					throw;
				}
				if (exception is ParseException)
				{
					throw;
				}
				throw (ApplicationException) exception;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void ElseStatement()
		{
			/*@bgen(jjtree) ElseStatement */
			ASTElseStatement jjtn000 = new ASTElseStatement(this, ParserTreeConstants.ELSE_STATEMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.ELSE_DIRECTIVE);
				ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.BLOCK);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					while(true)
					{
						Statement();
						switch(GetCurrentTokenKind())
						{
							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE_DIRECTIVE:
							case ParserConstants.SET_DIRECTIVE:
							case ParserConstants.DOUBLE_ESCAPE:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.IF_DIRECTIVE:
							case ParserConstants.STOP_DIRECTIVE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								;
								break;

							default:
								jj_la1[32] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_11_brk;
						}
					}
					//UPGRADE_NOTE: Label 'label_11_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_11_brk:
					;
				}
				catch(Exception exception)
				{
					nodeTree.ClearNodeScope(jjtn001);
					jjtc001 = false;
					if (exception is SystemException)
					{
						throw;
					}
					if (exception is ParseException)
					{
						throw;
					}
					throw (ApplicationException) exception;
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, true);
					}
				}
			}
			catch(Exception exception)
			{
				nodeTree.ClearNodeScope(jjtn000);
				jjtc000 = false;
				if (exception is SystemException)
				{
					throw;
				}
				if (exception is ParseException)
				{
					throw;
				}
				throw (ApplicationException) exception;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void ElseIfStatement()
		{
			/*@bgen(jjtree) ElseIfStatement */
			ASTElseIfStatement jjtn000 = new ASTElseIfStatement(this, ParserTreeConstants.ELSE_IF_STATEMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.ELSEIF_DIRECTIVE);
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[33] = jj_gen;
						break;
				}
				ConsumeToken(ParserConstants.LPAREN);
				Expression();
				ConsumeToken(ParserConstants.RPAREN);
				ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.BLOCK);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					while(true)
					{
						Statement();
						switch(GetCurrentTokenKind())
						{
							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE_DIRECTIVE:
							case ParserConstants.SET_DIRECTIVE:
							case ParserConstants.DOUBLE_ESCAPE:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.IF_DIRECTIVE:
							case ParserConstants.STOP_DIRECTIVE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								;
								break;

							default:
								jj_la1[34] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_12_brk;
						}
					}
					//UPGRADE_NOTE: Label 'label_12_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_12_brk:
					;
				}
				catch(Exception exception)
				{
					nodeTree.ClearNodeScope(jjtn001);
					jjtc001 = false;
					if (exception is SystemException)
					{
						throw;
					}
					if (exception is ParseException)
					{
						throw;
					}
					throw (ApplicationException) exception;
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, true);
					}
				}
			}
			catch(Exception exception)
			{
				nodeTree.ClearNodeScope(jjtn000);
				jjtc000 = false;
				if (exception is SystemException)
				{
					throw;
				}
				if (exception is ParseException)
				{
					throw;
				}
				throw (ApplicationException) exception;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary>  Currently support both types of set :
		/// #set( expr )
		/// #set expr
		/// </summary>
		public void SetDirective()
		{
			/*@bgen(jjtree) SetDirective */
			ASTSetDirective jjtn000 = new ASTSetDirective(this, ParserTreeConstants.SET_DIRECTIVE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.SET_DIRECTIVE);
				if (jj_2_9(2))
				{
					ConsumeToken(ParserConstants.WHITESPACE);
				}
				ConsumeToken(ParserConstants.LPAREN);
				Expression();
				ConsumeToken(ParserConstants.RPAREN);
				/*
				* ensure that inSet is false.  Leads to some amusing bugs...
				*/

				token_source.inSet = false;
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.NEWLINE:
						ConsumeToken(ParserConstants.NEWLINE);
						break;

					default:
						jj_la1[35] = jj_gen;
						break;
				}
			}
			catch(Exception exception)
			{
				nodeTree.ClearNodeScope(jjtn000);
				jjtc000 = false;
				if (exception is SystemException)
				{
					throw;
				}
				if (exception is ParseException)
				{
					throw;
				}
				throw (ApplicationException) exception;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary> This method corresponds to the #stop
		/// directive which just simulates and EOF
		/// so that parsing stops. The #stop directive
		/// is useful for end-user debugging
		/// purposes.
		/// </summary>
		public void StopStatement()
		{
			ConsumeToken(ParserConstants.STOP_DIRECTIVE);
		}

		/* -----------------------------------------------------------------------
		* 
		*  Expression Syntax
		* 
		* ----------------------------------------------------------------------*/

		public void Expression()
		{
			/*@bgen(jjtree) Expression */
			ASTExpression jjtn000 = new ASTExpression(this, ParserTreeConstants.EXPRESSION);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				if (jj_2_10(2147483647))
				{
					Assignment();
				}
				else
				{
					switch(GetCurrentTokenKind())
					{
						case ParserConstants.LBRACKET:
						case ParserConstants.LPAREN:
						case ParserConstants.WHITESPACE:
						case ParserConstants.STRING_LITERAL:
						case ParserConstants.TRUE:
						case ParserConstants.FALSE:
						case ParserConstants.LOGICAL_NOT:
						case ParserConstants.NUMBER_LITERAL:
						case ParserConstants.IDENTIFIER:
						case ParserConstants.LCURLY:
							ConditionalOrExpression();
							break;

						default:
							jj_la1[36] = jj_gen;
							ConsumeToken(-1);
							throw new ParseException();
					}
				}
			}
			catch(Exception exception)
			{
				nodeTree.ClearNodeScope(jjtn000);
				jjtc000 = false;
				if (exception is SystemException)
				{
					throw;
				}
				if (exception is ParseException)
				{
					throw;
				}
				throw (ApplicationException) exception;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void Assignment()
		{
			/*@bgen(jjtree) #Assignment( 2) */
			ASTAssignment jjtn000 = new ASTAssignment(this, ParserTreeConstants.ASSIGNMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				PrimaryExpression();
				ConsumeToken(ParserConstants.EQUALS);
				Expression();
			}
			catch(Exception exception)
			{
				nodeTree.ClearNodeScope(jjtn000);
				jjtc000 = false;
				if (exception is SystemException)
				{
					throw;
				}
				if (exception is ParseException)
				{
					throw;
				}
				throw (ApplicationException) exception;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, 2);
				}
			}
		}

		public void ConditionalOrExpression()
		{
			ConditionalAndExpression();
			while(true)
			{
				if (GetCurrentTokenKind() != ParserConstants.LOGICAL_OR)
				{
					jj_la1[37] = jj_gen;
					//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
					goto label_13_brk;
				}
				ConsumeToken(ParserConstants.LOGICAL_OR);
				ASTOrNode jjtn001 = new ASTOrNode(this, ParserTreeConstants.OR_NODE);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					ConditionalAndExpression();
				}
				catch(Exception exception)
				{
					nodeTree.ClearNodeScope(jjtn001);
					jjtc001 = false;
					if (exception is SystemException)
					{
						throw;
					}
					if (exception is ParseException)
					{
						throw;
					}
					throw (ApplicationException) exception;
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, 2);
					}
				}
			}
			//UPGRADE_NOTE: Label 'label_13_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_13_brk:
			;
		}

		public void ConditionalAndExpression()
		{
			EqualityExpression();
			while(true)
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_AND:
						;
						break;

					default:
						jj_la1[38] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_14_brk;
				}
				ConsumeToken(ParserConstants.LOGICAL_AND);
				ASTAndNode jjtn001 = new ASTAndNode(this, ParserTreeConstants.AND_NODE);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					EqualityExpression();
				}
				catch(Exception exception)
				{
					nodeTree.ClearNodeScope(jjtn001);
					jjtc001 = false;
					if (exception is SystemException)
					{
						throw;
					}
					if (exception is ParseException)
					{
						throw;
					}
					throw (ApplicationException) exception;
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, 2);
					}
				}
			}
			//UPGRADE_NOTE: Label 'label_14_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_14_brk:
			;
		}

		public void EqualityExpression()
		{
			RelationalExpression();
			while(true)
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_EQUALS:
					case ParserConstants.LOGICAL_NOT_EQUALS:
						;
						break;

					default:
						jj_la1[39] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_15_brk;
				}
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_EQUALS:
						ConsumeToken(ParserConstants.LOGICAL_EQUALS);
						ASTEQNode jjtn001 = new ASTEQNode(this, ParserTreeConstants.EQ_NODE);
						bool jjtc001 = true;
						nodeTree.OpenNodeScope(jjtn001);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							RelationalExpression();
						}
						catch(Exception exception)
						{
							nodeTree.ClearNodeScope(jjtn001);
							jjtc001 = false;
							if (exception is SystemException)
							{
								throw;
							}
							if (exception is ParseException)
							{
								throw;
							}
							throw (ApplicationException) exception;
						}
						finally
						{
							if (jjtc001)
							{
								nodeTree.CloseNodeScope(jjtn001, 2);
							}
						}
						break;

					case ParserConstants.LOGICAL_NOT_EQUALS:
						ConsumeToken(ParserConstants.LOGICAL_NOT_EQUALS);
						ASTNENode jjtn002 = new ASTNENode(this, ParserTreeConstants.NE_NODE);
						bool jjtc002 = true;
						nodeTree.OpenNodeScope(jjtn002);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							RelationalExpression();
						}
						catch(Exception exception)
						{
							nodeTree.ClearNodeScope(jjtn002);
							jjtc002 = false;
							if (exception is SystemException)
							{
								throw;
							}
							if (exception is ParseException)
							{
								throw;
							}
							throw (ApplicationException) exception;
						}
						finally
						{
							if (jjtc002)
							{
								nodeTree.CloseNodeScope(jjtn002, 2);
							}
						}
						break;

					default:
						jj_la1[40] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
			}
			//UPGRADE_NOTE: Label 'label_15_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_15_brk:
			;
		}

		public void RelationalExpression()
		{
			AdditiveExpression();
			while(true)
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_LT:
					case ParserConstants.LOGICAL_LE:
					case ParserConstants.LOGICAL_GT:
					case ParserConstants.LOGICAL_GE:
						;
						break;

					default:
						jj_la1[41] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_16_brk;
				}
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_LT:
						ConsumeToken(ParserConstants.LOGICAL_LT);
						ASTLTNode jjtn001 = new ASTLTNode(this, ParserTreeConstants.LT_NODE);
						bool jjtc001 = true;
						nodeTree.OpenNodeScope(jjtn001);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							AdditiveExpression();
						}
						catch(Exception jjte001)
						{
							nodeTree.ClearNodeScope(jjtn001);
							jjtc001 = false;
							if (jjte001 is SystemException)
							{
								throw;
							}
							if (jjte001 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte001;
						}
						finally
						{
							if (jjtc001)
							{
								nodeTree.CloseNodeScope(jjtn001, 2);
							}
						}
						break;

					case ParserConstants.LOGICAL_GT:
						ConsumeToken(ParserConstants.LOGICAL_GT);
						ASTGTNode jjtn002 = new ASTGTNode(this, ParserTreeConstants.GT_NODE);
						bool jjtc002 = true;
						nodeTree.OpenNodeScope(jjtn002);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							AdditiveExpression();
						}
						catch(Exception jjte002)
						{
							nodeTree.ClearNodeScope(jjtn002);
							jjtc002 = false;
							if (jjte002 is SystemException)
							{
								throw;
							}
							if (jjte002 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte002;
						}
						finally
						{
							if (jjtc002)
							{
								nodeTree.CloseNodeScope(jjtn002, 2);
							}
						}
						break;

					case ParserConstants.LOGICAL_LE:
						ConsumeToken(ParserConstants.LOGICAL_LE);
						ASTLENode jjtn003 = new ASTLENode(this, ParserTreeConstants.LE_NODE);
						bool jjtc003 = true;
						nodeTree.OpenNodeScope(jjtn003);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							AdditiveExpression();
						}
						catch(Exception jjte003)
						{
							nodeTree.ClearNodeScope(jjtn003);
							jjtc003 = false;
							if (jjte003 is SystemException)
							{
								throw;
							}
							if (jjte003 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte003;
						}
						finally
						{
							if (jjtc003)
							{
								nodeTree.CloseNodeScope(jjtn003, 2);
							}
						}
						break;

					case ParserConstants.LOGICAL_GE:
						ConsumeToken(ParserConstants.LOGICAL_GE);
						ASTGENode jjtn004 = new ASTGENode(this, ParserTreeConstants.GE_NODE);
						bool jjtc004 = true;
						nodeTree.OpenNodeScope(jjtn004);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							AdditiveExpression();
						}
						catch(Exception jjte004)
						{
							nodeTree.ClearNodeScope(jjtn004);
							jjtc004 = false;
							if (jjte004 is SystemException)
							{
								throw;
							}
							if (jjte004 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte004;
						}
						finally
						{
							if (jjtc004)
							{
								nodeTree.CloseNodeScope(jjtn004, 2);
							}
						}
						break;

					default:
						jj_la1[42] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
			}
			//UPGRADE_NOTE: Label 'label_16_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_16_brk:
			;
		}

		public void AdditiveExpression()
		{
			MultiplicativeExpression();
			while(true)
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.MINUS:
					case ParserConstants.PLUS:
						;
						break;

					default:
						jj_la1[43] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_17_brk;
				}
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.PLUS:
						ConsumeToken(ParserConstants.PLUS);
						ASTAddNode jjtn001 = new ASTAddNode(this, ParserTreeConstants.ADD_NODE);
						bool jjtc001 = true;
						nodeTree.OpenNodeScope(jjtn001);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							MultiplicativeExpression();
						}
						catch(Exception jjte001)
						{
							nodeTree.ClearNodeScope(jjtn001);
							jjtc001 = false;
							if (jjte001 is SystemException)
							{
								throw;
							}
							if (jjte001 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte001;
						}
						finally
						{
							if (jjtc001)
							{
								nodeTree.CloseNodeScope(jjtn001, 2);
							}
						}
						break;

					case ParserConstants.MINUS:
						ConsumeToken(ParserConstants.MINUS);
						ASTSubtractNode jjtn002 = new ASTSubtractNode(this, ParserTreeConstants.SUBTRACT_NODE);
						bool jjtc002 = true;
						nodeTree.OpenNodeScope(jjtn002);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							MultiplicativeExpression();
						}
						catch(Exception jjte002)
						{
							nodeTree.ClearNodeScope(jjtn002);
							jjtc002 = false;
							if (jjte002 is SystemException)
							{
								throw;
							}
							if (jjte002 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte002;
						}
						finally
						{
							if (jjtc002)
							{
								nodeTree.CloseNodeScope(jjtn002, 2);
							}
						}
						break;

					default:
						jj_la1[44] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
			}
			//UPGRADE_NOTE: Label 'label_17_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_17_brk:
			;
		}

		public void MultiplicativeExpression()
		{
			UnaryExpression();
			while(true)
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.MULTIPLY:
					case ParserConstants.DIVIDE:
					case ParserConstants.MODULUS:
						;
						break;

					default:
						jj_la1[45] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_18_brk;
				}
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.MULTIPLY:
						ConsumeToken(ParserConstants.MULTIPLY);
						ASTMulNode jjtn001 = new ASTMulNode(this, ParserTreeConstants.MUL_NODE);
						bool jjtc001 = true;
						nodeTree.OpenNodeScope(jjtn001);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							UnaryExpression();
						}
						catch(Exception jjte001)
						{
							nodeTree.ClearNodeScope(jjtn001);
							jjtc001 = false;
							if (jjte001 is SystemException)
							{
								throw;
							}
							if (jjte001 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte001;
						}
						finally
						{
							if (jjtc001)
							{
								nodeTree.CloseNodeScope(jjtn001, 2);
							}
						}
						break;

					case ParserConstants.DIVIDE:
						ConsumeToken(ParserConstants.DIVIDE);
						ASTDivNode jjtn002 = new ASTDivNode(this, ParserTreeConstants.DIV_NODE);
						bool jjtc002 = true;
						nodeTree.OpenNodeScope(jjtn002);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							UnaryExpression();
						}
						catch(Exception jjte002)
						{
							nodeTree.ClearNodeScope(jjtn002);
							jjtc002 = false;
							if (jjte002 is SystemException)
							{
								throw;
							}
							if (jjte002 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte002;
						}
						finally
						{
							if (jjtc002)
							{
								nodeTree.CloseNodeScope(jjtn002, 2);
							}
						}
						break;

					case ParserConstants.MODULUS:
						ConsumeToken(ParserConstants.MODULUS);
						ASTModNode jjtn003 = new ASTModNode(this, ParserTreeConstants.MOD_NODE);
						bool jjtc003 = true;
						nodeTree.OpenNodeScope(jjtn003);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							UnaryExpression();
						}
						catch(Exception jjte003)
						{
							nodeTree.ClearNodeScope(jjtn003);
							jjtc003 = false;
							if (jjte003 is SystemException)
							{
								throw;
							}
							if (jjte003 is ParseException)
							{
								throw;
							}
							throw (ApplicationException) jjte003;
						}
						finally
						{
							if (jjtc003)
							{
								nodeTree.CloseNodeScope(jjtn003, 2);
							}
						}
						break;

					default:
						jj_la1[46] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
			}
			//UPGRADE_NOTE: Label 'label_18_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_18_brk:
			;
		}

		public void UnaryExpression()
		{
			if (jj_2_11(2))
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[47] = jj_gen;
						;
						break;
				}
				ConsumeToken(ParserConstants.LOGICAL_NOT);
				ASTNotNode jjtn001 = new ASTNotNode(this, ParserTreeConstants.NOT_NODE);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					UnaryExpression();
				}
				catch(Exception jjte001)
				{
					nodeTree.ClearNodeScope(jjtn001);
					jjtc001 = false;
					if (jjte001 is SystemException)
					{
						throw;
					}
					if (jjte001 is ParseException)
					{
						throw;
					}
					throw (ApplicationException) jjte001;
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, 1);
					}
				}
			}
			else
			{
				switch(GetCurrentTokenKind())
				{
					case ParserConstants.LBRACKET:
					case ParserConstants.LPAREN:
					case ParserConstants.WHITESPACE:
					case ParserConstants.STRING_LITERAL:
					case ParserConstants.TRUE:
					case ParserConstants.FALSE:
					case ParserConstants.NUMBER_LITERAL:
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						PrimaryExpression();
						break;

					default:
						jj_la1[48] = jj_gen;
						ConsumeToken(-1);
						throw new ParseException();
				}
			}
		}

		public void PrimaryExpression()
		{
			switch(GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[49] = jj_gen;
					break;
			}
			switch(GetCurrentTokenKind())
			{
				case ParserConstants.STRING_LITERAL:
					StringLiteral();
					break;

				case ParserConstants.NUMBER_LITERAL:
					NumberLiteral();
					break;

				case ParserConstants.IDENTIFIER:
				case ParserConstants.LCURLY:
					Reference();
					break;

				default:
					jj_la1[50] = jj_gen;
					if (jj_2_12(2147483647))
					{
						IntegerRange();
					}
					else
					{
						switch(GetCurrentTokenKind())
						{
							case ParserConstants.LBRACKET:
								ObjectArray();
								break;

							case ParserConstants.TRUE:
								True();
								break;

							case ParserConstants.FALSE:
								False();
								break;

							case ParserConstants.LPAREN:
								ConsumeToken(ParserConstants.LPAREN);
								Expression();
								ConsumeToken(ParserConstants.RPAREN);
								break;

							default:
								jj_la1[51] = jj_gen;
								ConsumeToken(-1);
								throw new ParseException();
						}
					}
					break;
			}
			switch(GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[52] = jj_gen;
					;
					break;
			}
		}

		private bool jj_3R_52()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_2_1(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3R_50(jj_3R_19());
			Save(0, xla);
			return retval;
		}

		private bool jj_2_2(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_2();
			Save(1, xla);
			return retval;
		}

		private bool jj_2_3(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_3();
			Save(2, xla);
			return retval;
		}

		private bool jj_2_4(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_4();
			Save(3, xla);
			return retval;
		}

		private bool jj_2_5(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_7();
			Save(4, xla);
			return retval;
		}

		private bool jj_2_6(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3R_50(jj_3R_29());
			Save(5, xla);
			return retval;
		}

		private bool jj_2_7(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_7();
			Save(6, xla);
			return retval;
		}

		private bool jj_2_8(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3R_50(jj_3R_29());
			Save(7, xla);
			return retval;
		}

		private bool jj_2_9(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3R_52();
			Save(8, xla);
			return retval;
		}

		private bool jj_2_10(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_10();
			Save(9, xla);
			return retval;
		}

		private bool jj_2_11(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_11();
			Save(10, xla);
			return retval;
		}

		private bool jj_2_12(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_12();
			Save(11, xla);
			return retval;
		}

		private bool jj_3R_58()
		{
			if (ScanToken(ParserConstants.TRUE))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_42()
		{
			if (jj_3R_54())
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3R_100(ParserConstants.COMMA, jj_3R_54()))
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}

		private bool jj_3_7()
		{
			if (ScanToken(ParserConstants.DOT))
				return true;
			if (ToRefactor1())
				return false;
			Token xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_29()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_41()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_39()
		{
			if (ScanToken(ParserConstants.LCURLY))
				return true;
			if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.IDENTIFIER))
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3_7())
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			if (ScanToken(ParserConstants.RCURLY))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3_12()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (ToRefactor1())
				return false;
			Token xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_19()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_40()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.DOUBLEDOT))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_38()
		{
			if (ScanToken(ParserConstants.IDENTIFIER))
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3_7())
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}


		private bool jj_3R_19()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_38())
			{
				jj_scanpos = xsp;
				if (jj_3R_39())
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_41()
		{
			if (ScanToken(ParserConstants.IDENTIFIER))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_50(bool b)
		{
			if (b)
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3_4()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (ToRefactor1())
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_19()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_40()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.DOUBLEDOT))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_29()
		{
			if (jj_3R_41())
				return true;
			if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.LPAREN))
				return true;
			if (ToRefactor1())
				return false;
			Token xsp = jj_scanpos;
			if (jj_3R_42())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.REFMOD2_RPAREN))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_31()
		{
			Token xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_55()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_40()))
				{
					jj_scanpos = xsp;
					if (jj_3R_50(jj_3R_19()))
					{
						jj_scanpos = xsp;
						if (jj_3R_50(jj_3R_56()))
						{
							jj_scanpos = xsp;
							if (jj_3R_50(jj_3R_57()))
							{
								jj_scanpos = xsp;
								if (jj_3R_50(jj_3R_58()))
								{
									jj_scanpos = xsp;
									if (jj_3R_50(jj_3R_59()))
									{
										jj_scanpos = xsp;
										if (jj_3R_51())
											return true;
										if (ToRefactor1())
											return false;
									}
									else if (ToRefactor1())
										return false;
								}
								else if (ToRefactor1())
									return false;
							}
							else if (ToRefactor1())
								return false;
						}
						else if (ToRefactor1())
							return false;
					}
					else if (ToRefactor1())
						return false;
				}
				else if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_33()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3_11())
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_31()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3_11()
		{
			Token xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.LOGICAL_NOT))
				return true;
			if (ToRefactor1())
				return false;
			if (jj_3R_33())
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_101()
		{
			Token xsp = jj_scanpos;
			if (jj_3R_100(ParserConstants.MULTIPLY, jj_3R_33()))
			{
				jj_scanpos = xsp;
				if (jj_3R_100(ParserConstants.DIVIDE, jj_3R_33()))
				{
					jj_scanpos = xsp;
					if (jj_3R_100(ParserConstants.MODULUS, jj_3R_33()))
						return true;
					if (ToRefactor1())
						return false;
				}
				else if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_55()
		{
			if (ScanToken(ParserConstants.STRING_LITERAL))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_40()
		{
			if (ScanToken(ParserConstants.NUMBER_LITERAL))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_95()
		{
			if (jj_3R_33())
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3R_101())
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}


		private bool jj_3R_54()
		{
			Token xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_55()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_56()))
				{
					jj_scanpos = xsp;
					if (jj_3R_50(jj_3R_57()))
					{
						jj_scanpos = xsp;
						if (jj_3R_50(jj_3R_58()))
						{
							jj_scanpos = xsp;
							if (jj_3R_50(jj_3R_59()))
							{
								jj_scanpos = xsp;
								if (jj_3R_50(jj_3R_19()))
								{
									jj_scanpos = xsp;
									if (jj_3R_50(jj_3R_40()))
										return true;
									if (ToRefactor1())
										return false;
								}
								else if (ToRefactor1())
									return false;
							}
							else if (ToRefactor1())
								return false;
						}
						else if (ToRefactor1())
							return false;
					}
					else if (ToRefactor1())
						return false;
				}
				else if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_96()
		{
			Token xsp = jj_scanpos;
			if (jj_3R_100(ParserConstants.PLUS, jj_3R_95()))
			{
				jj_scanpos = xsp;
				if (jj_3R_100(ParserConstants.MINUS, jj_3R_95()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_91()
		{
			if (jj_3R_95())
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3R_96())
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}

		//TODO: refactor usages of this method
		private bool jj_3R_100(int ge, bool r_91)
		{
			if (ScanToken(ge))
				return true;
			if (ToRefactor1())
				return false;
			if (r_91)
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_51()
		{
			if (ScanToken(ParserConstants.LPAREN))
				return true;
			if (ToRefactor1())
				return false;
			if (jj_3R_60())
				return true;
			if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.RPAREN))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_77()
		{
			if (jj_3R_54())
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3R_100(ParserConstants.COMMA, jj_3R_54()))
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}


		private bool jj_3R_92()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_100(ParserConstants.LOGICAL_LT, jj_3R_91()))
			{
				jj_scanpos = xsp;
				if (jj_3R_100(ParserConstants.LOGICAL_GT, jj_3R_91()))
				{
					jj_scanpos = xsp;
					if (jj_3R_100(ParserConstants.LOGICAL_LE, jj_3R_91()))
					{
						jj_scanpos = xsp;
						if (jj_3R_100(ParserConstants.LOGICAL_GE, jj_3R_91()))
							return true;
						if (ToRefactor1())
							return false;
					}
					else if (ToRefactor1())
						return false;
				}
				else if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_56()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (ToRefactor1())
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_19()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_40()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.DOUBLEDOT))
				return true;
			if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_19()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_40()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.RBRACKET))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_89()
		{
			if (jj_3R_91())
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3R_92())
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}


		private bool jj_3R_90()
		{
			Token xsp = jj_scanpos;
			if (jj_3R_100(ParserConstants.LOGICAL_EQUALS, jj_3R_89()))
			{
				jj_scanpos = xsp;
				if (jj_3R_100(ParserConstants.LOGICAL_NOT_EQUALS, jj_3R_89()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_57()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (ToRefactor1())
				return false;
			Token xsp = jj_scanpos;
			if (jj_3R_77())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.RBRACKET))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3R_86()
		{
			if (jj_3R_89())
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3R_90())
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}


		private bool jj_3R_84()
		{
			if (jj_3R_86())
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3R_100(ParserConstants.LOGICAL_AND, jj_3R_86()))
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}


		private bool jj_3_2()
		{
			if (ScanToken(ParserConstants.DOUBLE_ESCAPE))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		private bool jj_3_10()
		{
			if (jj_3R_31())
				return true;
			if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.EQUALS))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		//TODO: not sure what this does
		private bool ToRefactor1()
		{
			return jj_la == 0 && jj_scanpos == jj_lastpos;
		}

		private bool jj_3R_82()
		{
			if (jj_3R_84())
				return true;
			if (ToRefactor1())
				return false;
			while(true)
			{
				Token xsp = jj_scanpos;
				if (jj_3R_100(ParserConstants.LOGICAL_OR, jj_3R_84()))
				{
					jj_scanpos = xsp;
					break;
				}
				if (ToRefactor1())
					return false;
			}
			return false;
		}

		private bool jj_3R_81()
		{
			if (jj_3R_31())
				return true;
			if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.EQUALS))
				return true;
			if (ToRefactor1())
				return false;
			if (jj_3R_60())
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_60()
		{
			Token xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_81()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_82()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3_3()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (ToRefactor1())
				return false;
			Token xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_50(jj_3R_19()))
			{
				jj_scanpos = xsp;
				if (jj_3R_50(jj_3R_40()))
					return true;
				if (ToRefactor1())
					return false;
			}
			else if (ToRefactor1())
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (ToRefactor1())
				return false;
			if (ScanToken(ParserConstants.DOUBLEDOT))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}


		private bool jj_3R_59()
		{
			if (ScanToken(ParserConstants.FALSE))
				return true;
			if (ToRefactor1())
				return false;
			return false;
		}

		public Parser(ICharStream stream)
		{
			InitBlock();
			token_source = new ParserTokenManager(stream);
			token = new Token();
			jj_ntk_Renamed_Field = -1;
			jj_gen = 0;
			for(int i = 0; i < 53; i++)
				jj_la1[i] = -1;
			for(int i = 0; i < callsArray.Length; i++)
				callsArray[i] = new Calls();
		}

		public void ReInit(ICharStream stream)
		{
			token_source.ReInit(stream);
			token = new Token();
			jj_ntk_Renamed_Field = -1;
			nodeTree.Reset();
			jj_gen = 0;
			for(int i = 0; i < 53; i++)
				jj_la1[i] = -1;
			for(int i = 0; i < callsArray.Length; i++)
				callsArray[i] = new Calls();
		}

		public Parser(ParserTokenManager tm)
		{
			InitBlock();
			token_source = tm;
			token = new Token();
			jj_ntk_Renamed_Field = -1;
			jj_gen = 0;
			for(int i = 0; i < 53; i++)
				jj_la1[i] = -1;
			for(int i = 0; i < callsArray.Length; i++)
				callsArray[i] = new Calls();
		}

		public void ReInit(ParserTokenManager tm)
		{
			token_source = tm;
			token = new Token();
			jj_ntk_Renamed_Field = -1;
			nodeTree.Reset();
			jj_gen = 0;
			for(int i = 0; i < 53; i++)
				jj_la1[i] = -1;
			for(int i = 0; i < callsArray.Length; i++)
				callsArray[i] = new Calls();
		}

		private Token ConsumeToken(int kind)
		{
			Token oldToken = token;
			if (token.Next == null)
			{
				token = token.Next = token_source.NextToken;
			}
			else
			{
				token = token.Next;
			}
			jj_ntk_Renamed_Field = -1;
			if (token.Kind == kind)
			{
				jj_gen++;
				if (++jj_gc > 100)
				{
					jj_gc = 0;
					for(int i = 0; i < callsArray.Length; i++)
					{
						Calls c = callsArray[i];
						while(c != null)
						{
							if (c.Gen < jj_gen)
								c.First = null;
							c = c.Next;
						}
					}
				}
				return token;
			}
			token = oldToken;
			jj_kind = kind;
			throw GenerateParseException();
		}

		private int jj_ntk()
		{
			if ((jj_nt = token.Next) == null)
			{
				return (jj_ntk_Renamed_Field = (token.Next = token_source.NextToken).Kind);
			}
			else
			{
				return (jj_ntk_Renamed_Field = jj_nt.Kind);
			}
		}

		private bool ScanToken(int kind)
		{
			if (jj_scanpos == jj_lastpos)
			{
				jj_la--;
				if (jj_scanpos.Next == null)
				{
					jj_lastpos = jj_scanpos = jj_scanpos.Next = token_source.NextToken;
				}
				else
				{
					jj_lastpos = jj_scanpos = jj_scanpos.Next;
				}
			}
			else
			{
				jj_scanpos = jj_scanpos.Next;
			}
			if (jj_rescan)
			{
				int i = 0;
				Token tok = token;
				while(tok != null && tok != jj_scanpos)
				{
					i++;
					tok = tok.Next;
				}
				if (tok != null)
				{
					AddErrorToken(kind, i);
				}
			}
			return (jj_scanpos.Kind != kind);
		}


		public Token GetToken(int index)
		{
			Token t = lookingAhead ? jj_scanpos : token;
			for(int i = 0; i < index; i++)
			{
				if (t.Next == null)
				{
					t = t.Next = token_source.NextToken;
				}
				else
				{
					t = t.Next;
				}
			}
			return t;
		}


		private void AddErrorToken(int kind, int position)
		{
			if (position >= 100)
			{
				return;
			}
			if (position == endPosition + 1)
			{
				lastTokens[endPosition++] = kind;
			}
			else if (endPosition != 0)
			{
				jj_expEntry = new int[endPosition];
				for(int i = 0; i < endPosition; i++)
				{
					jj_expEntry[i] = lastTokens[i];
				}
				bool exists = false;
				//UPGRADE_TODO: method 'java.util.Enumeration.hasMoreElements' was converted to ' ' which has a different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1073_javautilEnumerationhasMoreElements"'
				for(IEnumerator enumerator = expEntries.GetEnumerator(); enumerator.MoveNext();)
				{
					//UPGRADE_TODO: method 'java.util.Enumeration.nextElement' was converted to ' ' which has a different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1073_javautilEnumerationnextElement"'
					int[] oldEntry = (int[]) (enumerator.Current);
					if (oldEntry.Length == jj_expEntry.Length)
					{
						exists = true;
						for(int i = 0; i < jj_expEntry.Length; i++)
						{
							if (oldEntry[i] != jj_expEntry[i])
							{
								exists = false;
								break;
							}
						}
						if (exists)
							break;
					}
				}
				if (!exists)
				{
					expEntries.Add(jj_expEntry);
				}
				if (position != 0)
				{
					lastTokens[(endPosition = position) - 1] = kind;
				}
			}
		}

		public ParseException GenerateParseException()
		{
			ArrayList temp_arraylist;
			temp_arraylist = expEntries;
			temp_arraylist.RemoveRange(0, temp_arraylist.Count);
			bool[] la1tokens = new bool[62];
			for(int i = 0; i < 62; i++)
			{
				la1tokens[i] = false;
			}
			if (jj_kind >= 0)
			{
				la1tokens[jj_kind] = true;
				jj_kind = -1;
			}
			for(int i = 0; i < 53; i++)
			{
				if (jj_la1[i] == jj_gen)
				{
					for(int j = 0; j < 32; j++)
					{
						if ((jj_la1_0[i] & (1 << j)) != 0)
						{
							la1tokens[j] = true;
						}
						if ((jj_la1_1[i] & (1 << j)) != 0)
						{
							la1tokens[32 + j] = true;
						}
					}
				}
			}
			for(int i = 0; i < 62; i++)
			{
				if (la1tokens[i])
				{
					jj_expEntry = new int[1];
					jj_expEntry[0] = i;
					expEntries.Add(jj_expEntry);
				}
			}
			endPosition = 0;
			RescanToken();
			AddErrorToken(0, 0);
			int[][] exptokseq = new int[expEntries.Count][];
			for(int i = 0; i < expEntries.Count; i++)
			{
				exptokseq[i] = (int[]) expEntries[i];
			}
			return new ParseException(token, exptokseq, ParserConstants.TokenImage);
		}


		private void RescanToken()
		{
			jj_rescan = true;
			for(int i = 0; i < 12; i++)
			{
				Calls p = callsArray[i];
				do
				{
					if (p.Gen > jj_gen)
					{
						jj_la = p.Arg;
						jj_lastpos = jj_scanpos = p.First;
						switch(i)
						{
							case 0:
								jj_3R_50(jj_3R_19());
								break;

							case 1:
								jj_3_2();
								break;

							case 2:
								jj_3_3();
								break;

							case 3:
								jj_3_4();
								break;

							case 4:
								jj_3_7();
								break;

							case 5:
								jj_3R_50(jj_3R_29());
								break;

							case 6:
								jj_3_7();
								break;

							case 7:
								jj_3R_50(jj_3R_29());
								break;

							case 8:
								jj_3R_52();
								break;

							case 9:
								jj_3_10();
								break;

							case 10:
								jj_3_11();
								break;

							case 11:
								jj_3_12();
								break;
						}
					}
					p = p.Next;
				} while(p != null);
			}
			jj_rescan = false;
		}

		private void Save(int index, int xla)
		{
			Calls calls = callsArray[index];
			while(calls.Gen > jj_gen)
			{
				if (calls.Next == null)
				{
					calls = calls.Next = new Calls();
					break;
				}
				calls = calls.Next;
			}
			calls.Gen = jj_gen + xla - jj_la;
			calls.First = token;
			calls.Arg = xla;
		}

		private sealed class Calls
		{
			internal int Gen;
			internal Token First;
			internal int Arg;
			internal Calls Next;
		}
	}
}