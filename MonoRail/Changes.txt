Change history
--------------

Release Candidate 1
===================

- Fixed a bug with Brail not picking up changes that occured by VS.Net

- Fixed bug with NVelocity components that caused an InvalidCastException to be thrown by the Render method if there was something other than an IRailsEngineContext occupying the "context" key.

- MonoRail is now CLSCompliant (kudos to Roelof Blom <roelof.blom@gmail.com>)

- Breaking change: now MonoRail requires that you add the following module to web.config:

	<system.web>
		<httpModules>
			<add name="monorail" type="Castle.MonoRail.Framework.EngineContextModule, Castle.MonoRail.Framework" />
		</httpModules>
	</system.web>

- Configuration nodes and attributes changes:
  - mailto to mailTo 
  - mailfrom to mailFrom
  - customsession to customSession

- SmartViewComponent removed

- DataBinder refactored out. Now implementation lies on Castle.Components.Binder
  Big performance improvement

- ARDataBinder now issues a FindByPK for nested objects if the keys differs (existing object with 
  form fields)

- SmartDispatcher: now there's no hardcode reference to DataBind, ARDataBind or ARFetch attributes. 
  They only must implement the interface IParameterBinding. This opens an interesting extension point
  for users willing to create their own logic to binding form/querystring parameters to their data components

- Controller: Added RedirectToAction(String action, params String[] queryStringParameters)
  example:  RedirectToAction("edit", "id=" + id, "error=couldn't update the row");

- Added FlashBinderAttribute (being evaluated)

- Added FormHelper (being evaluated)

- Added CaptureFor component

- Renamed ARPager splitted into ARPaginationHelper and ARPager

- ARDataBinder is now able to deal with HasAndBelongsToMany relations. 
  This works in two ways. Suppose you have a Product class with a relation HasAndBelongsToMany to Category.
  
  If you send the following fields from a form:
    
    product.categories.id=1 
    product.categories.id=2
    
  ARDataBinder will ignore the AutoLoad property and always populate the Categories 
  collection on the product class with the result of FindByPrimaryKey of the categories.
  Any other field will be ignored, for example product.categories.name will not be bound
  
  However, if you send the values like
  
    product.categories[0].id=1 
    product.categories[1].id=2
    
  Then ARDataBinder will use the usual path, not ignoring the AutoLoad.
  
  This behavior is being evaluated.

- Removed AbstractExtension

- Extension now uses events (See ExtensionManager)

- Interface IMonoRailExtension changed (has only Init method now)

- Refactored IParameterBinder in order to make it participate on calculations points.

- Introduced WindsorMonoRailSectionHandler which has the support for statements similar to those supported
  by windsor's XmlInterpreter
  
- Added ARDataBindAttribute.NullWhenPrimaryKey which forces the databinder to
  ignore and do not load a record if the retrieved PK has the value assigned to this
  property (kudos to Roelof Blom <roelof.blom@gmail.com>)

Beta 5
======

** Core ** 

- Fixed Flash (it now persists the new entries between requests)  (by Ahmed)

- Added FilterAttribute.ExecutionOrder, the default value is Int32.MaxValue 
  so the less the value higher will be the filter priority

- Added Controller.RedirectToAction(String actionName)

- Added Controller.RedirectToAction overloads (by Fabio Batista)

- Controller.Redirect(String) is now virtual, and it's called by all Redirect* methods (by Fabio Batista)

- Moved action collection to ControllerMetaDescriptor class, using new method that does not require ScreenCommonPublicMethods.

- Moved ControllerDescriptorBuilder creation to ProcessEngineFactory to ensure ControllerDescriptors are only created once

- ITrace and Trace property added to IRailsEngineContext (kudos to Chad Humphries)

- Hierarchy of areas support (kudos to Fabio Batista)

- Support for [Layout] attribute on Actions, so actions can override 
  the Controller's specified layout (by Fabio Batista, rev 1459)

- PaginationHelper introduced: paginates objects that implements IList, and supports caching.

- ARPager introduced: allows you to specify a custom NHibernate HQL Query or an NHibernate Criteria
  (using Expression.Eq, à là ActiveRecord's FindAll()) and fetch the results with pagination.
  (by Fabio Batista)

- Added IServerUtility.JavaScriptEscape() (kudos to Chad Humphries)

- Added DataBindAttribute.Exclude - A comma separated list of property names 
  to exclude from databinding (kudos to Chad Humphries)

- Added IResponse.BinaryWrite() and CreateCookie( HttpCookie ) overload

- Added IServerUtility.MapPath()

- Added IRailsContext.ApplicationPhysicalPath

- Added to HtmlHelper:
  - InputCheckbox
  
  - InputRadio
  - InputFile
  - InputButton
  - Form(action, attribtes) overload

- Added more fine-grained support for ExecuteEnum in Filters (by Fabio Batista, rev 1286-1287)

    The values are now: BeforeAction, AfterAction, AfterRendering and Always.
  
- Support for nullable types in SmartDispatcherController, useful for
  detecting missing ValueType parameters. Works with Nullables library, still
  not working on .NET 2.0 Nullables (by Fabio Batista, rev 1297 and 1363)

  Example of use:

    // .NET 1.1
    public void CreateTicket(string name, NullableDateTime date, NullableInt32 priority)
    {
      if (name == null || name.Length == 0) throw new MissingFieldException();
      if (!date.HasValue) throw new MissingFieldException();
      if (!priority.HasValue) throw new MissingFieldException();
    }

    // .NET 2.0 (NOT WORKING YET)
    public void CreateTicket(string name, DateTime? date, int? priority)
    {
      if (name == null || name.Length == 0) throw new MissingFieldException();
      if (!date.HasValue) throw new MissingFieldException();
      if (!priority.HasValue) throw new MissingFieldException();
    }

- Broaded support for Enums. They can be specified by number or by text (by Fabio Batista, rev 1203)

  public enum MyEnum {
    First = 1,
    Second = 2
  }
  
  <input type="hidden" name="myEnumValue" value="1" />
  <input type="hidden" name="myOtherEnumValue" value="seCoNd" />
  
  public void TestEnumValues(MyEnum myEnumValue, MyEnum myOtherEnumValue)
  {
    if (myEnumValue == MyEnum.First) // ok
    if (myOtherEnumValue == MyEnum.Second) // ok
  }

- Support for Active Record fetching in Castle.MonoRail.ActiveRecordSupport
  (by Fabio Batista, rev. 1380).
	
	Mainly for those unconfortable with direct binding of form values
	to ActiveRecord objects. This attribute only fetches the ActiveRecord based
	on its Primary Key, nothing more.
	
	Usage:
	
		public class MyCrudExample : ARSmartDispatchController
		{
			// simple usage.
			public void Save( [ARFetch] Example example, string name, ...)
			{
				example.Name = name;
				// ...
				
				example.Save();
			}

			// using a different request parameter, instead of the action's parameter name
			public void Save( [ARFetch("primaryKey")] Example example, string name, ...)
			{
				example.Name = name;
				// ...
				
				example.Save();
			}

			// ignoring invalid primary keys
			public void Save( [ARFetch(Require=false)] Example example, string name, ...)
			{
				example.Name = name;
				// ...
				
				example.Save();
			}

			// not creating new records automatically, when the parameter is empty or null
			public void Save( [ARFetch(Create=false)] Example example, string name, ...)
			{
				if (example == null)
					example = new Example(someRequiredConstructorParameter);
				
				example.Name = name;
				// ...
				
				example.Save();
			}

			// fetching a list of Active Records
			public void Delete( [ARFetch("selected")] Example[] examples )
			{
				foreach (Example example in examples)
					example.Delete();
			}
		}

- Support for smart arrays (aside from primitives) (kudos do Ahmed)

  Quoting the explanation:
  
Suppose you have this class:

 
class Person
{
  public string Name {get;set;}

  public int Age {get;set;}
}

With the following view 

  <input name="Person[0].Name"   value="John">
  <input name="Person[0].Age"    value="30">
  <input name="Person[1].Name"   value="Mary">
  <input name="Person[1].Age"    value="25">

Now you can specify the DataBinderAttribute to an array element in your controller:

public void SavePeople( [DataBinder(Prefix=”People”)] Person[] people )
{
  // you should be able to access the people as an Person array

  Assert.IsTrue( people[0].Name == “John” );
  Assert.IsTrue( people[1].Name == “Mary” );
}

There are a couple extra things, first you can specify an “ignore” attribute to any element in which that case the data binder will completely ignore the element

  <input name="Person[0].Name"   value="John">
  <input name="Person[0].Age"    value="30">
  <input name="Person[0]@ignore" value="yes">
  <input name="Person[1].Name"   value="Mary">
  <input name="Person[1].Age"    value="25">

In the previous html code, the people array in the controller will only have one element (Mary).

Notice that I reserved the @ sign as a special character to add metadata to any element, right now the only attributes supported are “ignore” and “count”.

The count attribute serves as a performance optimization when your elements are keyed using sequential integers, for example:

  <input name="Person@count"   value="5">
  <input name="Person[0].Name" value="John">
  <input name="Person[1].Name" value="James">
  <input name="Person[2].Name" value="Jeff">
  <input name="Person[3].Name" value="Geoff">
  <input name="Person[4].Name" value="Jeffrey">

** Ajax Helper **
   
- AjaxHelper2 renamed to AjaxHelper. The old one was renamed to AjaxHelperOld

- Two more callbacks supported: onSuccess and onFailure. For example

  $AjaxHelper.BuildFormRemoteTag( $DictHelper.CreateDict("url=something.rails", "OnSuccess=myjavascriptfunction();", "OnFailure=otherfunction(request)" ) );
  
  Do not confuse it with 'success' and 'failure' keys, though. Those means the id of elements
  to be updated in the event of success and failure.


** NVelocity View Engine **

- Added support for global macros. Every *.vm file which is placed in the Views/macros directory
  will be scanned for macros (by Fabio Batista, rev. 1374)

** Brail View Engine **

- Upgraded to use Boo 0.75, should solve the problem that Brail had with breaking tests.

** Scaffolding support **

- huge refactoring
- It's now using templates


** Test support **

- Introduced Castle.MonoRail.TestSupport


** Bug fixes **

MR-68	PreSendView is not being invoked by NVelocityViewEngine
        http://support.castleproject.org/jira/browse/MR-68
MR-66	DataBinder and ConvertUtils should support TypeConverters
        http://support.castleproject.org/jira/browse/MR-66
MR-64	DataBinder.Convert should support decimal
        http://support.castleproject.org/jira/browse/MR-64
MR-58	AbstractHelper generates invalid XHTML
        http://support.castleproject.org/jira/browse/MR-58
MR-57	Wrong urls are crashing UrlTokenizer
        http://support.castleproject.org/jira/browse/MR-57
MR-52	Support for real Flash feature
        http://support.castleproject.org/jira/browse/MR-52
MR-49	Remove public properties from the list of available actions (Controller.cs)
        http://support.castleproject.org/jira/browse/MR-49
MR-30	MR should not accept incorrect urls
        http://support.castleproject.org/jira/browse/MR-30


Beta 4
======

- Added useWindsorIntegration attribute to monoRail configuration section

Beta 3
======

- Databind
- Initial Scaffolding support
- Routing feature
- Localization support
- More helpers and improvements


Beta 2
====== 

- Few bug corrections
- Applied patch from Dru Sellers: NVelocityViewEngine adds a $siteRoot exposing the Request.ApplicationPath

