 /* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */

namespace NVelocity.Runtime.Parser
{
	using System;
	using System.Collections;
	using System.IO;
	using NVelocity.Exception;
	using NVelocity.Runtime.Directive;
	using NVelocity.Runtime.Parser.Node;
	using NVelocity.Util;

	/// <summary> This class is responsible for parsing a Velocity
	/// template. This class was generated by JavaCC using
	/// the JJTree extension to produce an Abstract
	/// Syntax Tree (AST) of the template.
	///
	/// Please look at the Parser.jjt file which is
	/// what controls the generation of this class.
	/// </summary>
	public class Parser
	{
		/*@bgen(jjtree)*/
		//UPGRADE_NOTE: The initialization of  'jjtree' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		internal ParserState nodeTree;

		/// <summary>  This Hashtable contains a list of all of the dynamic directives.
		/// </summary>
		//UPGRADE_NOTE: The initialization of  'directives' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private IDirectiveManager directives;

		/// <summary>  Name of current template we are parsing.  Passed to us in parse()
		/// </summary>
		internal String currentTemplateName = "";

		internal VelocityCharStream velcharstream = null;

		private IRuntimeServices rsvc = null;

		///
		/// <summary> This constructor was added to allow the re-use of parsers.
		/// The normal constructor takes a single argument which
		/// an InputStream. This simply creates a re-usable parser
		/// object, we satisfy the requirement of an InputStream
		/// by using a newline character as an input stream.
		/// </summary>
		public Parser(IRuntimeServices rs) : this(new VelocityCharStream(new StringReader("\n"), 1, 1))
		{
			InitBlock();

			/*
			* now setup a VCS for later use
			*/
			velcharstream = new VelocityCharStream(new StringReader("\n"), 1, 1);

			/*
			*  and save the RuntimeServices
			*/
			rsvc = rs;
		}

		private void InitBlock()
		{
			nodeTree = new ParserState();
			directives = null;
			jj_la1 = new int[53];
			jj_2_rtns = new Calls[12];
			jj_expentries = new ArrayList();
			jj_lasttokens = new int[100];
		}

		public IDirectiveManager Directives
		{
			set { this.directives = value; }
		}

		public Token NextToken
		{
			get
			{
				if (token.Next != null)
					token = token.Next;
				else
					token = token.Next = token_source.NextToken;
				jj_ntk_Renamed_Field = - 1;
				jj_gen++;
				return token;
			}
		}

		///
		/// <summary> This was also added to allow parsers to be
		/// re-usable. Normal JavaCC use entails passing an
		/// input stream to the constructor and the parsing
		/// process is carried out once. We want to be able
		/// to re-use parsers: we do this by adding this
		/// method and re-initializing the lexer with
		/// the new stream that we want parsed.
		/// </summary>
		public SimpleNode Parse(TextReader reader, String templateName)
		{
			SimpleNode sn = null;

			currentTemplateName = templateName;

			try
			{
				token_source.ClearStateVars();

				/*
				*  reinitialize the VelocityCharStream
				*  with the new reader
				*/
				velcharstream.ReInit(reader, 1, 1);

				/*
				* now reinit the Parser with this CharStream
				*/
				ReInit(velcharstream);

				/*
				*  do that voodoo...
				*/
				sn = Process();
			}
			catch (ParseException pe)
			{
				rsvc.Error("Parser Exception: " + templateName + " : " + StringUtils.StackTrace(pe));
				throw ( pe.currentToken == null ) ? pe : new ParseException(pe.currentToken, pe.expectedTokenSequences, pe.tokenImage);
			}
			catch (TokenMgrError tme)
			{
				throw new ParseException("Lexical error: " + tme.ToString());
			}
			catch (Exception e)
			{
				rsvc.Error("Parser Error: " + templateName + " : " + StringUtils.StackTrace(e));
			}

			currentTemplateName = "";

			return sn;
		}

		/// <summary>  This method sets the directives Hashtable
		/// </summary>
		/// <summary>  This method gets a Directive from the directives Hashtable
		/// </summary>
		public Directive GetDirective(String directive)
		{
			return directives.Create(directive);
		}

		/// <summary>  This method finds out of the directive exists in the directives
		/// Hashtable.
		/// </summary>
		public bool IsDirective(String directive)
		{
			return (directives.Contains(directive));
		}

		/// <summary> Produces a processed output for an escaped control or
		/// pluggable directive
		/// </summary>
		private String EscapedDirective(String strImage)
		{
			int iLast = strImage.LastIndexOf("\\");

			String strDirective = strImage.Substring(iLast + 1);

			bool bRecognizedDirective = false;

			/*
	    *  is this a PD or a control directive?
	    */

			if (IsDirective(strDirective.Substring(1)))
			{
				bRecognizedDirective = true;
			}
			else if (rsvc.IsVelocimacro(strDirective.Substring(1), currentTemplateName))
			{
				bRecognizedDirective = true;
			}
			else
			{
				/* order for speed? */

				if (strDirective.Substring(1).Equals("if") || strDirective.Substring(1).Equals("end") || strDirective.Substring(1).Equals("set") || strDirective.Substring(1).Equals("else") || strDirective.Substring(1).Equals("elseif") || strDirective.Substring(1).Equals("stop"))
				{
					bRecognizedDirective = true;
				}
			}

			/*
	    *  if so, make the proper prefix string (let the escapes do their thing..)
	    *  otherwise, just return what it is..
	    */

			if (bRecognizedDirective)
				return (strImage.Substring(0, (iLast/2) - (0)) + strDirective);
			else
				return (strImage);
		}

		/// <summary> This method is what starts the whole parsing
		/// process. After the parsing is complete and
		/// the template has been turned into an AST,
		/// this method returns the root of AST which
		/// can subsequently be traversed by a visitor
		/// which implements the ParserVisitor interface
		/// which is generated automatically by JavaCC
		/// </summary>
		public SimpleNode Process()
		{
			/*@bgen(jjtree) process */
			ASTprocess jjtn000 = new ASTprocess(this, ParserTreeConstants.PROCESS);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				while (true)
				{
					switch (GetCurrentTokenKind())
					{
						case ParserConstants.LPAREN:
						case ParserConstants.RPAREN:
						case ParserConstants.ESCAPE_DIRECTIVE:
						case ParserConstants.SET_DIRECTIVE:
						case ParserConstants.DOUBLE_ESCAPE:
						case ParserConstants.ESCAPE:
						case ParserConstants.TEXT:
						case ParserConstants.SINGLE_LINE_COMMENT:
						case ParserConstants.FORMAL_COMMENT:
						case ParserConstants.MULTI_LINE_COMMENT:
						case ParserConstants.STRING_LITERAL:
						case ParserConstants.IF_DIRECTIVE:
						case ParserConstants.STOP_DIRECTIVE:
						case ParserConstants.NUMBER_LITERAL:
						case ParserConstants.WORD:
						case ParserConstants.IDENTIFIER:
						case ParserConstants.DOT:
						case ParserConstants.LCURLY:
						case ParserConstants.RCURLY:
							;
							break;

						default:
							jj_la1[0] = jj_gen;
							//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
							goto label_1_brk;

					}
					Statement();
				}
				//UPGRADE_NOTE: Label 'label_1_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
				label_1_brk:
				;

				ConsumeToken(0);
				nodeTree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				if (true)
					return jjtn000;

			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					if (true)
						throw (SystemException) jjte000;

				}
				if (jjte000 is ParseException)
				{
					if (true)
						throw (ParseException) jjte000;

				}

				throw;
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new ApplicationException("Missing return statement in function");
		}

		/// <summary> These are the types of statements that
		/// are acceptable in Velocity templates.
		/// </summary>
		public void Statement()
		{
			int kind = GetCurrentTokenKind();
			switch (kind)
			{
				case ParserConstants.IF_DIRECTIVE:
					IfStatement();
					break;

				case ParserConstants.STOP_DIRECTIVE:
					StopStatement();
					break;

				default:
					jj_la1[1] = jj_gen;
					if (jj_2_1(2))
					{
						Reference();
					}
					else
					{
						int kind2 = GetCurrentTokenKind();
						switch (kind2)
						{
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
								Comment();
								break;

							case ParserConstants.SET_DIRECTIVE:
								SetDirective();
								break;

							case ParserConstants.ESCAPE_DIRECTIVE:
								EscapedDirective();
								break;

							case ParserConstants.DOUBLE_ESCAPE:
								Escape();
								break;

							case ParserConstants.WORD:
								Directive();
								break;

							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								Text();
								break;

							default:
								jj_la1[2] = jj_gen;
								ConsumeToken(- 1);
								throw new ParseException();

						}
					}
					break;

			}
		}

		/// <summary>  used to separate the notion of a valid directive that has been
		/// escaped, versus something that looks like a directive and
		/// is just schmoo.  This is important to do as a separate production
		/// that creates a node, because we want this, in either case, to stop
		/// the further parsing of the Directive() tree.
		/// </summary>
		public void EscapedDirective()
		{
			/*@bgen(jjtree) EscapedDirective */
			ASTEscapedDirective jjtn000 = new ASTEscapedDirective(this, ParserTreeConstants.ESCAPED_DIRECTIVE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				Token t = null;
				t = ConsumeToken(ParserConstants.ESCAPE_DIRECTIVE);
				nodeTree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				/*
				*  churn and burn..
				*/
				t.Image = EscapedDirective(t.Image);
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary>  Used to catch and process escape sequences in grammatical constructs
		/// as escapes outside of VTL are just characters.  Right now we have both
		/// this and the EscapeDirective() construction because in the EscapeDirective()
		/// case, we want to suck in the #<directive> and here we don't.  We just want
		/// the escapes to render correctly
		/// </summary>
		public void Escape()
		{
			/*@bgen(jjtree) Escape */
			ASTEscape jjtn000 = new ASTEscape(this, ParserTreeConstants.ESCAPE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				Token t = null;
				int count = 0;
				bool control = false;
				while (true)
				{
					t = ConsumeToken(ParserConstants.DOUBLE_ESCAPE);
					count++;
					if (jj_2_2(2))
					{
						;
					}
					else
					{
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_2_brk;
					}
				}
				//UPGRADE_NOTE: Label 'label_2_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
				label_2_brk:
				;

				nodeTree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				/*
				* first, check to see if we have a control directive
				*/
				switch (t.Next.Kind)
				{
					case ParserConstants.IF_DIRECTIVE:
					case ParserConstants.ELSE_DIRECTIVE:
					case ParserConstants.ELSEIF_DIRECTIVE:
					case ParserConstants.END:
					case ParserConstants.STOP_DIRECTIVE:
						control = true;
						break;

				}

				/*
				* if that failed, lets lookahead to see if we matched a PD or a VM
				*/

				if (IsDirective(t.Next.Image.Substring(1)))
					control = true;
				else if (rsvc.IsVelocimacro(t.Next.Image.Substring(1), currentTemplateName))
					control = true;

				t.Image = "";

				for (int i = 0; i < count; i++)
					t.Image += (control ? "\\" : "\\\\");
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void Comment()
		{
			/*@bgen(jjtree) Comment */
			ASTComment jjtn000 = new ASTComment(this, ParserTreeConstants.COMMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.SINGLE_LINE_COMMENT:
						ConsumeToken(ParserConstants.SINGLE_LINE_COMMENT);
						break;

					case ParserConstants.MULTI_LINE_COMMENT:
						ConsumeToken(ParserConstants.MULTI_LINE_COMMENT);
						break;

					case ParserConstants.FORMAL_COMMENT:
						ConsumeToken(ParserConstants.FORMAL_COMMENT);
						break;

					default:
						jj_la1[3] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void NumberLiteral()
		{
			/*@bgen(jjtree) NumberLiteral */
			ASTNumberLiteral jjtn000 = new ASTNumberLiteral(this, ParserTreeConstants.NUMBER_LITERAL);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.NUMBER_LITERAL);
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void StringLiteral()
		{
			/*@bgen(jjtree) StringLiteral */
			ASTStringLiteral jjtn000 = new ASTStringLiteral(this, ParserTreeConstants.STRING_LITERAL);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.STRING_LITERAL);
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary> This method corresponds to variable
		/// references in Velocity templates.
		/// The following are examples of variable
		/// references that may be found in a
		/// template:
		/// *
		/// $foo
		/// $bar
		/// *
		/// </summary>
		public void Identifier()
		{
			/*@bgen(jjtree) Identifier */
			ASTIdentifier jjtn000 = new ASTIdentifier(this, ParserTreeConstants.IDENTIFIER);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.IDENTIFIER);
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void Word()
		{
			/*@bgen(jjtree) Word */
			ASTWord jjtn000 = new ASTWord(this, ParserTreeConstants.WORD);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.WORD);
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary>   Supports the arguments for the Pluggable Directives
		/// We add whitespace in here as a token so the VMs can
		/// easily reconstruct a macro body from the token stream
		/// See Directive()
		/// </summary>
		public void DirectiveArg()
		{
			switch (GetCurrentTokenKind())
			{
				case ParserConstants.IDENTIFIER:
				case ParserConstants.LCURLY:
					Reference();
					break;

				case ParserConstants.WORD:
					Word();
					break;

				case ParserConstants.STRING_LITERAL:
					StringLiteral();
					break;

				case ParserConstants.NUMBER_LITERAL:
					NumberLiteral();
					break;

				default:
					jj_la1[4] = jj_gen;
					if (jj_2_3(2147483647))
					{
						IntegerRange();
					}
					else
					{
						switch (GetCurrentTokenKind())
						{
							case ParserConstants.LBRACKET:
								ObjectArray();
								break;

							case ParserConstants.TRUE:
								True();
								break;

							case ParserConstants.FALSE:
								False();
								break;

							case ParserConstants.WHITESPACE:
								ConsumeToken(ParserConstants.WHITESPACE);
								break;

							default:
								jj_la1[5] = jj_gen;
								ConsumeToken(- 1);
								throw new ParseException();

						}
					}
					break;

			}
		}

		/// <summary>   Supports the Pluggable Directives
		/// #foo( arg+ )
		/// </summary>
		public SimpleNode Directive()
		{
			/*@bgen(jjtree) Directive */
			ASTDirective directiveNode = new ASTDirective(this, ParserTreeConstants.DIRECTIVE);
			bool isNodeScopeOpen = true;
			nodeTree.OpenNodeScope(directiveNode);
			Token token = null;
			Directive directive;
			DirectiveType directiveType;
			bool doItNow = false;
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				/*
		* note that if we were escaped, that is now handled by 
		* EscapedDirective()
		*/
				token = ConsumeToken(ParserConstants.WORD);
				String directiveName = token.Image.Substring(1);

				directive = directives.Create(directiveName);

				/*
		*  Velocimacro support : if the directive is macro directive
		*   then set the flag so after the block parsing, we add the VM
		*   right then. (So available if used w/in the current template )
		*/

				if (directiveName.Equals("macro"))
				{
					doItNow = true;
				}

				/*
		* set the directive name from here.  No reason for the thing to know 
		* about parser tokens
		*/

				directiveNode.DirectiveName = directiveName;

				if (directive == null)
				{
					// if null, then not a real directive, but maybe a Velocimacro

					//d  =  (Directive) rsvc.getVelocimacro( directiveName, currentTemplateName );

					// TODO: adding a null check since RuntimeServices is not finished
					// since the parser can be created without RuntimeServices - this may actually be needed here and in the orgiginal source as well.
					if (rsvc != null)
					{
						if (!rsvc.IsVelocimacro(directiveName, currentTemplateName))
						{
							token_source.StateStackPop();
							token_source.inDirective = false;
							if (true)
								return directiveNode;
						}
					}

					/*
					 *  Currently, all VMs are LINE directives
					 */
					directiveType = DirectiveType.LINE;
				}
				else
				{
					directiveType = directive.Type;
				}

				/*
				*  now, switch us out of PRE_DIRECTIVE
				*/

				token_source.SwitchTo(ParserConstants.DIRECTIVE);

				ConsumeWhiteSpaces();

				if ( directive != null && !directive.AcceptParams)
				{
					int curToken = GetCurrentTokenKind();

					if(curToken == ParserConstants.NEWLINE)
					{
						ConsumeToken(ParserConstants.NEWLINE);	
					}
					else
					{
						throw new ParseException("Foreach directives must be the only items on the line (comments or contents are not allowed)");
					}
											
					return directiveNode;
				}

				ConsumeToken(ParserConstants.LPAREN);
				while (true)
				{
					switch (GetCurrentTokenKind())
					{
						case ParserConstants.LBRACKET:
						case ParserConstants.WHITESPACE:
						case ParserConstants.STRING_LITERAL:
						case ParserConstants.TRUE:
						case ParserConstants.FALSE:
						case ParserConstants.NUMBER_LITERAL:
						case ParserConstants.WORD:
						case ParserConstants.IDENTIFIER:
						case ParserConstants.LCURLY:
							;
							break;

						default:
							jj_la1[7] = jj_gen;
							//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
							goto label_3_brk;

					}
					DirectiveArg();
				}
				//UPGRADE_NOTE: Label 'label_3_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
				label_3_brk:
				;

				ConsumeToken(ParserConstants.RPAREN);
				if (directiveType == DirectiveType.LINE)
				{
					if (true)
						return directiveNode;
				}

				ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.BLOCK);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					while (true)
					{
						Statement();
						int kind = GetCurrentTokenKind();
						switch (kind)
						{
							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE_DIRECTIVE:
							case ParserConstants.SET_DIRECTIVE:
							case ParserConstants.DOUBLE_ESCAPE:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.IF_DIRECTIVE:
							case ParserConstants.STOP_DIRECTIVE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								break;

							default:
								jj_la1[8] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_4_brk;

						}
					}
					//UPGRADE_NOTE: Label 'label_4_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_4_brk:
					;

				}
				catch (Exception jjte001)
				{
					if (jjtc001)
					{
						nodeTree.ClearNodeScope(jjtn001);
						jjtc001 = false;
					}
					else
					{
						nodeTree.PopNode();
					}
					if (jjte001 is SystemException)
					{
						{
							if (true)
								throw (SystemException) jjte001;
						}
					}
					if (jjte001 is ParseException)
					{
						{
							if (true)
								throw (ParseException) jjte001;
						}
					}
					{
						if (true)
							throw (ApplicationException) jjte001;
					}
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, true);
					}
				}
				ConsumeToken(ParserConstants.END);
				nodeTree.CloseNodeScope(directiveNode, true);
				isNodeScopeOpen = false;
				/*
		*  VM : if we are processing a #macro directive, we need to 
		*     process the block.  In truth, I can just register the name
		*     and do the work later when init-ing.  That would work
		*     as long as things were always defined before use.  This way
		*     we don't have to worry about forward references and such...
		*/

				if (doItNow)
				{
					Macro.processAndRegister(rsvc, directiveNode, currentTemplateName);
				}
				{
					/*
		    *  VM : end
		    */

					if (true)
						return directiveNode;
				}
			}
			catch (Exception jjte000)
			{
				if (isNodeScopeOpen)
				{
					nodeTree.ClearNodeScope(directiveNode);
					isNodeScopeOpen = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (isNodeScopeOpen)
				{
					nodeTree.CloseNodeScope(directiveNode, true);
				}
			}
			throw new ApplicationException("Missing return statement in function");
		}

		private int GetCurrentTokenKind( )
		{
			return (jj_ntk_Renamed_Field == - 1) ? jj_ntk() : jj_ntk_Renamed_Field;
		}

		private void ConsumeWhiteSpaces( )
		{
			switch (GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[6] = jj_gen;
					;
					break;

			}
		}

		public void ObjectArray()
		{
			/*@bgen(jjtree) ObjectArray */
			ASTObjectArray jjtn000 = new ASTObjectArray(this, ParserTreeConstants.OBJECT_ARRAY);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.LBRACKET);
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LBRACKET:
					case ParserConstants.WHITESPACE:
					case ParserConstants.STRING_LITERAL:
					case ParserConstants.TRUE:
					case ParserConstants.FALSE:
					case ParserConstants.NUMBER_LITERAL:
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						Parameter();
						while (true)
						{
							switch (GetCurrentTokenKind())
							{
								case ParserConstants.COMMA:
									;
									break;

								default:
									jj_la1[9] = jj_gen;
									//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
									goto label_5_brk;

							}
							ConsumeToken(ParserConstants.COMMA);
							Parameter();
						}
						//UPGRADE_NOTE: Label 'label_5_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_5_brk:
						;

						break;

					default:
						jj_la1[10] = jj_gen;
						;
						break;

				}
				ConsumeToken(ParserConstants.RBRACKET);
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary>  supports the [n..m] vector generator for use in
		/// the #foreach() to generate measured ranges w/o
		/// needing explicit support from the app/servlet
		/// </summary>
		public void IntegerRange()
		{
			/*@bgen(jjtree) IntegerRange */
			ASTIntegerRange jjtn000 = new ASTIntegerRange(this, ParserTreeConstants.INTEGER_RANGE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.LBRACKET);
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[11] = jj_gen;
						;
						break;

				}
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						Reference();
						break;

					case ParserConstants.NUMBER_LITERAL:
						NumberLiteral();
						break;

					default:
						jj_la1[12] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[13] = jj_gen;
						;
						break;

				}
				ConsumeToken(ParserConstants.DOUBLEDOT);
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[14] = jj_gen;
						;
						break;

				}
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						Reference();
						break;

					case ParserConstants.NUMBER_LITERAL:
						NumberLiteral();
						break;

					default:
						jj_la1[15] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[16] = jj_gen;
						;
						break;

				}
				ConsumeToken(ParserConstants.RBRACKET);
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary> This method has yet to be fully implemented
		/// but will allow arbitrarily nested method
		/// calls
		/// </summary>
		public void Parameter()
		{
			switch (GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[17] = jj_gen;
					;
					break;

			}
			switch (GetCurrentTokenKind())
			{
				case ParserConstants.STRING_LITERAL:
					StringLiteral();
					break;

				default:
					jj_la1[18] = jj_gen;
					if (jj_2_4(2147483647))
					{
						IntegerRange();
					}
					else
					{
						switch (GetCurrentTokenKind())
						{
							case ParserConstants.LBRACKET:
								ObjectArray();
								break;

							case ParserConstants.TRUE:
								True();
								break;

							case ParserConstants.FALSE:
								False();
								break;

							case ParserConstants.IDENTIFIER:
							case ParserConstants.LCURLY:
								Reference();
								break;

							case ParserConstants.NUMBER_LITERAL:
								NumberLiteral();
								break;

							default:
								jj_la1[19] = jj_gen;
								ConsumeToken(- 1);
								throw new ParseException();

						}
					}
					break;

			}
			switch (GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[20] = jj_gen;
					;
					break;

			}
		}

		/// <summary> This method has yet to be fully implemented
		/// but will allow arbitrarily nested method
		/// calls
		/// </summary>
		public void Method()
		{
			/*@bgen(jjtree) Method */
			ASTMethod jjtn000 = new ASTMethod(this, ParserTreeConstants.METHOD);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				Identifier();
				ConsumeToken(ParserConstants.LPAREN);
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LBRACKET:
					case ParserConstants.WHITESPACE:
					case ParserConstants.STRING_LITERAL:
					case ParserConstants.TRUE:
					case ParserConstants.FALSE:
					case ParserConstants.NUMBER_LITERAL:
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						Parameter();
						while (true)
						{
							switch (GetCurrentTokenKind())
							{
								case ParserConstants.COMMA:
									;
									break;

								default:
									jj_la1[21] = jj_gen;
									//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
									goto label_6_brk;

							}
							ConsumeToken(ParserConstants.COMMA);
							Parameter();
						}
						//UPGRADE_NOTE: Label 'label_6_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_6_brk:
						;

						break;

					default:
						jj_la1[22] = jj_gen;
						;
						break;

				}
				ConsumeToken(ParserConstants.REFMOD2_RPAREN);
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void Reference()
		{
			/*@bgen(jjtree) Reference */
			ASTReference jjtn000 = new ASTReference(this, ParserTreeConstants.REFERENCE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.IDENTIFIER:
						ConsumeToken(ParserConstants.IDENTIFIER);
						while (true)
						{
							if (jj_2_5(2))
							{
								;
							}
							else
							{
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_7_brk;
							}
							ConsumeToken(ParserConstants.DOT);
							if (jj_2_6(3))
							{
								Method();
							}
							else
							{
								switch (GetCurrentTokenKind())
								{
									case ParserConstants.IDENTIFIER:
										Identifier();
										break;

									default:
										jj_la1[23] = jj_gen;
										ConsumeToken(- 1);
										throw new ParseException();

								}
							}
						}
						//UPGRADE_NOTE: Label 'label_7_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_7_brk:
						;

						break;

					case ParserConstants.LCURLY:
						ConsumeToken(ParserConstants.LCURLY);
						ConsumeToken(ParserConstants.IDENTIFIER);
						while (true)
						{
							if (jj_2_7(2))
							{
								;
							}
							else
							{
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_8_brk;
							}
							ConsumeToken(ParserConstants.DOT);
							if (jj_2_8(3))
							{
								Method();
							}
							else
							{
								switch (GetCurrentTokenKind())
								{
									case ParserConstants.IDENTIFIER:
										Identifier();
										break;

									default:
										jj_la1[24] = jj_gen;
										ConsumeToken(- 1);
										throw new ParseException();

								}
							}
						}
						//UPGRADE_NOTE: Label 'label_8_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_8_brk:
						;

						ConsumeToken(ParserConstants.RCURLY);
						break;

					default:
						jj_la1[25] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void True()
		{
			/*@bgen(jjtree) True */
			ASTTrue jjtn000 = new ASTTrue(this, ParserTreeConstants.TRUE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.TRUE);
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void False()
		{
			/*@bgen(jjtree) False */
			ASTFalse jjtn000 = new ASTFalse(this, ParserTreeConstants.FALSE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				ConsumeToken(ParserConstants.FALSE);
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary> This method is responsible for allowing
		/// all non-grammar text to pass through
		/// unscathed.
		/// </summary>
		public void Text()
		{
			/*@bgen(jjtree) Text */
			ASTText jjtn000 = new ASTText(this, ParserTreeConstants.TEXT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			try
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.TEXT:
						ConsumeToken(ParserConstants.TEXT);
						break;

					case ParserConstants.DOT:
						ConsumeToken(ParserConstants.DOT);
						break;

					case ParserConstants.RPAREN:
						ConsumeToken(ParserConstants.RPAREN);
						break;

					case ParserConstants.LPAREN:
						ConsumeToken(ParserConstants.LPAREN);
						break;

					case ParserConstants.NUMBER_LITERAL:
						ConsumeToken(ParserConstants.NUMBER_LITERAL);
						break;

					case ParserConstants.STRING_LITERAL:
						ConsumeToken(ParserConstants.STRING_LITERAL);
						break;

					case ParserConstants.ESCAPE:
						ConsumeToken(ParserConstants.ESCAPE);
						break;

					case ParserConstants.LCURLY:
						ConsumeToken(ParserConstants.LCURLY);
						break;

					case ParserConstants.RCURLY:
						ConsumeToken(ParserConstants.RCURLY);
						break;

					default:
						jj_la1[26] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/* -----------------------------------------------------------------------
		* 
		*  Defined Directive Syntax
		* 
		* ----------------------------------------------------------------------*/

		public void IfStatement()
		{
			/*@bgen(jjtree) IfStatement */
			ASTIfStatement jjtn000 = new ASTIfStatement(this, ParserTreeConstants.IF_STATEMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.IF_DIRECTIVE);
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[27] = jj_gen;
						;
						break;

				}
				ConsumeToken(ParserConstants.LPAREN);
				Expression();
				ConsumeToken(ParserConstants.RPAREN);
				ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.BLOCK);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					while (true)
					{
						Statement();
						switch (GetCurrentTokenKind())
						{
							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE_DIRECTIVE:
							case ParserConstants.SET_DIRECTIVE:
							case ParserConstants.DOUBLE_ESCAPE:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.IF_DIRECTIVE:
							case ParserConstants.STOP_DIRECTIVE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								;
								break;

							default:
								jj_la1[28] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_9_brk;

						}
					}
					//UPGRADE_NOTE: Label 'label_9_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_9_brk:
					;

				}
				catch (Exception jjte001)
				{
					if (jjtc001)
					{
						nodeTree.ClearNodeScope(jjtn001);
						jjtc001 = false;
					}
					else
					{
						nodeTree.PopNode();
					}
					if (jjte001 is SystemException)
					{
						{
							if (true)
								throw (SystemException) jjte001;
						}
					}
					if (jjte001 is ParseException)
					{
						{
							if (true)
								throw (ParseException) jjte001;
						}
					}
					{
						if (true)
							throw (ApplicationException) jjte001;
					}
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, true);
					}
				}

				switch (GetCurrentTokenKind())
				{
					case ParserConstants.ELSEIF_DIRECTIVE:
						while (true)
						{
							ElseIfStatement();
							switch (GetCurrentTokenKind())
							{
								case ParserConstants.ELSEIF_DIRECTIVE:
									;
									break;

								default:
									jj_la1[29] = jj_gen;
									//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
									goto label_10_brk;

							}
						}
						//UPGRADE_NOTE: Label 'label_10_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
						label_10_brk:
						;

						break;

					default:
						jj_la1[30] = jj_gen;
						;
						break;

				}

				switch (GetCurrentTokenKind())
				{
					case ParserConstants.ELSE_DIRECTIVE:
						ElseStatement();
						break;

					default:
						jj_la1[31] = jj_gen;
						;
						break;

				}
				ConsumeToken(ParserConstants.END);
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void ElseStatement()
		{
			/*@bgen(jjtree) ElseStatement */
			ASTElseStatement jjtn000 = new ASTElseStatement(this, ParserTreeConstants.ELSE_STATEMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.ELSE_DIRECTIVE);
				ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.BLOCK);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					while (true)
					{
						Statement();
						switch (GetCurrentTokenKind())
						{
							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE_DIRECTIVE:
							case ParserConstants.SET_DIRECTIVE:
							case ParserConstants.DOUBLE_ESCAPE:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.IF_DIRECTIVE:
							case ParserConstants.STOP_DIRECTIVE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								;
								break;

							default:
								jj_la1[32] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_11_brk;

						}
					}
					//UPGRADE_NOTE: Label 'label_11_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_11_brk:
					;

				}
				catch (Exception jjte001)
				{
					if (jjtc001)
					{
						nodeTree.ClearNodeScope(jjtn001);
						jjtc001 = false;
					}
					else
					{
						nodeTree.PopNode();
					}
					if (jjte001 is SystemException)
					{
						{
							if (true)
								throw (SystemException) jjte001;
						}
					}
					if (jjte001 is ParseException)
					{
						{
							if (true)
								throw (ParseException) jjte001;
						}
					}
					{
						if (true)
							throw (ApplicationException) jjte001;
					}
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, true);
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void ElseIfStatement()
		{
			/*@bgen(jjtree) ElseIfStatement */
			ASTElseIfStatement jjtn000 = new ASTElseIfStatement(this, ParserTreeConstants.ELSE_IF_STATEMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.ELSEIF_DIRECTIVE);
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[33] = jj_gen;
						;
						break;

				}
				ConsumeToken(ParserConstants.LPAREN);
				Expression();
				ConsumeToken(ParserConstants.RPAREN);
				ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.BLOCK);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					while (true)
					{
						Statement();
						switch (GetCurrentTokenKind())
						{
							case ParserConstants.LPAREN:
							case ParserConstants.RPAREN:
							case ParserConstants.ESCAPE_DIRECTIVE:
							case ParserConstants.SET_DIRECTIVE:
							case ParserConstants.DOUBLE_ESCAPE:
							case ParserConstants.ESCAPE:
							case ParserConstants.TEXT:
							case ParserConstants.SINGLE_LINE_COMMENT:
							case ParserConstants.FORMAL_COMMENT:
							case ParserConstants.MULTI_LINE_COMMENT:
							case ParserConstants.STRING_LITERAL:
							case ParserConstants.IF_DIRECTIVE:
							case ParserConstants.STOP_DIRECTIVE:
							case ParserConstants.NUMBER_LITERAL:
							case ParserConstants.WORD:
							case ParserConstants.IDENTIFIER:
							case ParserConstants.DOT:
							case ParserConstants.LCURLY:
							case ParserConstants.RCURLY:
								;
								break;

							default:
								jj_la1[34] = jj_gen;
								//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
								goto label_12_brk;

						}
					}
					//UPGRADE_NOTE: Label 'label_12_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
					label_12_brk:
					;

				}
				catch (Exception jjte001)
				{
					if (jjtc001)
					{
						nodeTree.ClearNodeScope(jjtn001);
						jjtc001 = false;
					}
					else
					{
						nodeTree.PopNode();
					}
					if (jjte001 is SystemException)
					{
						{
							if (true)
								throw (SystemException) jjte001;
						}
					}
					if (jjte001 is ParseException)
					{
						{
							if (true)
								throw (ParseException) jjte001;
						}
					}
					{
						if (true)
							throw (ApplicationException) jjte001;
					}
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, true);
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary>  Currently support both types of set :
		/// #set( expr )
		/// #set expr
		/// </summary>
		public void SetDirective()
		{
			/*@bgen(jjtree) SetDirective */
			ASTSetDirective jjtn000 = new ASTSetDirective(this, ParserTreeConstants.SET_DIRECTIVE);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				ConsumeToken(ParserConstants.SET_DIRECTIVE);
				if (jj_2_9(2))
				{
					ConsumeToken(ParserConstants.WHITESPACE);
				}
				else
				{
					;
				}
				ConsumeToken(ParserConstants.LPAREN);
				Expression();
				ConsumeToken(ParserConstants.RPAREN);
				/*
				* ensure that inSet is false.  Leads to some amusing bugs...
				*/

				token_source.inSet = false;
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.NEWLINE:
						ConsumeToken(ParserConstants.NEWLINE);
						break;

					default:
						jj_la1[35] = jj_gen;
						;
						break;

				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		/// <summary> This method corresponds to the #stop
		/// directive which just simulates and EOF
		/// so that parsing stops. The #stop directive
		/// is useful for end-user debugging
		/// purposes.
		/// </summary>
		public void StopStatement()
		{
			ConsumeToken(ParserConstants.STOP_DIRECTIVE);
		}

		/* -----------------------------------------------------------------------
		* 
		*  Expression Syntax
		* 
		* ----------------------------------------------------------------------*/

		public void Expression()
		{
			/*@bgen(jjtree) Expression */
			ASTExpression jjtn000 = new ASTExpression(this, ParserTreeConstants.EXPRESSION);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				if (jj_2_10(2147483647))
				{
					Assignment();
				}
				else
				{
					switch (GetCurrentTokenKind())
					{
						case ParserConstants.LBRACKET:
						case ParserConstants.LPAREN:
						case ParserConstants.WHITESPACE:
						case ParserConstants.STRING_LITERAL:
						case ParserConstants.TRUE:
						case ParserConstants.FALSE:
						case ParserConstants.LOGICAL_NOT:
						case ParserConstants.NUMBER_LITERAL:
						case ParserConstants.IDENTIFIER:
						case ParserConstants.LCURLY:
							ConditionalOrExpression();
							break;

						default:
							jj_la1[36] = jj_gen;
							ConsumeToken(- 1);
							throw new ParseException();

					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, true);
				}
			}
		}

		public void Assignment()
		{
			/*@bgen(jjtree) #Assignment( 2) */
			ASTAssignment jjtn000 = new ASTAssignment(this, ParserTreeConstants.ASSIGNMENT);
			bool jjtc000 = true;
			nodeTree.OpenNodeScope(jjtn000);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try
			{
				PrimaryExpression();
				ConsumeToken(ParserConstants.EQUALS);
				Expression();
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					nodeTree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					nodeTree.PopNode();
				}
				if (jjte000 is SystemException)
				{
					{
						if (true)
							throw (SystemException) jjte000;
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
							throw (ParseException) jjte000;
					}
				}
				{
					if (true)
						throw (ApplicationException) jjte000;
				}
			}
			finally
			{
				if (jjtc000)
				{
					nodeTree.CloseNodeScope(jjtn000, 2);
				}
			}
		}

		public void ConditionalOrExpression()
		{
			ConditionalAndExpression();
			while (true)
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_OR:
						;
						break;

					default:
						jj_la1[37] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_13_brk;

				}
				ConsumeToken(ParserConstants.LOGICAL_OR);
				ASTOrNode jjtn001 = new ASTOrNode(this, ParserTreeConstants.OR_NODE);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					ConditionalAndExpression();
				}
				catch (Exception jjte001)
				{
					if (jjtc001)
					{
						nodeTree.ClearNodeScope(jjtn001);
						jjtc001 = false;
					}
					else
					{
						nodeTree.PopNode();
					}
					if (jjte001 is SystemException)
					{
						{
							if (true)
								throw (SystemException) jjte001;
						}
					}
					if (jjte001 is ParseException)
					{
						{
							if (true)
								throw (ParseException) jjte001;
						}
					}
					{
						if (true)
							throw (ApplicationException) jjte001;
					}
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, 2);
					}
				}
			}
			//UPGRADE_NOTE: Label 'label_13_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_13_brk:
			;

		}

		public void ConditionalAndExpression()
		{
			EqualityExpression();
			while (true)
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_AND:
						;
						break;

					default:
						jj_la1[38] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_14_brk;

				}
				ConsumeToken(ParserConstants.LOGICAL_AND);
				ASTAndNode jjtn001 = new ASTAndNode(this, ParserTreeConstants.AND_NODE);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					EqualityExpression();
				}
				catch (Exception jjte001)
				{
					if (jjtc001)
					{
						nodeTree.ClearNodeScope(jjtn001);
						jjtc001 = false;
					}
					else
					{
						nodeTree.PopNode();
					}
					if (jjte001 is SystemException)
					{
						{
							if (true)
								throw (SystemException) jjte001;
						}
					}
					if (jjte001 is ParseException)
					{
						{
							if (true)
								throw (ParseException) jjte001;
						}
					}
					{
						if (true)
							throw (ApplicationException) jjte001;
					}
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, 2);
					}
				}
			}
			//UPGRADE_NOTE: Label 'label_14_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_14_brk:
			;

		}

		public void EqualityExpression()
		{
			RelationalExpression();
			while (true)
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_EQUALS:
					case ParserConstants.LOGICAL_NOT_EQUALS:
						;
						break;

					default:
						jj_la1[39] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_15_brk;

				}
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_EQUALS:
						ConsumeToken(ParserConstants.LOGICAL_EQUALS);
						ASTEQNode jjtn001 = new ASTEQNode(this, ParserTreeConstants.EQ_NODE);
						bool jjtc001 = true;
						nodeTree.OpenNodeScope(jjtn001);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							RelationalExpression();
						}
						catch (Exception jjte001)
						{
							if (jjtc001)
							{
								nodeTree.ClearNodeScope(jjtn001);
								jjtc001 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte001 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte001;
								}
							}
							if (jjte001 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte001;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte001;
							}
						}
						finally
						{
							if (jjtc001)
							{
								nodeTree.CloseNodeScope(jjtn001, 2);
							}
						}
						break;

					case ParserConstants.LOGICAL_NOT_EQUALS:
						ConsumeToken(ParserConstants.LOGICAL_NOT_EQUALS);
						ASTNENode jjtn002 = new ASTNENode(this, ParserTreeConstants.NE_NODE);
						bool jjtc002 = true;
						nodeTree.OpenNodeScope(jjtn002);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							RelationalExpression();
						}
						catch (Exception jjte002)
						{
							if (jjtc002)
							{
								nodeTree.ClearNodeScope(jjtn002);
								jjtc002 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte002 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte002;
								}
							}
							if (jjte002 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte002;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte002;
							}
						}
						finally
						{
							if (jjtc002)
							{
								nodeTree.CloseNodeScope(jjtn002, 2);
							}
						}
						break;

					default:
						jj_la1[40] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
			}
			//UPGRADE_NOTE: Label 'label_15_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_15_brk:
			;

		}

		public void RelationalExpression()
		{
			AdditiveExpression();
			while (true)
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_LT:
					case ParserConstants.LOGICAL_LE:
					case ParserConstants.LOGICAL_GT:
					case ParserConstants.LOGICAL_GE:
						;
						break;

					default:
						jj_la1[41] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_16_brk;

				}
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LOGICAL_LT:
						ConsumeToken(ParserConstants.LOGICAL_LT);
						ASTLTNode jjtn001 = new ASTLTNode(this, ParserTreeConstants.LT_NODE);
						bool jjtc001 = true;
						nodeTree.OpenNodeScope(jjtn001);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							AdditiveExpression();
						}
						catch (Exception jjte001)
						{
							if (jjtc001)
							{
								nodeTree.ClearNodeScope(jjtn001);
								jjtc001 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte001 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte001;
								}
							}
							if (jjte001 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte001;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte001;
							}
						}
						finally
						{
							if (jjtc001)
							{
								nodeTree.CloseNodeScope(jjtn001, 2);
							}
						}
						break;

					case ParserConstants.LOGICAL_GT:
						ConsumeToken(ParserConstants.LOGICAL_GT);
						ASTGTNode jjtn002 = new ASTGTNode(this, ParserTreeConstants.GT_NODE);
						bool jjtc002 = true;
						nodeTree.OpenNodeScope(jjtn002);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							AdditiveExpression();
						}
						catch (Exception jjte002)
						{
							if (jjtc002)
							{
								nodeTree.ClearNodeScope(jjtn002);
								jjtc002 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte002 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte002;
								}
							}
							if (jjte002 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte002;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte002;
							}
						}
						finally
						{
							if (jjtc002)
							{
								nodeTree.CloseNodeScope(jjtn002, 2);
							}
						}
						break;

					case ParserConstants.LOGICAL_LE:
						ConsumeToken(ParserConstants.LOGICAL_LE);
						ASTLENode jjtn003 = new ASTLENode(this, ParserTreeConstants.LE_NODE);
						bool jjtc003 = true;
						nodeTree.OpenNodeScope(jjtn003);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							AdditiveExpression();
						}
						catch (Exception jjte003)
						{
							if (jjtc003)
							{
								nodeTree.ClearNodeScope(jjtn003);
								jjtc003 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte003 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte003;
								}
							}
							if (jjte003 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte003;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte003;
							}
						}
						finally
						{
							if (jjtc003)
							{
								nodeTree.CloseNodeScope(jjtn003, 2);
							}
						}
						break;

					case ParserConstants.LOGICAL_GE:
						ConsumeToken(ParserConstants.LOGICAL_GE);
						ASTGENode jjtn004 = new ASTGENode(this, ParserTreeConstants.GE_NODE);
						bool jjtc004 = true;
						nodeTree.OpenNodeScope(jjtn004);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							AdditiveExpression();
						}
						catch (Exception jjte004)
						{
							if (jjtc004)
							{
								nodeTree.ClearNodeScope(jjtn004);
								jjtc004 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte004 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte004;
								}
							}
							if (jjte004 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte004;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte004;
							}
						}
						finally
						{
							if (jjtc004)
							{
								nodeTree.CloseNodeScope(jjtn004, 2);
							}
						}
						break;

					default:
						jj_la1[42] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
			}
			//UPGRADE_NOTE: Label 'label_16_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_16_brk:
			;

		}

		public void AdditiveExpression()
		{
			MultiplicativeExpression();
			while (true)
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.MINUS:
					case ParserConstants.PLUS:
						;
						break;

					default:
						jj_la1[43] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_17_brk;

				}
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.PLUS:
						ConsumeToken(ParserConstants.PLUS);
						ASTAddNode jjtn001 = new ASTAddNode(this, ParserTreeConstants.ADD_NODE);
						bool jjtc001 = true;
						nodeTree.OpenNodeScope(jjtn001);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							MultiplicativeExpression();
						}
						catch (Exception jjte001)
						{
							if (jjtc001)
							{
								nodeTree.ClearNodeScope(jjtn001);
								jjtc001 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte001 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte001;
								}
							}
							if (jjte001 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte001;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte001;
							}
						}
						finally
						{
							if (jjtc001)
							{
								nodeTree.CloseNodeScope(jjtn001, 2);
							}
						}
						break;

					case ParserConstants.MINUS:
						ConsumeToken(ParserConstants.MINUS);
						ASTSubtractNode jjtn002 = new ASTSubtractNode(this, ParserTreeConstants.SUBTRACT_NODE);
						bool jjtc002 = true;
						nodeTree.OpenNodeScope(jjtn002);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							MultiplicativeExpression();
						}
						catch (Exception jjte002)
						{
							if (jjtc002)
							{
								nodeTree.ClearNodeScope(jjtn002);
								jjtc002 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte002 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte002;
								}
							}
							if (jjte002 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte002;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte002;
							}
						}
						finally
						{
							if (jjtc002)
							{
								nodeTree.CloseNodeScope(jjtn002, 2);
							}
						}
						break;

					default:
						jj_la1[44] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
			}
			//UPGRADE_NOTE: Label 'label_17_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_17_brk:
			;

		}

		public void MultiplicativeExpression()
		{
			UnaryExpression();
			while (true)
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.MULTIPLY:
					case ParserConstants.DIVIDE:
					case ParserConstants.MODULUS:
						;
						break;

					default:
						jj_la1[45] = jj_gen;
						//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
						goto label_18_brk;

				}
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.MULTIPLY:
						ConsumeToken(ParserConstants.MULTIPLY);
						ASTMulNode jjtn001 = new ASTMulNode(this, ParserTreeConstants.MUL_NODE);
						bool jjtc001 = true;
						nodeTree.OpenNodeScope(jjtn001);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							UnaryExpression();
						}
						catch (Exception jjte001)
						{
							if (jjtc001)
							{
								nodeTree.ClearNodeScope(jjtn001);
								jjtc001 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte001 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte001;
								}
							}
							if (jjte001 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte001;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte001;
							}
						}
						finally
						{
							if (jjtc001)
							{
								nodeTree.CloseNodeScope(jjtn001, 2);
							}
						}
						break;

					case ParserConstants.DIVIDE:
						ConsumeToken(ParserConstants.DIVIDE);
						ASTDivNode jjtn002 = new ASTDivNode(this, ParserTreeConstants.DIV_NODE);
						bool jjtc002 = true;
						nodeTree.OpenNodeScope(jjtn002);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							UnaryExpression();
						}
						catch (Exception jjte002)
						{
							if (jjtc002)
							{
								nodeTree.ClearNodeScope(jjtn002);
								jjtc002 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte002 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte002;
								}
							}
							if (jjte002 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte002;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte002;
							}
						}
						finally
						{
							if (jjtc002)
							{
								nodeTree.CloseNodeScope(jjtn002, 2);
							}
						}
						break;

					case ParserConstants.MODULUS:
						ConsumeToken(ParserConstants.MODULUS);
						ASTModNode jjtn003 = new ASTModNode(this, ParserTreeConstants.MOD_NODE);
						bool jjtc003 = true;
						nodeTree.OpenNodeScope(jjtn003);
						//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
						try
						{
							UnaryExpression();
						}
						catch (Exception jjte003)
						{
							if (jjtc003)
							{
								nodeTree.ClearNodeScope(jjtn003);
								jjtc003 = false;
							}
							else
							{
								nodeTree.PopNode();
							}
							if (jjte003 is SystemException)
							{
								{
									if (true)
										throw (SystemException) jjte003;
								}
							}
							if (jjte003 is ParseException)
							{
								{
									if (true)
										throw (ParseException) jjte003;
								}
							}
							{
								if (true)
									throw (ApplicationException) jjte003;
							}
						}
						finally
						{
							if (jjtc003)
							{
								nodeTree.CloseNodeScope(jjtn003, 2);
							}
						}
						break;

					default:
						jj_la1[46] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
			}
			//UPGRADE_NOTE: Label 'label_18_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
			label_18_brk:
			;

		}

		public void UnaryExpression()
		{
			if (jj_2_11(2))
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.WHITESPACE:
						ConsumeToken(ParserConstants.WHITESPACE);
						break;

					default:
						jj_la1[47] = jj_gen;
						;
						break;

				}
				ConsumeToken(ParserConstants.LOGICAL_NOT);
				ASTNotNode jjtn001 = new ASTNotNode(this, ParserTreeConstants.NOT_NODE);
				bool jjtc001 = true;
				nodeTree.OpenNodeScope(jjtn001);
				//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
				try
				{
					UnaryExpression();
				}
				catch (Exception jjte001)
				{
					if (jjtc001)
					{
						nodeTree.ClearNodeScope(jjtn001);
						jjtc001 = false;
					}
					else
					{
						nodeTree.PopNode();
					}
					if (jjte001 is SystemException)
					{
						{
							if (true)
								throw (SystemException) jjte001;
						}
					}
					if (jjte001 is ParseException)
					{
						{
							if (true)
								throw (ParseException) jjte001;
						}
					}
					{
						if (true)
							throw (ApplicationException) jjte001;
					}
				}
				finally
				{
					if (jjtc001)
					{
						nodeTree.CloseNodeScope(jjtn001, 1);
					}
				}
			}
			else
			{
				switch (GetCurrentTokenKind())
				{
					case ParserConstants.LBRACKET:
					case ParserConstants.LPAREN:
					case ParserConstants.WHITESPACE:
					case ParserConstants.STRING_LITERAL:
					case ParserConstants.TRUE:
					case ParserConstants.FALSE:
					case ParserConstants.NUMBER_LITERAL:
					case ParserConstants.IDENTIFIER:
					case ParserConstants.LCURLY:
						PrimaryExpression();
						break;

					default:
						jj_la1[48] = jj_gen;
						ConsumeToken(- 1);
						throw new ParseException();

				}
			}
		}

		public void PrimaryExpression()
		{
			switch (GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[49] = jj_gen;
					;
					break;

			}
			switch (GetCurrentTokenKind())
			{
				case ParserConstants.STRING_LITERAL:
					StringLiteral();
					break;

				case ParserConstants.NUMBER_LITERAL:
					NumberLiteral();
					break;

				case ParserConstants.IDENTIFIER:
				case ParserConstants.LCURLY:
					Reference();
					break;

				default:
					jj_la1[50] = jj_gen;
					if (jj_2_12(2147483647))
					{
						IntegerRange();
					}
					else
					{
						switch (GetCurrentTokenKind())
						{
							case ParserConstants.LBRACKET:
								ObjectArray();
								break;

							case ParserConstants.TRUE:
								True();
								break;

							case ParserConstants.FALSE:
								False();
								break;

							case ParserConstants.LPAREN:
								ConsumeToken(ParserConstants.LPAREN);
								Expression();
								ConsumeToken(ParserConstants.RPAREN);
								break;

							default:
								jj_la1[51] = jj_gen;
								ConsumeToken(- 1);
								throw new ParseException();

						}
					}
					break;

			}
			switch (GetCurrentTokenKind())
			{
				case ParserConstants.WHITESPACE:
					ConsumeToken(ParserConstants.WHITESPACE);
					break;

				default:
					jj_la1[52] = jj_gen;
					;
					break;

			}
		}

		private bool jj_2_1(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_1();
			Save(0, xla);
			return retval;
		}

		private bool jj_2_2(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_2();
			Save(1, xla);
			return retval;
		}

		private bool jj_2_3(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_3();
			Save(2, xla);
			return retval;
		}

		private bool jj_2_4(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_4();
			Save(3, xla);
			return retval;
		}

		private bool jj_2_5(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_5();
			Save(4, xla);
			return retval;
		}

		private bool jj_2_6(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_6();
			Save(5, xla);
			return retval;
		}

		private bool jj_2_7(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_7();
			Save(6, xla);
			return retval;
		}

		private bool jj_2_8(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_8();
			Save(7, xla);
			return retval;
		}

		private bool jj_2_9(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_9();
			Save(8, xla);
			return retval;
		}

		private bool jj_2_10(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_10();
			Save(9, xla);
			return retval;
		}

		private bool jj_2_11(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_11();
			Save(10, xla);
			return retval;
		}

		private bool jj_2_12(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			bool retval = !jj_3_12();
			Save(11, xla);
			return retval;
		}

		private bool jj_3R_58()
		{
			if (ScanToken(ParserConstants.TRUE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_7()
		{
			if (ScanToken(ParserConstants.DOT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3_8())
			{
				jj_scanpos = xsp;
				if (jj_3R_30())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_42()
		{
			if (jj_3R_54())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3R_88())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3_5()
		{
			if (ScanToken(ParserConstants.DOT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3_6())
			{
				jj_scanpos = xsp;
				if (jj_3R_28())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_39()
		{
			if (ScanToken(ParserConstants.LCURLY))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.IDENTIFIER))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3_7())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			if (ScanToken(ParserConstants.RCURLY))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_12()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_34())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_35())
			{
				jj_scanpos = xsp;
				if (jj_3R_36())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_37())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.DOUBLEDOT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_24()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_38()
		{
			if (ScanToken(ParserConstants.IDENTIFIER))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3_5())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3R_52()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_51()
		{
			if (ScanToken(ParserConstants.LPAREN))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_60())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.RPAREN))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_19()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_38())
			{
				jj_scanpos = xsp;
				if (jj_3R_39())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_32()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_50()
		{
			if (jj_3R_59())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_41()
		{
			if (ScanToken(ParserConstants.IDENTIFIER))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_49()
		{
			if (jj_3R_58())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_48()
		{
			if (jj_3R_57())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_47()
		{
			if (jj_3R_56())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_46()
		{
			if (jj_3R_19())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_45()
		{
			if (jj_3R_40())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_4()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_24())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_25())
			{
				jj_scanpos = xsp;
				if (jj_3R_26())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_27())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.DOUBLEDOT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_44()
		{
			if (jj_3R_55())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_29()
		{
			if (jj_3R_41())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.LPAREN))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_42())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.REFMOD2_RPAREN))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_43()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_31()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_43())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_44())
			{
				jj_scanpos = xsp;
				if (jj_3R_45())
				{
					jj_scanpos = xsp;
					if (jj_3R_46())
					{
						jj_scanpos = xsp;
						if (jj_3R_47())
						{
							jj_scanpos = xsp;
							if (jj_3R_48())
							{
								jj_scanpos = xsp;
								if (jj_3R_49())
								{
									jj_scanpos = xsp;
									if (jj_3R_50())
									{
										jj_scanpos = xsp;
										if (jj_3R_51())
											return true;
										if (jj_la == 0 && jj_scanpos == jj_lastpos)
											return false;
									}
									else if (jj_la == 0 && jj_scanpos == jj_lastpos)
										return false;
								}
								else if (jj_la == 0 && jj_scanpos == jj_lastpos)
									return false;
							}
							else if (jj_la == 0 && jj_scanpos == jj_lastpos)
								return false;
						}
						else if (jj_la == 0 && jj_scanpos == jj_lastpos)
							return false;
					}
					else if (jj_la == 0 && jj_scanpos == jj_lastpos)
						return false;
				}
				else if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_52())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_73()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_68()
		{
			if (jj_3R_40())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_106()
		{
			if (ScanToken(ParserConstants.MODULUS))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_33())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_67()
		{
			if (jj_3R_19())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_105()
		{
			if (ScanToken(ParserConstants.DIVIDE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_33())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_83()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_66()
		{
			if (jj_3R_59())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_33()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3_11())
			{
				jj_scanpos = xsp;
				if (jj_3R_53())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_11()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_32())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.LOGICAL_NOT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_33())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_53()
		{
			if (jj_3R_31())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_104()
		{
			if (ScanToken(ParserConstants.MULTIPLY))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_33())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_101()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_104())
			{
				jj_scanpos = xsp;
				if (jj_3R_105())
				{
					jj_scanpos = xsp;
					if (jj_3R_106())
						return true;
					if (jj_la == 0 && jj_scanpos == jj_lastpos)
						return false;
				}
				else if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_65()
		{
			if (jj_3R_58())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_55()
		{
			if (ScanToken(ParserConstants.STRING_LITERAL))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_64()
		{
			if (jj_3R_57())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_63()
		{
			if (jj_3R_56())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_62()
		{
			if (jj_3R_55())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_40()
		{
			if (ScanToken(ParserConstants.NUMBER_LITERAL))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_75()
		{
			if (jj_3R_40())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_80()
		{
			if (ScanToken(ParserConstants.COMMA))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_54())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_71()
		{
			if (jj_3R_40())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_95()
		{
			if (jj_3R_33())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3R_101())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3R_61()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_54()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_61())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_62())
			{
				jj_scanpos = xsp;
				if (jj_3R_63())
				{
					jj_scanpos = xsp;
					if (jj_3R_64())
					{
						jj_scanpos = xsp;
						if (jj_3R_65())
						{
							jj_scanpos = xsp;
							if (jj_3R_66())
							{
								jj_scanpos = xsp;
								if (jj_3R_67())
								{
									jj_scanpos = xsp;
									if (jj_3R_68())
										return true;
									if (jj_la == 0 && jj_scanpos == jj_lastpos)
										return false;
								}
								else if (jj_la == 0 && jj_scanpos == jj_lastpos)
									return false;
							}
							else if (jj_la == 0 && jj_scanpos == jj_lastpos)
								return false;
						}
						else if (jj_la == 0 && jj_scanpos == jj_lastpos)
							return false;
					}
					else if (jj_la == 0 && jj_scanpos == jj_lastpos)
						return false;
				}
				else if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_83())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_103()
		{
			if (ScanToken(ParserConstants.MINUS))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_95())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_102()
		{
			if (ScanToken(ParserConstants.PLUS))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_95())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_96()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_102())
			{
				jj_scanpos = xsp;
				if (jj_3R_103())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_69()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_91()
		{
			if (jj_3R_95())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3R_96())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3R_100()
		{
			if (ScanToken(ParserConstants.LOGICAL_GE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_91())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_76()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_99()
		{
			if (ScanToken(ParserConstants.LOGICAL_LE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_91())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_74()
		{
			if (jj_3R_19())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_98()
		{
			if (ScanToken(ParserConstants.LOGICAL_GT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_91())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_70()
		{
			if (jj_3R_19())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_72()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_77()
		{
			if (jj_3R_54())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3R_80())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3R_97()
		{
			if (ScanToken(ParserConstants.LOGICAL_LT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_91())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_92()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_97())
			{
				jj_scanpos = xsp;
				if (jj_3R_98())
				{
					jj_scanpos = xsp;
					if (jj_3R_99())
					{
						jj_scanpos = xsp;
						if (jj_3R_100())
							return true;
						if (jj_la == 0 && jj_scanpos == jj_lastpos)
							return false;
					}
					else if (jj_la == 0 && jj_scanpos == jj_lastpos)
						return false;
				}
				else if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_56()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_69())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_70())
			{
				jj_scanpos = xsp;
				if (jj_3R_71())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_72())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.DOUBLEDOT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_73())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_74())
			{
				jj_scanpos = xsp;
				if (jj_3R_75())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_76())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.RBRACKET))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_89()
		{
			if (jj_3R_91())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3R_92())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3R_94()
		{
			if (ScanToken(ParserConstants.LOGICAL_NOT_EQUALS))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_89())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_93()
		{
			if (ScanToken(ParserConstants.LOGICAL_EQUALS))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_89())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_90()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_93())
			{
				jj_scanpos = xsp;
				if (jj_3R_94())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_57()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_77())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.RBRACKET))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_86()
		{
			if (jj_3R_89())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3R_90())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3R_87()
		{
			if (ScanToken(ParserConstants.LOGICAL_AND))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_86())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_84()
		{
			if (jj_3R_86())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3R_87())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3R_85()
		{
			if (ScanToken(ParserConstants.LOGICAL_OR))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_84())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_2()
		{
			if (ScanToken(ParserConstants.DOUBLE_ESCAPE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_10()
		{
			if (jj_3R_31())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.EQUALS))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_82()
		{
			if (jj_3R_84())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (jj_3R_85())
				{
					jj_scanpos = xsp;
					break;
				}
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			return false;
		}

		private bool jj_3R_81()
		{
			if (jj_3R_31())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.EQUALS))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_60())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_79()
		{
			if (jj_3R_82())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_78()
		{
			if (jj_3R_81())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_60()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_78())
			{
				jj_scanpos = xsp;
				if (jj_3R_79())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_23()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_9()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_1()
		{
			if (jj_3R_19())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_22()
		{
			if (jj_3R_40())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_37()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_21()
		{
			if (jj_3R_19())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_27()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_30()
		{
			if (jj_3R_41())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_28()
		{
			if (jj_3R_41())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_36()
		{
			if (jj_3R_40())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_20()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_35()
		{
			if (jj_3R_19())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_26()
		{
			if (jj_3R_40())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_8()
		{
			if (jj_3R_29())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_3()
		{
			if (ScanToken(ParserConstants.LBRACKET))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			Token xsp;
			xsp = jj_scanpos;
			if (jj_3R_20())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_21())
			{
				jj_scanpos = xsp;
				if (jj_3R_22())
					return true;
				if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			xsp = jj_scanpos;
			if (jj_3R_23())
				jj_scanpos = xsp;
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (ScanToken(ParserConstants.DOUBLEDOT))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_88()
		{
			if (ScanToken(ParserConstants.COMMA))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			if (jj_3R_54())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3_6()
		{
			if (jj_3R_29())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_25()
		{
			if (jj_3R_19())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_59()
		{
			if (ScanToken(ParserConstants.FALSE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		private bool jj_3R_34()
		{
			if (ScanToken(ParserConstants.WHITESPACE))
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			return false;
		}

		public ParserTokenManager token_source;
		public Token token, jj_nt;
		//UPGRADE_NOTE: Field jj_ntk was renamed. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1029"'
		private int jj_ntk_Renamed_Field;
		private Token jj_scanpos, jj_lastpos;
		private int jj_la;
		public bool lookingAhead = false;
		private bool jj_semLA;
		private int jj_gen;
		//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
		//UPGRADE_NOTE: The initialization of  'jj_la1' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private int[] jj_la1;
		//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1_0 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
		private int[] jj_la1_0 = new int[] {0x13f0360, 0x0, 0x13f0360, 0x380000, 0x1000000, 0x6800002, 0x800000, 0x7800002, 0x13f0360, 0x8, 0x7800002, 0x800000, 0x0, 0x800000, 0x800000, 0x0, 0x800000, 0x800000, 0x1000000, 0x6000002, 0x800000, 0x8, 0x7800002, 0x0, 0x0, 0x0, 0x1060060, 0x800000, 0x13f0360, 0x0, 0x0, 0x0, 0x13f0360, 0x800000, 0x13f0360, 0x8000000, 0x7800022, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30000000, 0x30000000, (int) (- (0x100000000 - 0xc0000000)), (int) (- (0x100000000 - 0xc0000000)), 0x800000, 0x7800022, 0x800000, 0x1000000, 0x6000022, 0x800000};
		//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1_1 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
		private int[] jj_la1_1 = new int[] {0xf129000, 0x9000, 0xe120000, 0x0, 0x5120000, 0x0, 0x0, 0x5120000, 0xf129000, 0x0, 0x5020000, 0x0, 0x5020000, 0x0, 0x0, 0x5020000, 0x0, 0x0, 0x0, 0x5020000, 0x0, 0x0, 0x5020000, 0x1000000, 0x1000000, 0x5000000, 0xe020000, 0x0, 0xf129000, 0x2000, 0x2000, 0x4000, 0xf129000, 0x0, 0xf129000, 0x0, 0x5020200, 0x4, 0x2, 0x180, 0x180, 0x78, 0x78, 0x0, 0x0, 0x1, 0x1, 0x0, 0x5020000, 0x0, 0x5020000, 0x0, 0x0};
		//UPGRADE_NOTE: Final was removed from the declaration of 'jj_2_rtns '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
		//UPGRADE_NOTE: The initialization of  'jj_2_rtns' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private Calls[] jj_2_rtns;
		private bool jj_rescan = false;
		private int jj_gc = 0;

		public Parser(ICharStream stream)
		{
			InitBlock();
			token_source = new ParserTokenManager(stream);
			token = new Token();
			jj_ntk_Renamed_Field = - 1;
			jj_gen = 0;
			for (int i = 0; i < 53; i++)
				jj_la1[i] = - 1;
			for (int i = 0; i < jj_2_rtns.Length; i++)
				jj_2_rtns[i] = new Calls();
		}

		public void ReInit(ICharStream stream)
		{
			token_source.ReInit(stream);
			token = new Token();
			jj_ntk_Renamed_Field = - 1;
			nodeTree.Reset();
			jj_gen = 0;
			for (int i = 0; i < 53; i++)
				jj_la1[i] = - 1;
			for (int i = 0; i < jj_2_rtns.Length; i++)
				jj_2_rtns[i] = new Calls();
		}

		public Parser(ParserTokenManager tm)
		{
			InitBlock();
			token_source = tm;
			token = new Token();
			jj_ntk_Renamed_Field = - 1;
			jj_gen = 0;
			for (int i = 0; i < 53; i++)
				jj_la1[i] = - 1;
			for (int i = 0; i < jj_2_rtns.Length; i++)
				jj_2_rtns[i] = new Calls();
		}

		public void ReInit(ParserTokenManager tm)
		{
			token_source = tm;
			token = new Token();
			jj_ntk_Renamed_Field = - 1;
			nodeTree.Reset();
			jj_gen = 0;
			for (int i = 0; i < 53; i++)
				jj_la1[i] = - 1;
			for (int i = 0; i < jj_2_rtns.Length; i++)
				jj_2_rtns[i] = new Calls();
		}

		private Token ConsumeToken(int kind)
		{
			Token oldToken = token;
			if (token.Next != null)
				token = token.Next;
			else
				token = token.Next = token_source.NextToken;
			jj_ntk_Renamed_Field = - 1;
			if (token.Kind == kind)
			{
				jj_gen++;
				if (++jj_gc > 100)
				{
					jj_gc = 0;
					for (int i = 0; i < jj_2_rtns.Length; i++)
					{
						Calls c = jj_2_rtns[i];
						while (c != null)
						{
							if (c.Gen < jj_gen)
								c.First = null;
							c = c.Next;
						}
					}
				}
				return token;
			}
			token = oldToken;
			jj_kind = kind;
			throw GenerateParseException();
		}

		private bool ScanToken(int kind)
		{
			if (jj_scanpos == jj_lastpos)
			{
				jj_la--;
				if (jj_scanpos.Next == null)
				{
					jj_lastpos = jj_scanpos = jj_scanpos.Next = token_source.NextToken;
				}
				else
				{
					jj_lastpos = jj_scanpos = jj_scanpos.Next;
				}
			}
			else
			{
				jj_scanpos = jj_scanpos.Next;
			}
			if (jj_rescan)
			{
				int i = 0;
				Token tok = token;
				while (tok != null && tok != jj_scanpos)
				{
					i++;
					tok = tok.Next;
				}
				if (tok != null)
					AddErrorToken(kind, i);
			}
			return (jj_scanpos.Kind != kind);
		}


		public Token GetToken(int index)
		{
			Token t = lookingAhead ? jj_scanpos : token;
			for (int i = 0; i < index; i++)
			{
				if (t.Next != null)
					t = t.Next;
				else
					t = t.Next = token_source.NextToken;
			}
			return t;
		}

		private int jj_ntk()
		{
			if ((jj_nt = token.Next) == null)
				return (jj_ntk_Renamed_Field = (token.Next = token_source.NextToken).Kind);
			else
				return (jj_ntk_Renamed_Field = jj_nt.Kind);
		}

		//UPGRADE_NOTE: The initialization of  'jj_expentries' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private ArrayList jj_expentries;
		private int[] jj_expentry;
		private int jj_kind = - 1;
		//UPGRADE_NOTE: The initialization of  'jj_lasttokens' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
		private int[] jj_lasttokens;
		private int jj_endpos;

		private void AddErrorToken(int kind, int pos)
		{
			if (pos >= 100)
				return;
			if (pos == jj_endpos + 1)
			{
				jj_lasttokens[jj_endpos++] = kind;
			}
			else if (jj_endpos != 0)
			{
				jj_expentry = new int[jj_endpos];
				for (int i = 0; i < jj_endpos; i++)
				{
					jj_expentry[i] = jj_lasttokens[i];
				}
				bool exists = false;
				//UPGRADE_TODO: method 'java.util.Enumeration.hasMoreElements' was converted to ' ' which has a different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1073_javautilEnumerationhasMoreElements"'
				for (IEnumerator enum_Renamed = jj_expentries.GetEnumerator(); enum_Renamed.MoveNext(); )
				{
					//UPGRADE_TODO: method 'java.util.Enumeration.nextElement' was converted to ' ' which has a different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1073_javautilEnumerationnextElement"'
					int[] oldentry = (int[]) (enum_Renamed.Current);
					if (oldentry.Length == jj_expentry.Length)
					{
						exists = true;
						for (int i = 0; i < jj_expentry.Length; i++)
						{
							if (oldentry[i] != jj_expentry[i])
							{
								exists = false;
								break;
							}
						}
						if (exists)
							break;
					}
				}
				if (!exists)
					jj_expentries.Add(jj_expentry);
				if (pos != 0)
					jj_lasttokens[(jj_endpos = pos) - 1] = kind;
			}
		}

		public ParseException GenerateParseException()
		{
			ArrayList temp_arraylist;
			temp_arraylist = jj_expentries;
			temp_arraylist.RemoveRange(0, temp_arraylist.Count);
			bool[] la1tokens = new bool[62];
			for (int i = 0; i < 62; i++)
			{
				la1tokens[i] = false;
			}
			if (jj_kind >= 0)
			{
				la1tokens[jj_kind] = true;
				jj_kind = - 1;
			}
			for (int i = 0; i < 53; i++)
			{
				if (jj_la1[i] == jj_gen)
				{
					for (int j = 0; j < 32; j++)
					{
						if ((jj_la1_0[i] & (1 << j)) != 0)
						{
							la1tokens[j] = true;
						}
						if ((jj_la1_1[i] & (1 << j)) != 0)
						{
							la1tokens[32 + j] = true;
						}
					}
				}
			}
			for (int i = 0; i < 62; i++)
			{
				if (la1tokens[i])
				{
					jj_expentry = new int[1];
					jj_expentry[0] = i;
					jj_expentries.Add(jj_expentry);
				}
			}
			jj_endpos = 0;
			RescanToken();
			AddErrorToken(0, 0);
			int[][] exptokseq = new int[jj_expentries.Count][];
			for (int i = 0; i < jj_expentries.Count; i++)
			{
				exptokseq[i] = (int[]) jj_expentries[i];
			}
			return new ParseException(token, exptokseq, ParserConstants.TokenImage);
		}

		public void EnableTracing()
		{
		}

		public void DisableTracing()
		{
		}

		private void RescanToken()
		{
			jj_rescan = true;
			for (int i = 0; i < 12; i++)
			{
				Calls p = jj_2_rtns[i];
				do
				{
					if (p.Gen > jj_gen)
					{
						jj_la = p.Arg;
						jj_lastpos = jj_scanpos = p.First;
						switch (i)
						{
							case 0:
								jj_3_1();
								break;

							case 1:
								jj_3_2();
								break;

							case 2:
								jj_3_3();
								break;

							case 3:
								jj_3_4();
								break;

							case 4:
								jj_3_5();
								break;

							case 5:
								jj_3_6();
								break;

							case 6:
								jj_3_7();
								break;

							case 7:
								jj_3_8();
								break;

							case 8:
								jj_3_9();
								break;

							case 9:
								jj_3_10();
								break;

							case 10:
								jj_3_11();
								break;

							case 11:
								jj_3_12();
								break;

						}
					}
					p = p.Next;
				} while (p != null);
			}
			jj_rescan = false;
		}

		private void Save(int index, int xla)
		{
			Calls p = jj_2_rtns[index];
			while (p.Gen > jj_gen)
			{
				if (p.Next == null)
				{
					p = p.Next = new Calls();
					break;
				}
				p = p.Next;
			}
			p.Gen = jj_gen + xla - jj_la;
			p.First = token;
			p.Arg = xla;
		}

		private sealed class Calls
		{
			internal int Gen;
			internal Token First;
			internal int Arg;
			internal Calls Next;
		}
	}
}
