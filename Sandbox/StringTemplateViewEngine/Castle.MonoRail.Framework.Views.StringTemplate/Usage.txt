== Simple Usage ==
The StringTemplateViewEngine can be as-is by modifying the <viewEngine>
definition in your web.config file to be:

 <viewEngine 
 	viewPathRoot="Views" 
 	customEngine="Castle.MonoRail.Framework.Views.StringTemplate.StringTemplateViewEngine, Castle.MonoRail.Framework.Views.StringTemplate"/>

The viewPathRoot can be anywhere. The important part is the customEngine declaration.

All your views must end with ".st" as per the StringTemplate requirement.

== Layouts ==
Layouts follow the same method as the NVelocity view engine. They are placed within the Layouts
directory and named after the layout name. They contain a $childContent$ which contains
the contents to wrap around your layout.

== Automatic Template Inheritance ==
All templates will automatically be created in a nested within two StringTemplateGroups.
The first StringTemplateGroup is created within the viewPathRoot location, allowing
all your templates to reference shared views automatically. The second, and immediate parent
of your view is created within the Controller's view directory, allowing you to use local views
or override global views.

Eg, your files are arranged as follows:

MyApp\Views\Footer.st
MyApp\Views\Home\Index.st
MyApp\Views\Home\ListOptions.st


The Footer.st may be:
 Created with MonoRail!

The Index.st:
 Welcome $name$. Your options are: $options:ListOptions(); seperator=", "$
 $Footer()$

The ListOptions.st:
 <a href="$it.Url$">$it.LinkText$</a>

The output will be:
 Welcome Sean. Your options are: <a href="Home.rails">Home</a>, <a href="MyAccount.rails">My Account</a>
 Created with MonoRail!


But adding the file:
MyApp\Views\Home\Footer.st

With the contents
 Goodbye!

Will result in:
 Welcome Sean. Your options are: <a href="Home.rails">Home</a>, <a href="MyAccount.rails">My Account</a>
 Goodbye!


== Configuration  ==
The view engine also supports a configuration section. In your web.config:
 <configSections>
 	<section name="stView" type="Castle.MonoRail.Framework.Views.StringTemplate.StringTemplateSectionHandler, Castle.MonoRail.Framework.Views.StringTemplate" />
 </configSections>
 
 <stView templateWriterClass="MyApp.Writer, MyApp" delimiterClass="MyApp.Delimiter, MyApp">
 	<renderers>
 		<renderer targetClass="System.String" rendererClass="MyApp.EscapeHtml, MyApp"/>
 	</renderers>
 </stView>

Note templateWriterClass, delimiterClass, and <renderer> are all optional.

=== templateWriterClass ===
This allows you to define your own writer class. 
Your writer class must implement StringTemplateWriter, and currently the constructor
can and must only contain one argument:

 public MyWriter(TextWriter output);

The default is to use the AutoIndentWriter. Change it like this:
 <stView templateWriterClass="antlr.stringtemplate.NoIndentWriter, stringtemplate"/>

=== delimiterClass ===
This allows you to specify or create a custom lexer, which lets you change from $..$ or <..> to
any other delimiters you'd like.

The default is to use $..$ but if you would like to use <..> specify
 <stView delimiterClass="antlr.stringtemplate.language.AngleBracketTemplateLexer, stringtemplate"/>

=== Renderers ===
This section allows you to define how you want your data to look on the view. These have a myrid of
wonderful applications: for example, they are particularly useful for displaying 
numbers in a nice way (1,000,000.50 instead of 1000000.5), or automatically
escaping html in strings.

An example of the latter:
 <renderers>
 	<renderer targetClass="System.String" rendererClass="MyApp.EscapeHtml, MyApp"/>
 </renderers>

Where MyApp.EscapeHtml could be:
 namespace MyApp
 {
 	using antlr.stringtemplate;
 
 	public class EscapeHtml : AttributeRenderer
 	{
 		public EscapeHtml()
 		{
 		}
 
 		public string ToString(object o)
 		{
 			if (o != null) return o.ToString().Replace("<", "&lt;").Replace(">", "&gt;");
 			else return "";
 		}
 	}
 }
